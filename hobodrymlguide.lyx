#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass hobo
\use_default_options true
\master hobo.lyx
\begin_modules
logicalmkup
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection*
What is DRYML?
\end_layout

\begin_layout Standard
DRYML is a template language for Ruby on Rails that you can use in place
 of Rails’ built-in ERB templates.
 It is part of the larger Hobo project, but will eventually be made available
 as a separate plugin.
\end_layout

\begin_layout Standard
DRYML was created in response to the observation that the vast majority
 of Rails development time seems to be spent in the view-layer.
 Rails’ models are beautifully declarative, the controllers can be made
 so pretty easily (witness the many and various “result controller” plugins),
 but the views, ah the views…
\end_layout

\begin_layout Standard
Given that so much of the user interaction we encounter on the web is so
 similar from one website to another, surely we don’t have to code all this
 stuff up from low-level primitives over and over again? Please, no! 
\end_layout

\begin_layout Standard
Of course what we want is a nice library of ready-to-go user interface component
s, or widgets, which can be quickly added to our project, and easily tailored
 to the specifics of our application.
\end_layout

\begin_layout Standard
If you’ve been at this game for a while you’re probably frowning about now.
 Re-use is a very, very thorny problem.
 It’s one of those things that sounds straight-forward and obvious in principle,
 but turns out to be horribly difficult in practice.
 When you come to re-use something, you very often find that your new needs
 differ from the original ones in a way that wasn’t foreseen or catered
 for in the design of the component.
 The more complex the component, the more likely it is that bending the
 thing to your needs will be harder than starting again from scratch.
\end_layout

\begin_layout Standard
So the challenge is not in being able to re-use code, it is:
\end_layout

\begin_layout Standard
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
\begin_inset Flex Emph
status collapsed

\begin_layout Plain Layout
Being able to re-use code in ways that were not foreseen.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reason we created DRYML was to see if this kind of flexibility could
 be built into the language itself.
 DRYML is a tag-based language that makes it trivially easy to give the
 defined tags a great deal of flexibility.
\end_layout

\begin_layout Standard
So DRYML is just a means to an end.
 The real goal is to create a library of reusable user-interface components
 that actually succeed in making it very quick and easy to create the view
 layer of a web application.
\end_layout

\begin_layout Standard
That library is also part of Hobo – the 
\begin_inset Flex Emph
status collapsed

\begin_layout Plain Layout
Rapid
\end_layout

\end_inset

 tag library.
 You will visit this library later on in the book.
 Here we will see how DRYML provides the tools and raw materials that make
 a library like Rapid possible.
\end_layout

\begin_layout Standard
Discussing DRYML before Rapid means that many of the examples are 
\begin_inset Flex Emph
status collapsed

\begin_layout Plain Layout
not
\end_layout

\end_inset

 good advice for use of DRYML in a full Hobo app.
 For example, you might see
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
<%= h this.name %>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Which in an app that used Rapid would be better written 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<view:name/>
\end_layout

\end_inset

 or even just 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<name/>
\end_layout

\end_inset

 (that’s a tag by the way, called 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
name
\end_layout

\end_inset

, not some metaprogramming trick that lets you use field names as tags).
 Bear that in mind while you’re reading this chapter.
 The examples are chosen to illustrate the point at hand, they are not necessari
ly something you want to paste right into your application.
\end_layout

\begin_layout Subsection*
Simple page templates and ERB
\end_layout

\begin_layout Standard
In its most basic usage, DRYML can be indistinguishable from a normal Rails
 template.
 That’s because DRYML is (almost) an extension of ERB, so you can still
 insert Ruby snippets using the 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<% ...
 %>
\end_layout

\end_inset

 notation.
 For example, a show-page for a blog post might look like this:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
<html>
\end_layout

\begin_layout LyX-Code
  <head>
\end_layout

\begin_layout LyX-Code
    <title>My Blog</title>
\end_layout

\begin_layout LyX-Code
  </head>
\end_layout

\begin_layout LyX-Code
  <body>
\end_layout

\begin_layout LyX-Code
    <h1>My Famous Blog!</h1>
\end_layout

\begin_layout LyX-Code
    <h2><%= @post.title %></h2>
\end_layout

\begin_layout LyX-Code
    <div class="post-body"> 
\end_layout

\begin_layout LyX-Code
      <%= @post.body %>
\end_layout

\begin_layout LyX-Code
    </div>
\end_layout

\begin_layout LyX-Code
  </body>
\end_layout

\begin_layout LyX-Code
</html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
No ERB inside tags
\end_layout

\end_inset


\end_layout

\begin_layout Standard
DRYML’s support for ERB is not quite the same as true ERB templates.
 The one thing you can’t do is use ERB snippets inside a tag.
 To have the value of an attribute generated dynamically in ERB, you could
 do:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
<a href="<%= my_url %>">
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In DRYML you would do:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
<a href="#{my_url}">
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In rare cases, you might use an ERB snippet to output one or more entire
 attributes:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
<form <%= my_attributes %>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We’re jumping ahead here, so just skip this if it doesn’t make sense, but
 to do the equivalent in DRYML, you would need your attributes to be in
 a hash (rather than a string), and do:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
<form merge-attrs="&my_attributes">
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, in a rare case you could even use an ERB snippet to generate the
 tag name itself:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
<<%= my_tag_name %>> ...
 </<%= my_tag_name %>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To achieve that in DRYML, you could put the angle brackets in the snippet
 too:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code
<%= "<#{my_tag_name}>" %> ...
 <%= "</#{my_tag_name}>" %>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Where are the layouts?
\end_layout

\begin_layout Standard
Going back to the 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<page>
\end_layout

\end_inset

 tag at the start of this section, from a “normal Rails” perspective, you
 might be wondering why the boilerplate stuff like 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<html>
\end_layout

\end_inset

, 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<head>
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<body>
\end_layout

\end_inset

 are there.
 What happened to layouts? You don’t tend to use layouts with DRYML, instead
 you would define your own tag, typically 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<page>
\end_layout

\end_inset

, and call that.
 Using tags for layouts is much more flexible, and it moves the choice of
 layout out of the controller and into the view layer, where it should be.
\end_layout

\begin_layout Standard
We’ll see how to define a 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<page>
\end_layout

\end_inset

 tag in the next section.
\end_layout

\begin_layout Subsection*
Defining simple tags
\end_layout

\begin_layout Standard
One of the strengths of DRYML is that defining tags is done right in the
 template (or in an imported tag library) using the same XML-like syntax.
 This means that if you’ve got markup you want to re-use, you can simply
 cut-and-paste it into a tag definition.
\end_layout

\begin_layout Standard
Here’s the page from the previous section, defined as a <page> tag simply
 by wrapping the markup in a <def> tag:
\end_layout

\begin_layout Standard
<def tag="page">
\end_layout

\begin_layout Standard
<html>
\end_layout

\begin_layout Standard
<head> 
\end_layout

\begin_layout Standard
<title>My Blog</title>
\end_layout

\begin_layout Standard
</head>
\end_layout

\begin_layout Standard
<body>
\end_layout

\begin_layout Standard
<h1>My Famous Blog!</h1>
\end_layout

\begin_layout Standard
<h2><%= @post.title %></h2>
\end_layout

\begin_layout Standard
<div class="post-body">
\end_layout

\begin_layout Standard
<%= @post.body %>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</body>
\end_layout

\begin_layout Standard
</html>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Now we can call that tag just as we would call any other:
\end_layout

\begin_layout Standard
<page/>
\end_layout

\begin_layout Standard
If you’d like an analogy to “normal” programming, you can think of the <def>...</de
f> as defining a method called page, and <page/> as a call to that method.
\end_layout

\begin_layout Standard
In fact, DRYML is implemented by compiling to Ruby, and that is exactly
 what is happening.
\end_layout

\begin_layout Standard
Parameters
\end_layout

\begin_layout Standard
We’ve illustrated the most basic usage of <def>, but our <page> tag is not
 very useful.
 Let’s take it a step further to make it into the equivalent of a layout.
 First of all, we clearly need the body of the page to be different each
 time we call it.
\end_layout

\begin_layout Standard
In DRYML we achieve this by adding parameters to the definition, which is
 accomplished with the param attribute.
 Here’s the new definition:
\end_layout

\begin_layout Standard
<def tag="page">
\end_layout

\begin_layout Standard
<html>
\end_layout

\begin_layout Standard
<head>
\end_layout

\begin_layout Standard
<title>My Blog</title> 
\end_layout

\begin_layout Standard
</head>
\end_layout

\begin_layout Standard
<body param/>
\end_layout

\begin_layout Standard
</html>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Now we can call the <page> tag and provide our own body:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<body:>
\end_layout

\begin_layout Standard
<h1>My Famous Blog!</h1> 
\end_layout

\begin_layout Standard
<h2><%= @post.title %></h2> 
\end_layout

\begin_layout Standard
<div class="post-body"> 
\end_layout

\begin_layout Standard
<%= @post.body %>
\end_layout

\begin_layout Standard
</div> 
\end_layout

\begin_layout Standard
</body:>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
See how easy that was? We just added param to the <body> tag, which means
 our page tag now has a parameter called body.
 In the <page> call we provide some content for that parameter.
 
\end_layout

\begin_layout Standard
It’s very important to read that call to <page> properly.
 In particular, the <body:> (note the trailing ’:’) is not a call to a tag,
 it is providing a named parameter to the call to <page>.
 We call <body:> a parameter tag.
 In Ruby terms you could think of the call like this:
\end_layout

\begin_layout Standard
page(:body => "...my body content...")
\end_layout

\begin_layout Standard
Note that is not actually what the compiled Ruby looks like in this case,
 but it illustrates the important point that <page> is a call to a defined
 tag, whereas <body:> is providing a parameter to that call.
\end_layout

\begin_layout Standard
Changing Parameter Names
\end_layout

\begin_layout Standard
To give the parameter a different name, we can provide a value to the param
 attribute:
\end_layout

\begin_layout Standard
<def tag="page">
\end_layout

\begin_layout Standard
<html>
\end_layout

\begin_layout Standard
<head>
\end_layout

\begin_layout Standard
<title>My Blog</title>
\end_layout

\begin_layout Standard
</head> 
\end_layout

\begin_layout Standard
<body param="content"/> 
\end_layout

\begin_layout Standard
</html>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
We would now call the tag like this:
\end_layout

\begin_layout Standard
<page><content:> ...body content goes here...
 </content:></page>
\end_layout

\begin_layout Standard
Multiple Parameters
\end_layout

\begin_layout Standard
As you would expect, we can define many parameters in a single tag.
 For example, here’s a page with a side-bar:
\end_layout

\begin_layout Standard
<def tag="page">
\end_layout

\begin_layout Standard
<html> 
\end_layout

\begin_layout Standard
<head>
\end_layout

\begin_layout Standard
<title>My Blog</title>
\end_layout

\begin_layout Standard
</head> 
\end_layout

\begin_layout Standard
<body> 
\end_layout

\begin_layout Standard
<div param="content"/> 
\end_layout

\begin_layout Standard
<div param="aside" /> 
\end_layout

\begin_layout Standard
</body>
\end_layout

\begin_layout Standard
</html>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Which we could call like this:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<content:> ...
 main content here ...
 </content:>
\end_layout

\begin_layout Standard
<aside:> ...
 aside content here ...
 </aside:>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
Note that when you name a parameter, DRYML automatically adds a CSS class
 of the same name to the output, so the two <div> tags above will be output
 as <div class="content"> and <div class="aside"> respectively.
\end_layout

\begin_layout Standard
Default Parameter Content
\end_layout

\begin_layout Standard
In the examples we’ve seen so far, we’ve only put the param attribute on
 empty tags.
 That’s not required though.
 If you declare a non-empty tag as a parameter, the content of that tag
 becomes the default when the call does not provide that parameter.
 This means you can easily add a parameter to any part of the template that
 you think the caller might want to be able to change:
\end_layout

\begin_layout Standard
<def tag="page">
\end_layout

\begin_layout Standard
<html>
\end_layout

\begin_layout Standard
<head> 
\end_layout

\begin_layout Standard
<title param>My Blog</title>
\end_layout

\begin_layout Standard
</head> 
\end_layout

\begin_layout Standard
<body param>
\end_layout

\begin_layout Standard
</html>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
We’ve made the page title parameterized.
 All existing calls to <page/> will continue to work unchanged, but we’ve
 now got the ability to change the title on a per-page basis:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<title:>My VERY EXCITING Blog</title:>
\end_layout

\begin_layout Standard
<body:>
\end_layout

\begin_layout Standard
...
 body content
\end_layout

\begin_layout Standard
</body:> 
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
This is a very nice feature of DRYML - whenever you’re writing a tag, and
 you see a part that might be useful to change in some situations, just
 throw the param attribute at it and you’re done.
\end_layout

\begin_layout Standard
Nested param Declarations
\end_layout

\begin_layout Standard
You can nest param declarations inside other tags that have param on them.
 For example, there’s no need to choose between a <page> tag that provides
 a single content section and one that provides an aside section as well
 – a single definition can serve both purposes:
\end_layout

\begin_layout Standard
<def tag="page">
\end_layout

\begin_layout Standard
<html>
\end_layout

\begin_layout Standard
<head>
\end_layout

\begin_layout Standard
<title>My Blog</title>
\end_layout

\begin_layout Standard
</head>
\end_layout

\begin_layout Standard
<body param>
\end_layout

\begin_layout Standard
<div param="content"/>
\end_layout

\begin_layout Standard
<div param="aside" />
\end_layout

\begin_layout Standard
</body>
\end_layout

\begin_layout Standard
</html>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Here the <body> tag is a param, and so are the two <div> tags inside it.
 The <page> tag can be called either like this:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<body:> ...
 page content goes here ...
 </body:>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
Or like this:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<content:> ...
 main content here ...
 </content:> 
\end_layout

\begin_layout Standard
<aside:> ...
 aside content here ...
 </aside:>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
An interesting question is, what happens if you give both a <body:> parameter
 and say, <content:>.
 By providing the <body:> parameter, you have replaced everything inside
 the body section, including those two parameterized <div> tags, so the
 <body:> you have provided will appear as normal, but the <content:> parameter
 will be silently ignored.
\end_layout

\begin_layout Standard
The Default Parameter
\end_layout

\begin_layout Standard
In the situation where a tag will usually be given a single parameter when
 called, you can give your tag a more compact XML-like syntax by using the
 special parameter name default:
\end_layout

\begin_layout Standard
<def tag="page"> 
\end_layout

\begin_layout Standard
<html>
\end_layout

\begin_layout Standard
<head>
\end_layout

\begin_layout Standard
<title>My Blog</title>
\end_layout

\begin_layout Standard
</head> 
\end_layout

\begin_layout Standard
<body param="default"/> 
\end_layout

\begin_layout Standard
</html
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Now there is no need to give a parameter tag in the call at all - the content
 directly inside the <page> tag becomes the default parameter:
\end_layout

\begin_layout Standard
<page> ...
 body content goes here -- no need for a parameter tag ...
 </page>
\end_layout

\begin_layout Standard
You might notice that the <page> tag is now indistinguishable from a normal
 HTML tag.
 Some find this aspect of DRYML disconcerting at first – how can you tell
 what is an HTML tag and what it a defined DRYML tag? The answer is – you
 can’t, and that’s quite deliberate.
 This allows you to do nice tricks like define your own smart <form> tag
 or <a> tag (the Rapid library does exactly that).
 Other tag-based template languages (e.g.
 Java’s JSP) like to put everything in XML namespaces.
 The result is very cluttered views that are boring to type and hard to
 read.
 From the start we put a very high priority on making DRYML templates compact
 and elegant.
 When you’re new to DRYML you might have to do a lot of looking things up,
 as you would with any new language or API, but things gradually become
 familiar and then view templates can be read and understood very easily.
\end_layout

\begin_layout Standard
The Implicit Context
\end_layout

\begin_layout Standard
In addition to the most important goal behind DRYML - creating a template
 language that would encourage re-use in the view layer, a secondary goal
 is for templates to be concise, elegant and readable.
 One aspect of DRYML that helps a lot in this regard is something called
 the implicit context.
\end_layout

\begin_layout Standard
This feature was born of a simple observation that pretty much every page
 in a web app renders some kind of hierarchy of application objects.
 Think about a simple page in a blog - say, the permalink page for an individual
 post.
 The page as a whole can be considered a rendering of a BlogPost object.
 Then we have sections of the page that display different “pieces” of the
 post – the title, the date, the author’s name, the body.
 Then we have the comments.
 The list of comments as a whole is also a “piece” of the BlogPost.
 Within that we have each of the individual comments, and the whole thing
 starts again: the comment title, date, author… This can carry on even further,
 for example some blogs are set up so that you can comment on comments.
\end_layout

\begin_layout Standard
This structure is incredibly common, perhaps even universal, as it seems
 to be intrinsically tied to the way we visually parse information.
 DRYML’s implicit context takes advantage of this fact to make templates
 extremely concise while remaining readable and clear.
 The object that you are rendering in any part of the page is known as the
 context, and every tag has access to this object through the method this.
 The controller sets up the initial context, and the templates then only
 have to mention where the context needs to change.
\end_layout

\begin_layout Standard
We’ll dive straight into some examples, but first a quick general point
 about this guide.
 If you like to use the full Hobo framework, you will probably always use
 DRYML and the Rapid tag library together.
 DRYML and Rapid have grown up together, and the design of each is heavily
 influenced by the other.
 Having said that, this is the DRYML Guide, not the Rapid Guide.
 We won’t be using any Rapid tags in this guide, because we want to document
 DRYML the language properly.
 That will possibly be a source of confusion if you’re very used to working
 with Rapid.
 Just keep in mind that we’re not allowed to use any Rapid tags in this
 guide and you’ll be fine.
\end_layout

\begin_layout Standard
In order to see the implicit context in its best light, we’ll start by defining
 a <view> tag, that simply renders the current context with HTML escaping.
 Remember the context is always available as this:
\end_layout

\begin_layout Standard
<def tag="view"><%= h this.to_s %></def>
\end_layout

\begin_layout Standard
Next we’ll define a tag for making a link to the current context.
 We’ll assume the object will be recognized by Rails’ polymorphic routing.
 Let’s call the tag <l> (for link):
\end_layout

\begin_layout Standard
<def tag="l"><a href="#{url_for this}" param="default"/></def>
\end_layout

\begin_layout Standard
Now let’s use these tags in a page template.
 We’ll stick with the comfortingly boring blog post example.
 In order to set the initial context, our controller action would need to
 do something like this:
\end_layout

\begin_layout Standard
def show @this = @blog_post = BlogPost.find(params[:id]) end
\end_layout

\begin_layout Standard
The DRYML template handler looks for the @this instance variable for the
 initial context.
 It’s quite nice to also set the more conventionally named instance variable
 as we’ve done here.
\end_layout

\begin_layout Standard
Now we’ll create the page.
 Let’s assume we’re using a <page> tag along the lines of those defined
 above.
 We’ll also assume that the blog post object has these fields: title, published_
at, body and belongs_to :author, and that the author has a name field:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<content:>
\end_layout

\begin_layout Standard
<h2><view:title/></h2> 
\end_layout

\begin_layout Standard
<div class="details"> 
\end_layout

\begin_layout Standard
Published by <l:author><view:name/></l> on <view:published-at/>.
\end_layout

\begin_layout Standard
</div> 
\end_layout

\begin_layout Standard
<div class="post-body">
\end_layout

\begin_layout Standard
<view:body/>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</content:>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
When you see a tag like <view:title/>, you don’t get any prizes for guessing
 what will be displayed.
 In terms of what actually happens, you can read this as “change the context
 to be the title attribute of the current context, then call the <view>
 tag”.
 You might like to think of that change to the context as this = this.title
 (although in fact this is not assignable).
 But really you just think of it as “view the title”.
 Of what? Of whatever is in context, in this case the blog post.
\end_layout

\begin_layout Standard
Be careful with the two different uses of colon in DRYML.
 A trailing colon as in <foo:> indicates a parameter tag, whereas a colon
 joining two names as in <view:title/> indicates a change of context.
\end_layout

\begin_layout Standard
When the tag ends, the context is set back to what it was.
 In the case of <view/> which is a self-closing tag familiar from XML, that
 happens immediately.
 The <l:author> tag is more interesting.
 We set the context to be the author, so that the link goes to the right
 place.
 Inside the <l:author> that context remains in place so we just need <view:name/
> in order to display the author’s name.
\end_layout

\begin_layout Standard
with and field attributes
\end_layout

\begin_layout Standard
The with attribute is a special DRYML attribute that sets the context to
 be the result of any Ruby expression before the tag is called.
 In DRYML any attribute value that starts with ’&’ is interpreted as a Ruby
 expression.
 Here’s the same example as above using only the with attribute:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<content:>
\end_layout

\begin_layout Standard
<h2><view with="&@blog_post.title"/></h2>
\end_layout

\begin_layout Standard
<div class="details">
\end_layout

\begin_layout Standard
Published by <l with="&@blog_post.author"><view with="&this.name"/></l>
\end_layout

\begin_layout Standard
on <view with="&@blog_post.published-at"/>.
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
<div class="post-body">
\end_layout

\begin_layout Standard
<view with="&@blog_post.body"/> 
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</content:>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
Note that we could have used &this.title instead of &@blog_post.title.
\end_layout

\begin_layout Standard
The field attribute makes things more concise by taking advantage of a common
 pattern.
 When changing the context, we very often want to change to some attribute
 of the current context.
 field="x" is a shorthand for with="&this.x" (actually it’s not quite the
 same, using the field version also sets this_parent and this_field, whereas
 with does not.
 This is discussed later in more detail).
\end_layout

\begin_layout Standard
The same template again, this time using field:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<content:> 
\end_layout

\begin_layout Standard
<h2><view field="title"/></h2>
\end_layout

\begin_layout Standard
<div class="details"> 
\end_layout

\begin_layout Standard
Published by <l field="author"><view field="name"/></l>
\end_layout

\begin_layout Standard
on <view field="published-at"/>.
\end_layout

\begin_layout Standard
</div> 
\end_layout

\begin_layout Standard
<div class="post-body"> 
\end_layout

\begin_layout Standard
<view field="body"/>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</content:>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
If you compare that example to the first one, you should notice that the
 : syntax is just a shorthand for the field attribute; i.e., <view field="name">
 and <view:name> are equivalent.
\end_layout

\begin_layout Standard
Field chains
\end_layout

\begin_layout Standard
Sometimes you want to drill down through several fields at a time.
 Both the field attribute and the : shorthand support this.
 For example:
\end_layout

\begin_layout Standard
<view:category.name/> <view field="category.name"/>
\end_layout

\begin_layout Standard
this_field and this_parent
\end_layout

\begin_layout Standard
When you change the context using field="my-field" (or the <tag:my-field>
 shorthand), the previous context is available as this_parent, and the name
 of the field is available as this_field.
 If you set the context using with="...", these values are not available.
 That means the following apparently identical tag calls are not quite the
 same:
\end_layout

\begin_layout Standard
<my-tag with="&@post.title"/> <my-tag with="&@post" field="title"/>
\end_layout

\begin_layout Standard
If the tag requires this_parent and this_field, and in Rapid, for example,
 some do, then it must be called using the second style.
\end_layout

\begin_layout Standard
Numeric field indices
\end_layout

\begin_layout Standard
If your current context is a collection, you can use the field attribute
 to change the context to a single item.
\end_layout

\begin_layout Standard
<my-tag field="7" />
\end_layout

\begin_layout Standard
<% i=97 %>
\end_layout

\begin_layout Standard
<my-tag field="&i" />
\end_layout

\begin_layout Standard
The <repeat> tag sets this_field to the current index into the collection.
\end_layout

\begin_layout Standard
<repeat:foos>
\end_layout

\begin_layout Standard
<td><%= this_field %></td>
\end_layout

\begin_layout Standard
<td><view /></td>
\end_layout

\begin_layout Standard
</repeat>
\end_layout

\begin_layout Standard
Forms
\end_layout

\begin_layout Standard
When rendering the Rapid library’s <form> tag, DRYML keeps track of even
 more metadata in order to add name attributes to form fields automatically.
 This mechanism does not work if you set the context using with=.
\end_layout

\begin_layout Standard
Tag attributes
\end_layout

\begin_layout Standard
As we’ve seen, DRYML provides parameters as a mechanism for Customizing
 the markup that is output by a tag.
 Sometimes we want to provide other kinds of values to control the behavior
 of a tag: URLs, filenames or even Ruby values like hashes and arrays.
 For this situation, DRYML lets you define tag attributes.
\end_layout

\begin_layout Standard
As a simple example, say your application has a bunch of help files in public/he
lp, and you have links to them scattered around your views.
 Here’s a tag you could define:
\end_layout

\begin_layout Standard
<def tag="help-link" attrs="file">
\end_layout

\begin_layout Standard
<a class="help" href="#{base_url}/help/#{file}.html" param="default"/> </def>
\end_layout

\begin_layout Standard
<def> takes a special attribute attrs.
 Use this to declare a list (separated by commas) of attributes, much as
 you would declare arguments to a method in Ruby.
 Here we’ve defined one attribute, file, and just like arguments in Ruby,
 file becomes a local variable inside the tag definition.
 In this definition we construct the href attribute from the base_url helper
 and file, using Ruby string interpolation syntax (#{....}).
 Remember that you can use that syntax when providing a value for any attribute
 in DRYML.
\end_layout

\begin_layout Standard
The call to this tag would look like this:
\end_layout

\begin_layout Standard
<help-link file="intro">Introductory Help</help-link>
\end_layout

\begin_layout Standard
Using regular XML-like attribute syntax – file="intro" – passes “intro”
 as a string value to the attribute.
 DRYML also allows you to pass any Ruby value.
 When the attribute value starts with &, the rest of the attribute is interprete
d as a Ruby expression.
 For example you could use this syntax to pass true and false values:
\end_layout

\begin_layout Standard
<help-link file="intro" new-window="&true">Introductory Help</help-link>
 <help-link file="intro" new-window="&false">Introductory Help</help-link>
\end_layout

\begin_layout Standard
And we could add that new-window attribute to the definition like this:
\end_layout

\begin_layout Standard
<def tag="help-link" attrs="file, new-window">
\end_layout

\begin_layout Standard
<a class="help" href="#{base_url}/help/#{file}.html" target="#{new_window
 ? '_blank' : '_self' }" param="default"/>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
An important point to notice there is that the markup-friendly dash in the
 new-window attribute became a Ruby-friendly underscore (new_window) in
 the local variable inside the tag definition.
\end_layout

\begin_layout Standard
Using the &, you can pass any value you like – arrays, hashes, active-record
 objects…
\end_layout

\begin_layout Standard
In the case of boolean values like the one used in the above example, there
 is a nicer syntax that can be used in the call…
\end_layout

\begin_layout Standard
Flag attributes
\end_layout

\begin_layout Standard
That new-window attribute shown in the previous section is simple switch
 - on or off.
 DRYML lets you omit the value of the attribute, giving a flag-like syntax:
\end_layout

\begin_layout Standard
<help-link file="intro" new-window>Introductory Help</help-link> 
\end_layout

\begin_layout Standard
<help-link file="intro">Introductory Help</help-link>
\end_layout

\begin_layout Standard
Omitting the attribute value is equivalent to giving "&true" as the value.
 In the second example the attribute is omitted entirely, meaning the value
 will be nil which evaluates to false in Ruby and so works as expected.
\end_layout

\begin_layout Standard
attributes and all_attributes locals
\end_layout

\begin_layout Standard
Inside a tag definition two hashes are available in local variables:
\end_layout

\begin_layout Standard
attributes contains all the attributes that were not declared in the attrs
 list of the def but that were provided in the call to the tag.
\end_layout

\begin_layout Standard
all_attributes contains every attribute, including the declared ones.
\end_layout

\begin_layout Standard
Merging Attributes
\end_layout

\begin_layout Standard
In a tag definition, you can use the merge-attrs attribute to take any ‘extra’
 attributes that the caller passed in, and add them to a tag of your choosing
 inside your definition.
 Let’s backtrack a bit and see why you might want to do that.
\end_layout

\begin_layout Standard
Here’s a simple definition for a <markdown-help> tag--it’s similar to a
 tag defined in the Hobo Cookbook app:
\end_layout

\begin_layout Standard
<def tag="markdown-help">
\end_layout

\begin_layout Standard
<a href="http://daringfireball.net/..." param="default"/>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
You would use it like this:
\end_layout

\begin_layout Standard
Add formatting using <markdown-help>markdown</markdown-help>
\end_layout

\begin_layout Standard
Suppose you wanted to give the caller the ability to choose the target for
 the link.
 You could extend the definition like this:
\end_layout

\begin_layout Standard
<def tag="markdown-help" attrs="target">
\end_layout

\begin_layout Standard
<a href="http://daringfireball.net/..." target="&target" param="default"/> </def>
\end_layout

\begin_layout Standard
Now we can call the tag like this:
\end_layout

\begin_layout Standard
Add formatting using <markdown-help target="_blank">markdown</markdown-help>
\end_layout

\begin_layout Standard
OK, but maybe the caller wants to add a CSS class, or a javascript onclick
 attribute, or any one of a dozen potential HTML attributes.
 This approach is not going to scale.
 That’s where merge-attrs comes in.
 As mentioned above, DRYML keeps track of all the attributes that were passed
 to a tag, even if they were not declared in the attrs list of the tag definitio
n.
 They are available in two hashes: attributes (that has only undeclared
 attributes) and all_attributes (that has all of them), but in normal usage
 you don’t need to access those variables directly.
 To add all of the undeclared attributes to a tag inside your definition,
 just add the merge-attrs attribute, like this:
\end_layout

\begin_layout Standard
<def tag="markdown-help"> 
\end_layout

\begin_layout Standard
<a href="http://daringfireball.net/..." merge-attrs param="default"/> </def>
\end_layout

\begin_layout Standard
Note that the merge attribute is another way of merging attributes.
 Declaring merge is a shorthand for declaring both merge-attrs and merge-params
 (which we’ll cover later).
\end_layout

\begin_layout Standard
Merging selected attributes
\end_layout

\begin_layout Standard
merge-attrs can be given a value - either a hash containing attribute names
 and values, or a list of attribute names (comma separated), to be merged
 from the all_attributes variable.
\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout Standard
<a merge-attrs="href, name">
\end_layout

\begin_layout Standard
<a merge-attrs="&my_attribute_hash">
\end_layout

\begin_layout Standard
A requirement that crops up from time to time is to forward to a tag all
 the attributes that it understands (i.e.
 the attributes from that tag’s attrs list), and to forward some or all
 the other attributes to tags called within that tag.
 Say for example, we are declaring a tag that renders a section of content,
 with some navigation at the top.
 We want to be able to add CSS classes and so on to the main <div> that
 will be output, but the <navigation> tag also defines some special attributes,
 and these need to be forwarded to it.
\end_layout

\begin_layout Standard
To achieve this we take advantage of a helper method attrs_for.
 Given the name of a tag, it returns the list of attributes declared by
 that tag.
\end_layout

\begin_layout Standard
Here’s the definition:
\end_layout

\begin_layout Standard
<def tag="section-with-nav"> 
\end_layout

\begin_layout Standard
<div class="section" merge-attrs="&attributes - attrs_for(:navigation)">
 <navigation merge-attrs="&attributes & attrs_for(:navigation)"/>
\end_layout

\begin_layout Standard
<do param="default"/>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Note that:
\end_layout

\begin_layout Standard
The expression attributes - attrs_for(:navigation) returns a hash of only
 those attributes from the attributes hash that are not declared by <navigation>
 (The - operator on Hash comes from HoboSupport)
\end_layout

\begin_layout Standard
The expression attributes & attrs_for(:navigation) returns a hash of only
 those attributes from the attributes hash that are declared by <navigation>
 (The & operator on Hash comes from HoboSupport)
\end_layout

\begin_layout Standard
The <do> tag is a “do nothing” tag, defined by the core DRYML taglib, which
 is always included.
\end_layout

\begin_layout Standard
The class attribute
\end_layout

\begin_layout Standard
If you have the following definition:
\end_layout

\begin_layout Standard
<def tag="foo"> <div id="foo" class="bar" merge-attrs /> </def>
\end_layout

\begin_layout Standard
and the user invokes it with:
\end_layout

\begin_layout Standard
<foo id="baz" class="bop" />
\end_layout

\begin_layout Standard
The following content will result:
\end_layout

\begin_layout Standard
<foo id="baz" class="bar bop" />
\end_layout

\begin_layout Standard
The class attribute receives special behavior when merging.
 All other attributes are overridden with the user specified values.
 The class attribute takes on the values from both the tag definition and
 invocation.
\end_layout

\begin_layout Standard
Repeated and optional content
\end_layout

\begin_layout Standard
As you would expect from any template language, DRYML has the facility to
 repeat sections of content, and to optionally render or not render given
 sections according to your application’s data.
 DRYML provides two alternative syntaxes, much as Ruby does (e.g.
 Ruby has the block if and the one-line suffix version of if).
\end_layout

\begin_layout Standard
Conditionals - if and unless
\end_layout

\begin_layout Standard
DRYML provides if and unless both as tags, which come from the core tag
 library, and are just ordinary tag definitions, and as attributes, which
 are part of the language:
\end_layout

\begin_layout Standard
The tag version:
\end_layout

\begin_layout Standard
<if test="&logged_in?"><p>Welcome back</p></if>
\end_layout

\begin_layout Standard
The attribute version:
\end_layout

\begin_layout Standard
<p if="&logged_in?">Welcome back</p>
\end_layout

\begin_layout Standard
Important note! The test is performed (in Ruby terms) like this:
\end_layout

\begin_layout Standard
if (...your test expression...).blank?
\end_layout

\begin_layout Standard
Got that? Blankiness not truthiness (blank? comes from ActiveSupport by
 the way – Rails’ mixed bag of core-Ruby extensions).
 So for example, in DRYML:
\end_layout

\begin_layout Standard
<if test="&current_user.comments">
\end_layout

\begin_layout Standard
is a test to see if there are any comments – empty collections are considered
 blank.
 We are of the opinion that Matz made a fantastic choice for Ruby when he
 followed the Lisp / Smalltalk approach to truth values, but that view templates
 are a special case, and testing for blankness is more often what you want.
\end_layout

\begin_layout Standard
Can we skip <unless>? It’s like <if> with the nest negated.
 You get the picture, right?
\end_layout

\begin_layout Standard
Repetition
\end_layout

\begin_layout Standard
For repeating sections of content, DRYML has the <repeat> tag (from the
 core tag library) and the repeat attribute.
\end_layout

\begin_layout Standard
The tag version:
\end_layout

\begin_layout Standard
<repeat with="&current_user.new_messages">
\end_layout

\begin_layout Standard
<h3><%= h this.subject %></h3>
\end_layout

\begin_layout Standard
</repeat>
\end_layout

\begin_layout Standard
The attribute version:
\end_layout

\begin_layout Standard
<h3 repeat="&current_user.new_messages"><%= h this.subject %></h3>
\end_layout

\begin_layout Standard
Notice that as well as the content being repeated, the implicit context
 is set to each item in the collection in turn.
\end_layout

\begin_layout Standard
Even/odd classes
\end_layout

\begin_layout Standard
It’s a common need to want alternating styles for items in a collection
 - e.g.
 striped table rows.
 Both the repeat attribute and the repeat tag set a scoped variable scope.even_od
d which will be alternately ‘even’ then ‘odd’, so you could do:
\end_layout

\begin_layout Standard
<h3 repeat="&new_messages" class="#{scope.even_odd}"><%= h this.subject %></h3>
\end_layout

\begin_layout Standard
That example illustrates another important point – any Ruby code in attributes
 is evaluated inside the repeat.
 In other words, the repeat attribute behaves the same as wrapping the tag
 in a <repeat> tag.
\end_layout

\begin_layout Standard
first_item? and last_item? helpers
\end_layout

\begin_layout Standard
Another common need is to give special treatment to the first and last items
 in a collection.
 The first_item? and last_item? helpers can be used to find out when these
 items come up; e.g., we could use first_item? to capitalise the first item:
\end_layout

\begin_layout Standard
<h3 repeat="&new_messages"><%= h(first_item? ? this.subject.upcase : this.subject)
 %></h3>
\end_layout

\begin_layout Standard
Repeating over hashes
\end_layout

\begin_layout Standard
If you give a hash as the value to repeat over, DRYML will iterate over
 each key/value pair, with the value available as this (i.e.
 the implicit context) and the key available as this_key.
 This is particularly useful for grouping things in combination with the
 group_by method:
\end_layout

\begin_layout Standard
<div repeat="&current_user.new_messages.group_by(&:sender)"> 
\end_layout

\begin_layout Standard
<h2>Messages from <%= h this_key %></h2>
\end_layout

\begin_layout Standard
<ul> 
\end_layout

\begin_layout Standard
<li repeat><%= h this.subject %></li>
\end_layout

\begin_layout Standard
</ul>
\end_layout

\begin_layout Standard
<h2>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
That example has given a sneak preview of another point - using if/unless/repeat
 with the implicit context.
 We’ll get to that in a minute.
\end_layout

\begin_layout Standard
Using the implicit context
\end_layout

\begin_layout Standard
If you don’t specify the test of a conditional, or the collection to repeat
 over, the implicit context is used.
 This allows for a few nice shorthands.
 For example, this is a common pattern for rendering collections:
\end_layout

\begin_layout Standard
<if:comments> 
\end_layout

\begin_layout Standard
<h3>Comments</h3> 
\end_layout

\begin_layout Standard
<ul> 
\end_layout

\begin_layout Standard
<li repeat> ...
 </li>
\end_layout

\begin_layout Standard
</ul>
\end_layout

\begin_layout Standard
</if>
\end_layout

\begin_layout Standard
We’re switching the context on the <if> tag to be this.comments, which has
 two effects.
 Firstly the comments collection is used as the test for the if, so the
 whole section including the heading will be omitted if the collection is
 empty (remember that if tests for blankness, and empty collections are
 considered blank).
 Secondly, the context is switched to be the comments collection, so that
 when we come to repeat the <li> tag, all we need to say is repeat.
\end_layout

\begin_layout Standard
One last shorthand - attributes of this
\end_layout

\begin_layout Standard
The attribute versions of if/unless and repeat support a useful shortcut
 for accessing attributes or methods of the implicit context.
 If you give a literal string attribute–that is, an attribute that does
 not start with &–this is interpreted as the name of a method on this.
 For example:
\end_layout

\begin_layout Standard
<li repeat="comments"/>
\end_layout

\begin_layout Standard
is equivalent to
\end_layout

\begin_layout Standard
<li repeat="&this.comments"/>
\end_layout

\begin_layout Standard
Similarly
\end_layout

\begin_layout Standard
<p if="sticky?">This post has been marked 'sticky'</p>
\end_layout

\begin_layout Standard
is equivalent to
\end_layout

\begin_layout Standard
<p if="this.sticky?">This post has been marked 'sticky'</p>
\end_layout

\begin_layout Standard
It is a bit inconsistent that these shortcuts do not work with the tag versions
 of <if>, <unless> and <repeat>.
 This may be remedied in a future version of DRYML.
\end_layout

\begin_layout Standard
Content tags only
\end_layout

\begin_layout Standard
The attributes introduced in this section – repeat, if and unless, can only
 be used on content tags, i.e.
 static HTML tags and defined tags.
 They cannot be used on tags like <def>, <extend> and <include>.
\end_layout

\begin_layout Standard
Pseudo parameters - before, after, append, prepend, and replace
\end_layout

\begin_layout Standard
For every parameter you define in a tag, there are five “pseudo parameters”
 created as well.
 Four allow you to insert extra content without replacing existing content,
 and one lets you replace or remove a parameter entirely.
\end_layout

\begin_layout Standard
To help illustrate these, here’s a very simple <page> tag:
\end_layout

\begin_layout Standard
<def tag="page"> 
\end_layout

\begin_layout Standard
<body>
\end_layout

\begin_layout Standard
<h1 param="heading"><%= h @this.to_s %></h1>
\end_layout

\begin_layout Standard
<div param="content"></div>
\end_layout

\begin_layout Standard
</body>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
We’ve assumed that @this.to_s will give us the name of the object that this
 page is presenting.
\end_layout

\begin_layout Standard
Inserting extra content
\end_layout

\begin_layout Standard
The output of the heading would look something like:
\end_layout

\begin_layout Standard
<h1 class="heading">Welcome to my new blog</h1>
\end_layout

\begin_layout Standard
Pseudo parameters give us the ability to insert extra context in four places,
 marked here as (A), (B), (C) and (D):
\end_layout

\begin_layout Standard
(A)<h1 class="heading">(B)Welcome to my new blog(C)</h1>(D)
\end_layout

\begin_layout Standard
The parameters are:
\end_layout

\begin_layout Standard
(A) – <before-heading:>
\end_layout

\begin_layout Standard
(B) – <prepend-heading:>
\end_layout

\begin_layout Standard
(C) – <append-heading:>
\end_layout

\begin_layout Standard
(D) – <after-heading:>
\end_layout

\begin_layout Standard
So, for example, suppose we want to add the name of the blog to the heading:
\end_layout

\begin_layout Standard
<h1 class="heading">Welcome to my new blog -- The Hobo Blog</h1>
\end_layout

\begin_layout Standard
To achieve that on one page, we could call the <page> tag like this:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<append-heading:> -- The Hobo Blog</append-heading:>
\end_layout

\begin_layout Standard
<body:> ...
 </body>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
Or we could go a step further and create a new page tag that added that
 suffix automatically.
 We could then use that new page tag for an entire section of our site:
\end_layout

\begin_layout Standard
<def tag="blog-page">
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<append-heading:> -- The Hobo Blog</append-heading:> 
\end_layout

\begin_layout Standard
<body: param></body>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Note: we have explicitly made sure that the <body:> parameter is still available.
 There is a better way of achieving this using merge-params or merge, which
 are covered later.)
\end_layout

\begin_layout Standard
The default parameter supports append and prepend
\end_layout

\begin_layout Standard
As we’ve seen, the <append-...:> and <prepend-...:> parameters insert content
 at the beginning and end of a tag’s content.
 But in the case of a defined tag that may output all sorts of other tags
 and may itself define many parameters, what exactly is the tag’s “content”?
 It is whatever is contained in the default parameter tag.
 So <append-...:> and <prepend-...:> only work on tags that define a default parameter.
\end_layout

\begin_layout Standard
For this reason, you will often see tag definitions include a default parameter,
 even though it would be rare to use it directly.
 It is there so that <append-...:> and <prepend-...:> work as expected.
\end_layout

\begin_layout Standard
Replacing a parameter entirely
\end_layout

\begin_layout Standard
So far, we’ve seen how the parameter mechanism allows us to change the attribute
s and content of a tag, but what if we want to remove the tag entirely?
 We might want a page that has no <h1> tag at all, or has <h2> instead.
 For that situation we can use “replace parameters”.
 Here’s a page with an <h2> instead of an <h1>:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<heading: replace><h2>My Awesome Page</h2></heading:>
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
And here’s one with no heading at all:
\end_layout

\begin_layout Standard
<page>
\end_layout

\begin_layout Standard
<heading: replace/> 
\end_layout

\begin_layout Standard
</page>
\end_layout

\begin_layout Standard
There is a nice shorthand for the second case.
 For every parameter, the enclosing tag also supports a special without
 attribute.
 This is exactly equivalent to the previous example, but much more readable:
\end_layout

\begin_layout Standard
<page without-heading/>
\end_layout

\begin_layout Standard
Note: To make things more consistent, <heading: replace> may become <replace-hea
ding:> in the future.
\end_layout

\begin_layout Standard
Current limitation
\end_layout

\begin_layout Standard
Due to a limitation of the current DRYML implementation, you cannot use
 both before and after on the same parameter.
 You can achieve the same effect as follows (this technique is covered properly
 later in the section on wrapping content):
\end_layout

\begin_layout Standard
<heading: replace> 
\end_layout

\begin_layout Standard
...
 before content ...
\end_layout

\begin_layout Standard
<heading restore>
\end_layout

\begin_layout Standard
...
 after content ...
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
Nested parameters
\end_layout

\begin_layout Standard
As we’ve discussed at the start of this guide, one of the main motivations
 for the creation of DRYML was to deliver a higher degree of re-use in the
 view layer.
 One of the great challenges of re-use is managing the constant tension
 between re-use and flexibility: the greater the need for flexibility, the
 harder it is to re-use existing code.
 This has a very direct effect on the size of things that we can successfully
 re-use.
 Take the humble hypertext link for example.
 A link is a link is a link – there’s only so much you could really want
 to change, so it’s not surprising that long ago we stopped having to assemble
 links from fragments of HTML text.
 Rails has its link_to helper, and Hobo Rapid has its <a> tag.
 At the other extreme, reusing an entire photo gallery or interactive calendar
 is extremely difficult.
 Again no surprise–these things have been built from scratch over and over
 again, because each time something slightly (or very) different is needed.
 A single calendar component that is flexible enough to cover every eventuality
 would be so complicated that configuring it would be more effort than starting
 over.
\end_layout

\begin_layout Standard
This tension between re-use and flexibility will probably never go away;
 life is just like that.
 As components get larger they will inevitably get either harder to work
 with or less flexible.
 What we can do though, through technologies like DRYML, is slow down the
 onset of these problems.
 By thinking about the fundamental challenges to re-use, we have tried to
 create a language in which, as components grow larger, simplicity and flexibili
ty can be retained longer.
\end_layout

\begin_layout Standard
One of the most important features that DRYML brings to the re-use party
 is nested parameters.
 
\end_layout

\begin_layout Standard
They are born of the following observations:
\end_layout

\begin_layout Standard
As components get larger, they are not really single components at all,
 but compositions of many smaller sub-components.
\end_layout

\begin_layout Standard
Often, the Customization we wish to make is not to the “super-component”
 but to one of the sub-components.
\end_layout

\begin_layout Standard
What is needed, then, is a means to pass parameters and attributes not just
 to the tag you are calling, but to the tag called within the tag, or the
 tag called within the tag called within the tag, and so on.
\end_layout

\begin_layout Standard
DRYML’s nested parameter mechanism does exactly that.
 After you’ve been using DRYML for some time, you may notice that you don’t
 use this feature very often.
 But when you do use it, it can make the difference between sticking with
 your nice high-level components or throwing them away and rebuilding from
 scratch.
 A little use of nested parameters goes a long way.
\end_layout

\begin_layout Standard
An example
\end_layout

\begin_layout Standard
To illustrate the mechanism, we’ll build up a small example using ideas
 that are familiar from Rapid.
 This is not a Rapid guide though, so we’ll define these tags from scratch.
 First off, the <card> tag.
 This captures the very common pattern of web pages displaying collections
 of some kind of object as small “cards”: comments, friends, discussion
 threads, etc.
\end_layout

\begin_layout Standard
<def tag="card">
\end_layout

\begin_layout Standard
<div class="card" merge-attrs>
\end_layout

\begin_layout Standard
<h3 param="heading"><%= h this.to_s %></h3>
\end_layout

\begin_layout Standard
<div param="body"></div>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
We’ve defined a very simple <card> that uses the to_s method to give a default
 heading, and provides a <body:> parameter that is blank by default.
 Here’s how we might use it:
\end_layout

\begin_layout Standard
<h2>Discussions</h2>
\end_layout

\begin_layout Standard
<ul>
\end_layout

\begin_layout Standard
<li repeat="@discussions"> 
\end_layout

\begin_layout Standard
<card> 
\end_layout

\begin_layout Standard
<body:><%= this.posts.length %> posts</body:>
\end_layout

\begin_layout Standard
</card> 
\end_layout

\begin_layout Standard
</li>
\end_layout

\begin_layout Standard
</ul>
\end_layout

\begin_layout Standard
This example (specifically, the collection created in the <li repeat="@discussio
ns"> section) demonstrates that as soon as we have the concept of a card,
 we very often find ourselves wanting to render a collection of <card> tags.
 The obvious next step is to capture that collection-of-cards idea as a
 reusable tag:
\end_layout

\begin_layout Standard
<def tag="collection"> 
\end_layout

\begin_layout Standard
<h2 param="heading"></h2>
\end_layout

\begin_layout Standard
<ul>
\end_layout

\begin_layout Standard
<li repeat>
\end_layout

\begin_layout Standard
<card param>
\end_layout

\begin_layout Standard
</li>
\end_layout

\begin_layout Standard
</ul>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
The <collection> tag has a straightforward <heading:> parameter, but notice
 that the <card> tag is also declared as a parameter.
 Whenever you add param to a tag that itself also has parameters, you give
 your “super-tag” (<collection> in this case) the ability to customize the
 “sub-tag” (<card> in this case) using nested parameters.
 Here’s how we can use the nested parameters in the <collection> tag to
 get the same output as the <li repeat="@discussions"> section in the previous
 example:
\end_layout

\begin_layout Standard
<collection>
\end_layout

\begin_layout Standard
<heading:>Discussions</heading>
\end_layout

\begin_layout Standard
<card:>
\end_layout

\begin_layout Standard
<body:><%= this.posts.length %>posts</body:>
\end_layout

\begin_layout Standard
</card:>
\end_layout

\begin_layout Standard
</collection>
\end_layout

\begin_layout Standard
This nesting works to any depth.
 To show this, if we define an <index-page> tag that uses <collection> and
 declares it as a parameter:
\end_layout

\begin_layout Standard
<def tag="index-page">
\end_layout

\begin_layout Standard
<html>
\end_layout

\begin_layout Standard
<head> ...
 </head>
\end_layout

\begin_layout Standard
<body>
\end_layout

\begin_layout Standard
<h1 param="heading"></h1>
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
<collection param>
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
</body> 
\end_layout

\begin_layout Standard
</html>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
we can still access the card inside the collection inside the page:
\end_layout

\begin_layout Standard
<index-page>
\end_layout

\begin_layout Standard
<heading:>Welcome to our forum</heading:>
\end_layout

\begin_layout Standard
<collection:>
\end_layout

\begin_layout Standard
<heading:>Discussions</heading>
\end_layout

\begin_layout Standard
<card:><body:><%= this.posts.length %>posts</body:></card:>
\end_layout

\begin_layout Standard
</collection:>
\end_layout

\begin_layout Standard
</index-page>
\end_layout

\begin_layout Standard
Pay careful attention to the use of the trailing ’:’.
 The definition of <index-page> contains a call the collection tag, written
 <collection> (no ’:’).
 By contrast, the above call to <index-page> customizes the call to the
 collection tag that is already present inside <index-page>, so we write
 <collection:> (with a ’:’).
 Remember:
\end_layout

\begin_layout Standard
Without ’:’ – call a tag
\end_layout

\begin_layout Standard
With ’:’ – customize an existing call inside the definition
\end_layout

\begin_layout Standard
Customizing and extending tags
\end_layout

\begin_layout Standard
As we’ve seen, DRYML makes it easy to define tags that are highly customizable.
 By adding prams to the tags inside your definition, the caller can insert,
 replace and tweak to their heart’s content.
 Sometimes the changes you make to a tag’s output are needed not once, but
 many times throughout the site.
 In other words, you want to define a new tag in terms of an existing tag.
\end_layout

\begin_layout Standard
New tags from old
\end_layout

\begin_layout Standard
As an example, let’s bring back our card tag:
\end_layout

\begin_layout Standard
<def tag="card">
\end_layout

\begin_layout Standard
<div class="card" merge-attrs>
\end_layout

\begin_layout Standard
<h3 param="heading"><%= h this.to_s %></h3>
\end_layout

\begin_layout Standard
<div param="body"></div>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Now let’s say we want a new kind of card, one that has a link to the resource
 that it represents.
 Rather than redefine the whole thing from scratch, we can define the new
 card, say, “linked-card”, like this:
\end_layout

\begin_layout Standard
<def tag="linked-card"> 
\end_layout

\begin_layout Standard
<card>
\end_layout

\begin_layout Standard
<heading: param><a href="&object_url this"><%= h this.to_s %></a>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
That’s all well and good but there are a couple of problems:
\end_layout

\begin_layout Standard
The original card used merge-attrs so that we could add arbitrary HTML attribute
s to the final <div>.
 Our new card has lost that feature
\end_layout

\begin_layout Standard
Worse than that, the new card is in fact useless, as there’s no way to pass
 it the body parameter
\end_layout

\begin_layout Standard
Let’s solve those problems in turn.
 First the attributes.
\end_layout

\begin_layout Standard
merge-attrs again
\end_layout

\begin_layout Standard
In fact merge-attrs works just the same on defined tags as it does on HTML
 tags that are output, so we can simply add it to the call to <card>, like
 this:
\end_layout

\begin_layout Standard
<def tag="linked-card">
\end_layout

\begin_layout Standard
<card merge-attrs>
\end_layout

\begin_layout Standard
<heading: param><a href="&object_url this"><%= h this.to_s %></a>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Now we can do things like <linked-card class="emphasised">, and the attribute
 will be passed from <linked-card>, to <card>, to the rendered <div>.
\end_layout

\begin_layout Standard
Now we’ll fix the parameters, it’s going to look somewhat similar…
\end_layout

\begin_layout Standard
merge-prams
\end_layout

\begin_layout Standard
We’ll introduce merge-prams the same way we introduced merge-attrs – by
 showing how you would get by without it.
 The problem with our <linked-card> tag is that we’ve lost the <body:> parameter.
 We could bring it back like this:
\end_layout

\begin_layout Standard
<def tag="linked-card">
\end_layout

\begin_layout Standard
<card merge-attrs> 
\end_layout

\begin_layout Standard
<heading: param><a href="&object_url this"><%= h this.to_s %></a>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
<body: param/>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
In other words, we use the param declaration to give <linked-card> a <body:>
 parameter, which is forwarded to <card>.
 But what if <card> had several parameters? We would have to list them all
 out.
 And what if we add a new parameter to <card> later? We would have to remember
 to update <linked-card> and any other customized cards we had defined.
\end_layout

\begin_layout Standard
Instead we use merge-prams, much as we use merge-attrs:
\end_layout

\begin_layout Standard
<def tag="linked-card"> 
\end_layout

\begin_layout Standard
<card merge-attrs merge-params>
\end_layout

\begin_layout Standard
<heading: param><a href="&object_url this"><%= h this.to_s %></a>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
You can read merge-prams as: take any “extra” parameters passed to <linked-card>
 and forward them all to <card>.
 By “extra” parameters, we mean any that are not declared as parameters
 (via the param attribute) inside the definition of <linked-card>.
\end_layout

\begin_layout Standard
There are two local variables inside the tag definition that mirror the
 attributes and all_attributes variables described previously:
\end_layout

\begin_layout Standard
parameters a hash containing all the “extra” parameters (those that do not
 match a declared parameter name)
\end_layout

\begin_layout Standard
all parameters a hash containing all the parameters passed to the tag
\end_layout

\begin_layout Standard
The values in these hashes are Ruby procs.
 One common use of all parameters is to test if a certain parameter was
 passed or not:
\end_layout

\begin_layout Standard
<if test="&all_parameters[:body]">
\end_layout

\begin_layout Standard
In fact, all parameters and parameters are not regular hashes, they are
 instances of a subclass of Hash – Hobo::Dryml::TagParameters.
 This subclass allows parameters to be called as if they were methods on
 the hash object, e.g.:
\end_layout

\begin_layout Standard
parameters.default
\end_layout

\begin_layout Standard
That’s not something you’ll use often.
\end_layout

\begin_layout Standard
Merge
\end_layout

\begin_layout Standard
As it’s very common to want both merge-attrs and merge-prams on the same
 tag, there is a shorthand for this: merge.
 So the final, preferred definition of <linked-card> is:
\end_layout

\begin_layout Standard
<def tag="linked-card">
\end_layout

\begin_layout Standard
<card merge>
\end_layout

\begin_layout Standard
<heading: param><a href="&object_url this"><%= h this.to_s %></a>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Merging selected parameters
\end_layout

\begin_layout Standard
Just as with merge-attrs, merge-prams can be given a value - either a hash
 containing the parameters you wish to merge, or a list of parameter names
 (comma separated), to be merged from the all parameters variable.
\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout Standard
<card merge-params="heading, body">
\end_layout

\begin_layout Standard
<card merge-params="&my_parameter_hash">
\end_layout

\begin_layout Standard
Extending a tag
\end_layout

\begin_layout Standard
We’ve now seen how to easily create a new tag from an existing tag.
 But what if we don’t actually want a new tag, but rather we want to change
 the behavior of an existing tag in some way, and keep the tag name the
 same.
 What we can’t do is simply use the existing name in the definition:
\end_layout

\begin_layout Standard
<!-- DOESN'T WORK! -->
\end_layout

\begin_layout Standard
<def tag="card"> 
\end_layout

\begin_layout Standard
<card merge>
\end_layout

\begin_layout Standard
<heading: param><a href="&object_url this"><%= h this.to_s %></a>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
All we’ve done there is created a nice stack overflow when the card calls
 itself over and over.
\end_layout

\begin_layout Standard
Fortunately, DRYML has support for extending tags.
 Use <extend> instead of <def>:
\end_layout

\begin_layout Standard
<extend tag="card">
\end_layout

\begin_layout Standard
<old-card merge>
\end_layout

\begin_layout Standard
<heading: param><a href="&object_url this"><%= h this.to_s %></a>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
</old-card>
\end_layout

\begin_layout Standard
</extend>
\end_layout

\begin_layout Standard
The one thing to notice there is that the “old” version of <card>, i.e.
 the one that was active before you’re extension, is available as <old-card>.
 That’s about all there is to it.
\end_layout

\begin_layout Standard
Here’s another example where we add a footer to every page in our application.
 It’s very common to <extend tag="page"> in your application.dryml, in order
 to make changes that should appear on every page:
\end_layout

\begin_layout Standard
<extend tag="page">
\end_layout

\begin_layout Standard
<old-page merge>
\end_layout

\begin_layout Standard
<footer: param> 
\end_layout

\begin_layout Standard
...
 
\end_layout

\begin_layout Standard
your custom footer here
\end_layout

\begin_layout Standard
...
 
\end_layout

\begin_layout Standard
</footer:>
\end_layout

\begin_layout Standard
</old-page>
\end_layout

\begin_layout Standard
</extend>
\end_layout

\begin_layout Standard
Aliasing tags
\end_layout

\begin_layout Standard
Welcome to the shortest section of The DRYML Guide…
\end_layout

\begin_layout Standard
If you want to create an alias of a tag; i.e., an identical tag with a different
 name:
\end_layout

\begin_layout Standard
<def tag="my-card" alias-of="card"/>
\end_layout

\begin_layout Standard
Note that it is a self-closing tag–there is no body to the definition.
\end_layout

\begin_layout Standard
So… that’s aliasing tags then…
\end_layout

\begin_layout Standard
Polymorphic tags
\end_layout

\begin_layout Standard
DRYML allows you to define a whole collection of tags that share the same
 name, where each definition is appropriate for a particular type of object
 being rendered.
 When you call the tag, the type (i.e.
 class) of the context is used to determine which definition to call.
 These are called polymorphic tags.
\end_layout

\begin_layout Standard
To illustrate how these work, let’s bring back our simple <card> tag once
 more:
\end_layout

\begin_layout Standard
<def tag="card" polymorphic>
\end_layout

\begin_layout Standard
<div class="card" merge-attrs>
\end_layout

\begin_layout Standard
<h3 param="heading"><%= h this.to_s %></h3> 
\end_layout

\begin_layout Standard
<div param="body">
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
We’ve added the polymorphic attribute to the <def>.
 This tells DRYML that <card> can have many definitions, each for a particular
 type.
 The definition we’ve given here is called the “base” definition or the
 “base card”.
 The base definition serves two purposes:
\end_layout

\begin_layout Standard
It is the fallback if we call <card> and no definition is found for the
 current type.
\end_layout

\begin_layout Standard
The type-specific definition can use the base definition as a starting point
 to be further customized.
\end_layout

\begin_layout Standard
To add a type-specific <card>, we use the for attribute on the <def>.
 For example, a card for a Product:
\end_layout

\begin_layout Standard
<def tag="card" for="Product"> ...
 </def>
\end_layout

\begin_layout Standard
Note: If the name in the for attribute starts with an uppercase letter,
 it is taken to be a class name.
 Otherwise it is taken to be an abbreviated name registered with HoboFields;
 e.g.:
\end_layout

\begin_layout Standard
<def tag="input" for="email_address">
\end_layout

\begin_layout Standard
For the product card, lets make the heading be a link to the product, and
 put the price of the product in the body area:
\end_layout

\begin_layout Standard
<def tag="card" for="Product">
\end_layout

\begin_layout Standard
<card merge>
\end_layout

\begin_layout Standard
<heading: param><a href="#{object_url this}"><%= h this.to_s %></a>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
<body: param="price">$<%= this.price %></body:>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
We call this a type-specific definition.
 Some points to notice:
\end_layout

\begin_layout Standard
The callback to <card> is not a recursive loop, but a call to the base definitio
n.
\end_layout

\begin_layout Standard
We’re using the normal technique for Customizing / extending an existing
 card; i.e., we’re using merge.
\end_layout

\begin_layout Standard
It is not required for the type-specific definition to call the base definition,
 it’s just often convenient.
 In fact the base definition is not required.
 It is valid to declare a polymorphic tag with no content:
\end_layout

\begin_layout Standard
<def tag="my-tag" polymorphic/>
\end_layout

\begin_layout Standard
Type hierarchy
\end_layout

\begin_layout Standard
If, for a given call, no type-specific definition is available for this.class,
 the search continues with this.class.superclass and so on up the superclass
 chain.
 If the search reaches either ActiveRecord::Base or Object, the base definition
 is used.
\end_layout

\begin_layout Standard
Specifying the type explicitly
\end_layout

\begin_layout Standard
Sometimes it is useful to give the type explicitly for the call explicitly
 (i.e., to override the use of this.class).
 The for-type attribute (on the call) provides this facility.
 For example, you might want to implement one type-specific definition in
 terms of another:
\end_layout

\begin_layout Standard
<def tag="card" for="SpecialProduct">
\end_layout

\begin_layout Standard
<card for-type="Product">
\end_layout

\begin_layout Standard
<append-price:>Today Only!)</append-price:>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Extending polymorphic tags
\end_layout

\begin_layout Standard
Type-specific definitions can be extended just like any other tag using
 the <extend> tag.
 For example, here we simply remove the price:
\end_layout

\begin_layout Standard
<extend tag="card" for="Product">
\end_layout

\begin_layout Standard
<old-card merge without-price/>
\end_layout

\begin_layout Standard
</extend>
\end_layout

\begin_layout Standard
Wrapping content
\end_layout

\begin_layout Standard
DRYML provides two mechanisms for wrapping existing content inside new tags.
\end_layout

\begin_layout Standard
Wrapping inside a parameter
\end_layout

\begin_layout Standard
Once or twice in the previous examples, we have extended our card tag definition
, replacing the plain heading with a hyperlink heading.
 Here is an example call to our extended card tag:
\end_layout

\begin_layout Standard
<card>
\end_layout

\begin_layout Standard
<heading:><a href="#{object_url this}"><%= h this.to_s %></a></heading:>
 </card>
\end_layout

\begin_layout Standard
There’s a bit of repetition there – <%= h this.to_s %> was already present
 in the original definition.
 All we really wanted to do was wrap the existing heading in an <a>.
 In this case there wasn’t much markup to repeat, so it wasn’t a big deal,
 but in other cases there might be much more.
\end_layout

\begin_layout Standard
We can’t use <prepend-heading:><a></prepend-heading:> and <append-heading:></a><
/append-heading:> because that’s not well formed markup (and is very messy
 besides).
 Instead, DRYML has a specific feature for this situation.
 The <param-content> tag is a special tag that brings back the default content
 for a parameter.
\end_layout

\begin_layout Standard
Here’s how it works:
\end_layout

\begin_layout Standard
<card>
\end_layout

\begin_layout Standard
<heading:>
\end_layout

\begin_layout Standard
<a href="#{object_url this}"><param-content for="heading"/></a>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
That’s the correct way to wrap inside the parameter, so in this case the
 output is:
\end_layout

\begin_layout Standard
<h3><a href="...">Fried Bananas</a></h3>
\end_layout

\begin_layout Standard
What if we wanted to wrap the entire <heading:> parameter, including the
 <h3> tags?
\end_layout

\begin_layout Standard
Wrapping outside a parameter
\end_layout

\begin_layout Standard
For example, we might want to give the card a new ‘header’ section, that
 contained the heading, and the time the record was created, like this:
\end_layout

\begin_layout Standard
<div class="header">
\end_layout

\begin_layout Standard
<h3>Fried Bananas</h3>
\end_layout

\begin_layout Standard
<p>Created: ....</p>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
To use DRYML terminology, what we’ve done there is replaced the entire heading
 with some new content, and the new content happens to contain the original
 heading.
 So we replaced the heading, and then restored it again, which in DRYML
 is written:
\end_layout

\begin_layout Standard
<card>
\end_layout

\begin_layout Standard
<heading: replace> 
\end_layout

\begin_layout Standard
<div class="header">
\end_layout

\begin_layout Standard
<heading: restore/> 
\end_layout

\begin_layout Standard
<p>Created: <%= this.created_at.to_s(:short) %></p>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
</heading:>
\end_layout

\begin_layout Standard
</card>
\end_layout

\begin_layout Standard
To summarize: 
\end_layout

\begin_layout Standard
To wrap content inside a parameter, use <param-content/>
\end_layout

\begin_layout Standard
To wrap an entire parameter, including the parameterized tag itself (the
 <h3> in our examples), use the replace and restore attributes.
\end_layout

\begin_layout Standard
Local variables and scoped variables.
\end_layout

\begin_layout Standard
DRYML provides two tags for setting variables: <set> and <set-scoped>.
\end_layout

\begin_layout Standard
Setting local variables with <set>
\end_layout

\begin_layout Standard
Sometimes it’s useful to define a local variable inside a template or a
 tag definition.
 It’s worth avoiding if you can, as we don’t really want our view layer
 to contain lots of low-level code, but sometimes it’s unavoidable.
 Because DRYML extends ERB, you can simply write:
\end_layout

\begin_layout Standard
<% total = price_of_fish * number_of_fish %>
\end_layout

\begin_layout Standard
For purely aesthetic reasons, DRYML provides a tag that does the same thing:
\end_layout

\begin_layout Standard
<set total="&price_of_fish * number_of_fish"/>
\end_layout

\begin_layout Standard
Note that you can put as many attribute/value pairs as you like on the same
 <set> tag, but the order of evaluation is not defined.
\end_layout

\begin_layout Standard
Scoped variables – <set-scoped>
\end_layout

\begin_layout Standard
Scoped variables (which is not a great name, we realize as we come to document
 them properly) are kind of like global variables with a limited lifespan.
 We all know the pitfalls of global variables, and DRYML’s scoped variables
 should indeed be used as sparingly as possible, but you can pull off some
 very useful tricks with them.
\end_layout

\begin_layout Standard
The <set-scoped> tag is very much like <set> except you open it up and put
 DRYML inside it:
\end_layout

\begin_layout Standard
<set-scoped xyz="&..."> ...
 </set-scoped>
\end_layout

\begin_layout Standard
The value is available as scope.xyz anywhere inside the tag and in any tags
 that are called inside that tag.
 That’s the difference between <set> and <set-scoped>.
 
\end_layout

\begin_layout Standard
They are like dynamic variables from LISP.
 To repeat the point, they are like global variables that exist from the
 time the <set-scope> tag is evaluated, and for the duration of the evaluation
 of the body of the tag, and are then removed.
\end_layout

\begin_layout Standard
As an example of their use, let’s define a simple tag for rendering navigation
 links.
 The output should be a list of <a> tags, and the <a> that represents the
 “current” page should have a CSS class “current”, so it can be highlighted
 in some way by the stylesheet.
 (In fact, the need to create a reusable tag like this is where the feature
 originally came from).
\end_layout

\begin_layout Standard
On our pages, we’d like to simply call, say:
\end_layout

\begin_layout Standard
<main-nav current="Home">`
\end_layout

\begin_layout Standard
And we’d like it to be easy to define our own <main-nav> tag in our applications
:
\end_layout

\begin_layout Standard
<def tag="main-nav">
\end_layout

\begin_layout Standard
<navigation merge-attrs>
\end_layout

\begin_layout Standard
<nav-item href="...">Home</nav-item> 
\end_layout

\begin_layout Standard
<nav-item href="...">News</nav-item>
\end_layout

\begin_layout Standard
<nav-item href="...">Offers</nav-item>
\end_layout

\begin_layout Standard
</navigation>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
Here’s the definition for the <navigation> tag:
\end_layout

\begin_layout Standard
<def tag="navigation" attrs="current">
\end_layout

\begin_layout Standard
<set-scoped current-nav-item="current">
\end_layout

\begin_layout Standard
<ul merge-attrs param="default"/> 
\end_layout

\begin_layout Standard
</set-scoped>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
All <navigation> does is set a scoped-variable to whatever was given as
 current and output the body wrapped in a <ul>.
\end_layout

\begin_layout Standard
Here’s the definition for the <nav-item> tag:
\end_layout

\begin_layout Standard
<def tag="nav-item">
\end_layout

\begin_layout Standard
<set body="&parameters.default"/> 
\end_layout

\begin_layout Standard
<li class="#{'current' if scope.current_nav_item == body}"> 
\end_layout

\begin_layout Standard
<a merge-attrs><%= body %>
\end_layout

\begin_layout Standard
</li>
\end_layout

\begin_layout Standard
</def>
\end_layout

\begin_layout Standard
The content inside the <nav-item> is compared to scope.current_nav_item.
 If they are the same, the “current” class is added.
 Also note the way parameters.default is evaluated and the result stored
 in the local variable body, in order to avoid evaluating the body twice.
\end_layout

\begin_layout Standard
Nested scopes
\end_layout

\begin_layout Standard
One of the strengths of scoped variables is that scopes can be nested, and
 where there are name clashes, the parent scope variable is temporarily
 hidden, rather than overwritten.
 With a bit of tweaking, we could use this fact to extend our <navigation>
 tag to support a sub-menu of links within a top level section.
 The sub-menu could also use <navigation> and <nav-item> and the two scope.curren
t_nav_item variables would not conflict with each other.
\end_layout

\begin_layout Standard
Taglibs
\end_layout

\begin_layout Standard
DRYML provides the <include> tag to support breaking up lots of tag definitions
 into separate “tag libraries”, known as taglibs.
 You can call <include> with several different formats:
\end_layout

\begin_layout Standard
<include src="foo"/>
\end_layout

\begin_layout Standard
Load foo.dryml from the same directory as the current template or taglib.
\end_layout

\begin_layout Standard
<include src="path/to/foo"/>
\end_layout

\begin_layout Standard
Load app/views/path/to/foo.dryml
\end_layout

\begin_layout Standard
<include src="foo" plugin="path/to/plugin"/>
\end_layout

\begin_layout Standard
Load vendor/plugins/path/to/plugin/taglibs/foo.dryml
\end_layout

\begin_layout Standard
When running in development mode, all of these libraries are automatically
 reloaded on every request.
\end_layout

\begin_layout Standard
Divergences from XML and HTML
\end_layout

\begin_layout Standard
Self-closing tags
\end_layout

\begin_layout Standard
In DRYML, <foo:/> and <foo:></foo:> have two slightly different meanings.
\end_layout

\begin_layout Standard
The second form replaces the parameter’s default inner content with the
 specified content: nothing in this case.
\end_layout

\begin_layout Standard
The first form uses the parameters default inner content unchanged.
\end_layout

\begin_layout Standard
This is very useful if you wish to add an attribute to a parameter but leave
 the inner content unchanged.
 In this example:
\end_layout

\begin_layout Standard
<def tag="bar">
\end_layout

\begin_layout Standard
<div class="container" merge-attrs> 
\end_layout

\begin_layout Standard
<p class="content" param>
\end_layout

\begin_layout Standard
Hello
\end_layout

\begin_layout Standard
</p>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
<def>
\end_layout

\begin_layout Standard
Then:
\end_layout

\begin_layout Standard
<bar><foo: class="my-foo"/></bar>
\end_layout

\begin_layout Standard
Gives:
\end_layout

\begin_layout Standard
<div class="container">
\end_layout

\begin_layout Standard
<p class="content my-foo">
\end_layout

\begin_layout Standard
Hello
\end_layout

\begin_layout Standard
</p>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
If you used:
\end_layout

\begin_layout Standard
<bar><foo: class="my-foo"></foo:></bar>
\end_layout

\begin_layout Standard
You would get:
\end_layout

\begin_layout Standard
<div class="container">
\end_layout

\begin_layout Standard
<p class="content my-foo"></p>
\end_layout

\begin_layout Standard
</div>
\end_layout

\begin_layout Standard
Colons in tag names
\end_layout

\begin_layout Standard
In XML, colons are valid inside tag and attribute names.
 However they are reserved for “experiments for namespaces”.
 So it’s possible that we may be non-compliant with the not-yet-existent
 XML 2.0.
\end_layout

\begin_layout Standard
Close tag shortcuts
\end_layout

\begin_layout Standard
In DRYML, you’re allowed to close tags with everything preceding the colon:
\end_layout

\begin_layout Standard
<view:name> Hello </view>
\end_layout

\begin_layout Standard
XML requires the full tag to be specified:
\end_layout

\begin_layout Standard
<view:name> Hello </view:name>
\end_layout

\begin_layout Standard
Null end tags
\end_layout

\begin_layout Standard
Self-closing tags are technically illegal in HTML.
 So <br /> is technically not valid HTML.
 However, browsers do parse it as you expect.
 It is valid XHTML, though.
\end_layout

\begin_layout Standard
However, browsers only do this for empty elements.
 So tags such as <script> and <a> require a separate closing tag in HTML.
 This behavior has surprised many people: 
\end_layout

\begin_layout Standard
<script src="foobar.js" />
\end_layout

\begin_layout Standard
…is not recognized in many web browsers for this reason.
 You must use:
\end_layout

\begin_layout Standard
<script src="foorbar.js"></script>
\end_layout

\begin_layout Standard
…in HTML instead.
\end_layout

\begin_layout Standard
DRYML follows the XML conventions:
\end_layout

\begin_layout Standard
<a/>
\end_layout

\begin_layout Standard
…is valid DRYML.
\end_layout

\end_body
\end_document
