SECTION 2: TUTORIALS
CHAPTER  3 - INTRODUCTOR TUTORIALS

Introductory Concepts and Comments
Tutorial 1 - Directories and Generators  	
Tutorial 2 - Changing Field Names
Tutorial 3 - Field Validation
Tutorial 4 - Introduction to Permissions
Tutorial 5 - Hobo
Tutorial 6 - Editing the Navigation Tabs
Tutorial 7 - Model Relationships
Tutorial 8 - Model Relationships












Introductory Concepts and Comments

If you explain a magic trick before it is performed, you risk spoiling the enjoyment. There will be plenty of time after you work through a few of the tutorials to learn what is going on “behind the curtain.”
So, in the spirit of this adventure we will explain just enough right now to allow you to dive in head first…
Tutorial 1 – Directories and Generators 

You will create a single-table application that demonstrates how Hobo constructs a nice user interface that includes a built-in login system and basic search capability.  Hobo 1.3 generators are compatible with the new Rails 3 generator API and operate quite differently from Hobo 1.0 and Rails 2.x.  We will explain in more detail below.
Tutorial Application: my-first-app
Topics
Creating a Hobo application
Learning the Hobo Directory structure
Generating Hobo models and controllers 
Generating Hobo models 
Generating Hobo controllers 
Creating Migrations and Databases 
Editing Models and propagating the changes 
Tutorial Application: my-first-app
Steps
1. Description of development tools. You will use three tools to do the work in these tutorials. They include:
A shell command prompt to run scripts 
A text editor for you to edit your application files
A browser to run and test your application
Ordinarily you will have two shell windows or tabs open: one from which to run Hobo  scripts or operating system commands and one from which to run a web server (Mongrel in these tutorials). These tutorials are not done with an integrated development environment (IDE). 
2. Create a Hobo application directory. Before you create your first Hobo application, create a directory called tutorials. This will be the directory where you keep all of your Hobo tutorials. Navigate to the tutorials directory using your shell application.  
	You should now see the following prompt:
\tutorials>
3. Create a Hobo application. All you have to do to create a Hobo application is to issue the Hobo command:
\tutorials> hobo new my-first-app

Note: The screen captures were taken with Hobo 1.3 pre-release # 26 as of 2/15/2011.
You will see a log of what Hobo is creating go by within the shell window that you will better understand as you learn Hobo’s directory structure. The first prompt from the Hobo Setup Wizard will appear as follows:

The Hobo Setup Wizard will present you with the following eight options, for this tutorial choose the following “default” options:


Question
Defaults 
Do you want to customize the test_framework? [y|n] 
n
a. Choose a name for the user resource [<enter>=user|<custom_name>]
<enter>
b. Do you want to send an activation email to activate the user? [y|n] 
n
c. Do you want to add the features for an invite only website? [y|n] 
n
d. Will you application use only hobo/dryml web page templates? (Choose 'n' only if you also plan to use plain rails/erb web page templates) [y|n]
y
e. Choose a name for the front controller [<enter>=front|<custom_name>]:
<enter>
f. Initial Migration: [s]kip, [g]enerate migration file only, generate and [m]igrate [s|g|m]: 
m
g. Type the locales (space separated) you want to add to your application or <enter> for 'en':
<enter>
h. Do you want to initialize a git repository now? [y|n] 
n


You will see the following message upon completion:



4. Start the web server. Create a second shell window (or tab).  You are now going to start a local web server on your computer. This will enable you to run the Hobo application and see what a deployed application looks like in your browser.
Navigate to your application directory and fire up the local web server by issuing the following command at your command prompt. 
\my-first-app> rails server 
While your server is executing, it does not return you to your command prompt. As you run your application, it logs what it is doing to this shell. You can terminate the web server by typing control-c and restart it the same way you started it above, but do not terminate the server.
5. Open your application in a web browser. Type the following URL into your browser:
	 http://localhost:3000/
The following “Register Administrator” page will appear:

Hobo, by default, assumes the first person that launches the application will be an administrator.  Go ahead and enter the information required and click on the “Register Administrator” button:
Note: The first person to register is assigned the administrator privileges by Hobo.  Notice that in the upper right-hand corner of your web page there is a drop-down list of created users that allows you to sign in automatically to any of the user accounts without going through the login page if you are in development mode. This is turned off in production mode.


This is how your app looks after registering:

Now let’s take a look at what Hobo has generated so far.  Use your text editor to locate the user.rb file under the app/models directory:

Figure 34: The default User model created by Hobo
Hobo took care of building the User model and generating the database table needed because we selected the “m” (generate and migrate) option for step 6 of the Hobo Setup Wizard:
Initial Migration: [s]kip, [g]enerate migration file only, generate and [m]igrate [s|g|m]: 
6. Examine what Hobo created during the first “migration”. In the following figure, you can see that the db directory is populated. 
a. The file, development.sqllite3, is the database file. 
b. The <timestamp>_initial_migration.rb file defines the database table that will be created when the migration is executed. 
c. The schema.rb file shows the current database schema after all migration executions to date.  In this case we have only created the user table.

Figure 35: Contents of the first Hobo migration file
Take a look at the schema and you will see that it corresponds to the migration file:

Figure 36: Contents of the "schema.rb" file after the first migration

Note:  You can see that the User model does not display all the fields that are implemented in the database. Hobo does not expose all of the User fields but reserves them for its own use.  All of the fields in other models will be reflected in the schema file.
Click on the “Logout” link and then click on the “Signup” link to create another account.  In the example below we are creating another account for “John Smith”. We will call this and all other accounts you create user accounts, because by default they will not have administrative privileges.
Log out of the user (e.g., John Smith) account you just created and login using the account you created as administrator (e.g., Owen Dall) for now. 
Note: You will use the user’s email address and password to log in, not the user’s name. Also, notice that in the upper right corner of your web page, there is a drop down box that lets you automatically login to any of your accounts without using the normal login page.  This speeds up testing permission customizations in development mode. In production mode this option disappears.  More on switching modes later.

	
7. Check the changes in the views/taglibs directory. Notice that since you fired up your web server, there is now a change in the taglibs directory. There is a new branch called views/taglibs/auto/rapid and three files in that directory: cards.dryml, forms.dryml and pages.dryml. We are going to show you a few things to pique your curiosity but we will not cover how Hobo handles views in any detail until the intermediate tutorials. We will just make a few high level comments here in case you know something about Ruby on Rails and so you know what is coming.
Familiarize yourself with the contents of these files. You will see many lines that look similar to:

<def tag= new-page>
.....
</end>
You will see mark-up in between the “def” and “end” tags. The contents are what we have mentioned before as “tag definitions.”  Hobo uses them to construct view templates on the fly.
These three files contain the libraries of tags that Hobo uses to construct view templates.
 

Note: When Hobo makes a web page, it takes tags from the pages.dryml file. When it wants to construct a data entry form, tags in the pages.dryml file call tags in the form.dryml file. When Hobo wants to list the records from a table, tags in the pages.dryml file call tags in the cards.dryml file. Card tags define how individual database table records are rendered.
(Actually, these files are a copy of what Hobo is doing on the fly behind the scenes but it is easier to think of it in this way.)
You will learn that you can edit and redefine the tags from the /rapid directory. When you want your changes to be available to the application, you can either put the new tags in the application.dryml file or create a taglibs/application folder and save your tags to a taglibs/application/<filename>.dryml.  Any dryml file located in the taglibs/application directory will automatically loaded and its tags will be available application wide. When you want them to be available only in a particular view you can put them in a dryml file under the app/views/<model> directory named for the model. 
So far, we only have the front (home page) and the users template directories. You will see after creating a new model (running hobo g resource or hobo g model) and running hobo g migration, that directories will be created and named for your new models.
8. Create a new model and controller. Let’s create a simple contacts model and see what Hobo does for us.
\my-first-app> hobo g resource contact name:string company:string 
This generator will create both a model and controller. Execute it and then take a look at what has changed in your application directories.
You will see the new contacts_controller.rb file in the /controllers directory and the new contact.rb file in the /models directory. 
Note: Unlike Hobo 1.0, a view template file is not created in the views/contacts folder.  We will discuss later how the rapid taglibs in the /auto/rapid folder take care of the default views for you).

Figure 39: Folder location for Models and Views
9. Run a Hobo migration. Before you run the migration, take a look at the contact.rb model file. We just want to review the relevant part for now. The permissions part will be explained in a later tutorial.
Here is the code that declares the fields that you want in your database table that will be called contacts. When you ran hobo g resource, it generated this code. 
class Contact < ActiveRecord::Base

 hobo_model # Don't put anything above this
 
 fields do
    name    :string
    company :string
    timestamps
 end
When you run hobo g migration, Hobo will take this declaration and create a migration file. It will then in turn use the migration file to create the database table. These two steps will be executed within a single Hobo migration. You could do them separately but we will not do that here.
Now run hobo g migration and observe what happens.
\my-first-app> hobo g migration
Remember to select the ‘m’ option to both create and execute the migration file. Then hit return to accept the proposed name of the migration file.
You will notice some changes now in the my-first-app/db directory of your app. 


There is a new migration file and changes in your schema file as well. The new migration file contains the following code:
  def self.up
    create_table :contacts do |t|
      t.string   :name
      t.string   :company
      t.datetime :created_at
      t.datetime :updated_at
  end

The schema file (schema.rb), reflecting this code, shows the current state of the database in the db/schema file:

 create_table "contacts", :force => true do |t|
    t.string   "name"
    t.string   "company"
    t.datetime "created_at"
    t.datetime "updated_at"
 end
Now check out the application in your browser with the following URL after running the command rails server
      http://localhost:3000/


Now you have a new tab called “Contacts.”
10. Create some contacts. Now you should be able to create a new contact by clicking the ‘New Contact’ link in the Contacts tab. Go ahead and create a couple of new contacts to convince yourself that the database entry actually works. While you are at it also try editing a contact.
So far, Hobo is doing a pretty decent job. You have a usable UI, I/O capability for your contact model and a login system and you have written no code.
11. Try out the search facility. Type the name of one your contacts to exercise the search facility. The default search searches “name” fields.  You need at lease three characters for a partial word search.
12. Add columns to the database. Now we are going to add a couple more fields to the model and have hobo add columns to the database. In this and the following steps, you will get a sense for the power of the hobo g migration generator.  Since we have already generated our model using hobo g resource, we do not have to do that again. Go into the model and add some new fields. Your code should now look like this:

class Contact < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name    :string
    company :string
    address_1 :string
    address_2 :string
    city      :string
    state     :string
    date_met  :date
    married   :boolean
    age       :integer
    notes     :text
    timestamps
  end
Make sure you save your changes and run hobo g migration. Select the ‘m’ option and accept the default filename for the migration.
\my-first-app> hobo g migration
Now refresh your browser. Go to the contacts tab and click ‘New Contact ’


Note what Hobo has done for you. It determines which entry controls you need based on the type of field you defined in your model. It has one-line fields for strings, a set of three combo boxes for dates, a one-line field for integers, a check box for boolean field, and a multi-line box for text fields. Later you will see that Hobo can provide the controls you need for multi-model situations.
Hobo has also provided reasonable names and styles from the field names. It removed the underscore characters and appropriately capitalized words to give the presentation a nice look and feel.
13. Remove columns from the database. Now suppose you decide that you need only one address field and you decide to remove the second one. Go back to the Contact model and delete it (we just commented it out with the # sign so you can see things clearer.)


class Contact < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name      :string
    company   :string
    address_1 :string
    #address_2:string
    city      :string
    state     :string
    date_met  :date
    married   :boolean
    age       :integer
    notes     :text
    timestamps
  end
Run hobo g migration again.
\my-first-app> hobo g migration
Hobo notices that you have deleted a model field and responds in this way.
CONFIRM DROP! column contacts.address_2
Enter 'drop address_2' to confirm:
You respond by typing what it asks (without the quotes).
CONFIRM DROP! column contacts.address_2
Enter 'drop address_2' to confirm: drop address_2
Complete the migration as you have learned above. Then go check the db directory. You will see another migration, *_hobo_migration_4.rb  with the following code. (The asterisk (*) here stands for the time/date stamp that precedes the rest of the migration file name.)
class HoboMigration4 < ActiveRecord::Migration
  def self.up
    remove_column :contacts, :address_2
  end

  def self.down
    add_column :contacts, :address_2, :string
  end
end
Check out the schema.rb file now.
ActiveRecord::Schema.define(:version => 20090220154125) do

  create_table "contacts", :force => true do |t|
    t.string   "name"
    t.string   "company"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "address_1"
    t.string   "city"
    t.string   "state"
    t.date     "date_met"
    t.boolean  "married"
    t.integer  “age”
    t.text     "notes"
  end
You can see that address_2 is gone.
14. Adding and removing database tables. You can also use hobo g migration to remove (drop) a table. Delete the model file and the associated helper and controller files. Then run hobo g migration.  You will be prompted to confirm that you wish to drop the table. (If you neglect to delete the helper and controller file for this model you will get an error.)
15. Going back to earlier migrations. Hobo does not provide this facility within hobo g migration. You will need to use the rake db:migrate VERSION = XXX procedure. You can roll back your tables but the rest of your changes will not be synchronized so you will have to perform manual edits.
Tutorial 2 – Changing Field Names

We are going to continue from the previous tutorial and show you how to do rename fields in a couple of different ways and improve your UI with hints about what to enter in a particular field.
Topics
Two ways of changing field names displayed
Displaying data entry hints
Changing field sizes: Hobo does not provide this facility now.
Tutorial Application: my-first-app
Steps 
1.	Rename a database column. In Tutorial 1, we showed you how to make changes to your database by editing the model file. You can rename a field and database column in the same way. We will try this with the married field. Go to your contacts.rb file and rename married to married_now and run the hobo g migration.
class Contact < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name			  :string
    company	       :string
    address_1     :string
    #address_2    :string
    city     	    :string
    state		    :string
    date_met      :date
    #married      :boolean
    married_now   :Boolean
	   age	          :integer   
    notes         :text
    timestamps
  end

\my-first-app> hobo g migration
Hobo should now respond:
DROP, RENAME or KEEP?: column contacts.married
Rename choices: married_now
Enter either 'drop married' or one of the rename choices or press enter to keep:
Hobo is trying to confirm that what you really want to do is rename the column and not drop it. Enter married_now to rename. Check your schema.db file and you will see that the column has been renamed.  The KEEP option is a safety option in case you mistakenly renamed the column,
Note: Do not use question marks (?) in field names. You will get an error.
Refresh your browser and you will now see the field labeled ‘Married Now.’
2.  Changing field names. There is no need to change the name of a field or column if all you wish to do is to change the name of a label in the user interface.  Hobo provides this as part of its new Internationalization (i18n) module.  This i18n module is very versatile and can be used for providing field/model renaming capabilities up to full multi-lingual support for your application.  The  i18n module is comprised of .yml files that reside in the config/locales directory; if you look in the directory you will see these files:
app.en.yml (or app.<locale>.yml)
hobo.en.yml (or hobo.<locale>.yml)
For this tutorial we will assume that english (en) was specified as the default locale.  The hobo.en.yml file contains all the strings that the hobo framework uses, while application specific strings are stored in the app.en.yml file.  We will modify the app.en.yml file to rename a couple of fields in the Contact model.  When you open the config/locales/app.en.yml file, you will see:

Figure 44: Default config/locales/app.en.yml File

The commented yaml code is very useful in understanding how to setup your locale file.  Our goal is to rename the name and address_1 fields of the Contact model.  To do this, add the illustrated code to the file:

Figure 45: app.en.yml File with Fields Renamed
As shown above, to declare new names for model fields in the app.en.yml file, the following pattern must be followed:
  activerecord:
    attributes:
      <model1>:
        <field1>: Label/Rename
        <field2>: Label/Rename
			…

      <model2>:
        <field1>: Label/Rename
        <field2>: Label/Rename
			…

			

Note: Indentation and spacing is very important when working with yml files; the activerecord: line must start with 2 spaces.
Refresh your browser and you should see the fields relabeled with your choices from above. Notice that a migration is not necessary for any changes made using the i18n module.


3.   Using the i18n module to suggest field uses. The application locale (app.en.yml) file also provides the facility to provide a suggestion below the field on what to enter into it. Edit your app.en.yml file to look like this.




Now refresh your browser and you will see hints on the field use in a small font below:


Note: In the Intermediate tutorials you will also learn how to use yet another way to manipulate the labels on a web page by using Hobo’s view markup language called DRYML (Don’t Repeat Yourself Markup Language).  DRYML is used by the Rapid UI generator that creates much of Hobo’s magic.
4. Changing field sizes.  As of the latest version of Hobo, the way to change the field length on an input form is to add an entry to application.css that will override any other reference to the element you wish to modify.
Look for the relevant class definition used by Hobo’s “Rapid” UI generator:  rapid-ui.css, located at:
/public/hobothemes/clean/stylesheets/rapid-ui.css

Figure 49: CSS definitions for the input text fields

	

Figure 50: Modified entry in "application.css" to shorten text prompts
Tutorial 3 – Field Validation

You will be introduced to a couple of ways of validating data entry fields. This is a capability that is derived from what are called Rails helper methods. There are a couple of enhancements Hobo has made for the most common need.  
Topics
Field validation using Hobo’s enhancements
Field validation using Rails helper methods
Validation on save, create and update processes

Tutorial Application: my-first-app

1.	Make sure data is entered. Open up the model contact.rb file.  Add the following code to the “name” field definition   
name   :string, :required
This is the simplified version that Hobo provides. To do this in the “normal” rails way, you would need to add this line after the “fields/do” block:
validates_presence_of :name   
(The difference in the two is a matter of taste, but the former seems “DRYer”  to us.)
By default Hobo will provide a message if a user fails to enter data. Try it out by trying to create a contact record with no data in it. Click the Contacts tab and then New Contact. 
Without entering anything in the form, click Create Contact.


2.	Validate multiple fields. In order to validate multiple fields, add the “:required” label to another field:
address_1   :string, :required

Click the Contacts tab and then New Contact. Without entering anything in the form, click Create Contact.

Notice the “declarative” nature of this validation.  All you need to do is use the label “:required”  for the name and address_1 fields and Hobo takes care of all of the logic associated with validation and delivering error messages. 
Now let’s try some other validations. 
3.	Make sure the integer field contains a number.  Add this validation to the “age” field after the “fields do/end” block:
validates_numericality_of  :age



Now try this out by entering the text “old” in the age field. (Also put something in the name and address_1 fields so you won’t trip the validations we put into place earlier in the tutorial.)

Figure 54: Page view of triggering the "validates_numericality_of" error

Note: When you cause a validation error for integer, Hobo/Rails replaces what you entered with a zero (0).  If the validation rule was not there, the text will be replaced by a zero, but the validation error will not be displayed.
4.   Prevent the entry of duplicates. Use the following code to prevent  a user from entering code that duplicates an existing record with a column value that is the same as the new record.
name  :string, :required, :unique


Note: This particular validation will only verify that there is no existing record with the same field value at the time of validation. In a multi-user application, there is still a chance that records could be entered nearly at the same time resulting in a duplicate entry. The most reliable way to enforce uniqueness is with a database-level constraint. 
5.	Including and excluding values. Now suppose we wish to exclude people who have an age between 0 and 17, and include people under 65 years of age. Try the following code after the “fields do/end” block:
validates_inclusion_of :age, :in => 18..65, :message => "Must be between 18 and 65"


6.	Validate length of entry. Suppose you wish to check the length of a string entry. You can specify a length range in the following way.
validates_length_of :name, :within => 2..20, :too_long => "pick a shorter name", :too_short => "pick a longer name" 
Try to enter a one-character name. You will get the following response:
 
7.	Validate acceptance. If you wish to get the user to accept a contract, for example, you can use the following validation code. Assume you have a Boolean variable named contract_agree, which would show up in the UI as a checkbox.
validates_acceptance_of :contract_agree, :accept => true
Hobo will generate an error if the contract_agree check box is not checked setting the value to 1.

	
8.	Summary. Here is the list of validations we accumulated during this tutorial:
address_1   :string, :required
name  :string, :required, :unique

validates_numericality_of  :age

validates_acceptance_of :contract_agree, :accept => true

validates_length_of :name, :within => 2..20, :too_long => "pick a shorter name", :too_short => "pick a longer name" 

validates_inclusion_of :age, :in => 18..65, :message => "Must be between 18 and 65"

There are several other very useful validation functions provided by Rails,  and the ones that we have shown you above have many other options.  These functions can provide very sophisticated business rule execution.
For example, the following is a sample of the list of options for the validates_length_of and validates_size_of (synonym) declarative expressions:
:minimum - The minimum size of the attribute. 
:maximum - The maximum size of the attribute. 
:is - The exact size of the attribute. 
:within - A range specifying the minimum and maximum size of the attribute. 
:in - A synonym(or alias) for :within. 
:allow_nil - Attribute may be nil; skip validation. 
:allow_blank - Attribute may be blank; skip validation. 
:too_long - The error message if the attribute goes over the maximum (default is: "is too long (maximum is {{count}} characters)"). 
:too_short - The error message if the attribute goes under the minimum (default is: "is too short (min is {{count}} characters)"). 
:wrong_length - The error message if using the :is method and the attribute is the wrong size (default is: "is the wrong length (should be {{count}} characters)"). 
:message - The error message to use for a :minimum, :maximum, or :is violation. An alias of the appropriate too_long/too_short/wrong_length message. 
:on - Specifies when this validation is active (default is :save, other options :create, :update). 
:if - Specifies a method, procedure,  or string to call to determine if the validation should occur:
 :if => :allow_validation 
The method, procedure, or string should return or evaluate to a true or false value. 
:unless - Specifies a method, procedure  or string to call to determine if the validation should not occur:
 :unless => :skip_validation
The method, procedure, or string should return or evaluate to a true or false value. 
We encourage you to read about validation helpers (what Rails calls functions) in the many good Ruby on Rails references. The following is a useful on-line reference:
http://api.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html
Tutorial 4 – Permissions 

In this tutorial you will learn some elementary aspects of Hobo’s permission system by changing what the admin user and users can do. Specifically, you will determine   whether a user is permitted to view, create, edit or delete records in the database.
Topics
Experiment with altering user permissions.
Naming conventions for database tables, models, controllers and views.
Tutorial Application: one_table	
Steps
1.	Create the Hobo application. Create the one_table Hobo application by issuing the following command at the command prompt.   By adding the --setup command line parameter the application will bypass the setup wizard and create the application with default settings, Then change directory to the subdirectory one_table:
\tutorials> hobo new one_table --setup
\tutorials> cd one_table
\one_table>
Recall from Tutorial 1 that this sets up the Hobo directory tree and the user model and controller. 
Note: Look at the file \one_table\app\models\user.rb and at the database schema file \one_table\db\schema.rb. There are more fields in the users table than in the user model. This is because Hobo creates several user model fields for you automatically. This will not be the case for models you create. 
3.	Start the web server. Open a new command prompt and navigate to the \tutorials\one_table  directory.  Fire up your web server by issuing the following command.
\one_table> rails server
4. Initiate the web application. Enter the local URL for the application in your browser’s URL window:
 	http://localhost:3000/

You should now see the following displayed on your browser.



5. Create user accounts. You will need a couple of accounts to exercise the functions of the One Table application. Let’s do this now like you did in Tutorial 1. 
Click Register Administrator to create the administrator account.  We refer to this account as the admin account. Logout and create a second account. We will refer to this second account as the user account in the following tutorials. By default, the user account does not have administrative privileges.
Later in the tutorial, you will learn to customize the default permission features.
Log out of the user account and login to the admin account for now.  Remember that you will use the admin email address and password to login, not the name.
6. Create the recipe model. Next create a model using the hobo:resource generator, which will be called Recipe. It will contain three fields: title, body and country. We will complete this step by rerunning the Hobo migration from Step 3. This will take the model definitions and create a migration file and the database table recipes.
\one_table> hobo g resource recipe title:string body:text country:string
	This generator created a recipe.rb model from which the hobo:migration generator will create a migration file and a database table.
Note: When we talk about a model’s name we are referring to its Ruby Class name that can be found at the top of the file.
	It also created the recipes_controller.rb controller, the recipes_helper.rb helper file, and recipes view folder. Run the hobo:migration generator:
\one_table>  hobo g migration

IMPORTANT: Hobo is different from Rails in that the migration file and database table are both the result of the hobo:migration generator. In Rails, generators typically create both models AND migration files but NOT database tables. 
	Refresh your browser and you should see a Recipes tab added. 


7. Confirm your login info. Make sure you are logged in as the administrator.  As long as you are logged in, you should see the “New Recipe” link on the left. 
	Create three recipes and take care to add info in all three fields. You can create them either from the Home or Recipes tab. The finished recipes should be displayed in both the Home tab and the Recipes tab automatically. You can click on any of the names of the recipes to edit them. Try it out.

Figure 61: Page view of created recipes
8. Login as a user. Sign out of the admin account and sign in as another. Note that you can still see the recipe title. Now, you can click on the recipe title and view the entire recipe record but you cannot create or edit a recipe. This is governed by the Hobo “Permissions” module. In the next step, you will change the user permissions and see how the user interface responds by automatically providing creation and editing capabilities in the user interface.
9. Edit permissions: Take a look at the recipe.rb model file. 
# --- Permissions --- #

def create_permitted?
	acting_user.administrator?
end

def update_permitted?
	acting_user.administrator?
end

def destroy_permitted?
	acting_user.administrator?
end

def view_permitted?(field)
	true
end
	There are four methods that define the basic permission system: create_permitted?, update_permitted?, destroy_permitted? and view_permitted?. In exercising the permission system, you are editing Ruby code. The permission methods are defined within Hobo. Each method evaluates a boolean-valued variable (actually a method on an object) that indicates whether the named action is allowed or not allowed. 
Method
Refers to permission to:
create_permitted?
create a record
update_permitted?
edit a record
destroy_permitted?
delete a record
View_permitted?(field)
view a record or field
Figure 62: Table of Hobo permission methods
For the code that is generated by the hobo:resource generator, the method is checking whether the acting user, which is the user that is signed on, is or is not the administrator. In practice though, the boolean value may ask another question or a more complex question. 
For example, one could write a line of Ruby code that determined if the signed on user was the admin AND the time was between 8:00 AM and 5:00 PM. In other words, there can be other logical determinations but you have to know a little Ruby.
acting_user method
Meaning
administrator?
first user to sign up
signed_up?
any user who is signed up (including the administrator)
guest?
any user who is not signed up
	Figure 63: Table of Hobo "acting_user" options
For these tutorials, we will use the acting_user object and its methods: administrator?, signed_up?, and guest?. Hobo encodes information about the user of its applications in the active_user object that determines if the user is an administrator, other signed up user or a guest user.
 	For example, acting_user.administrator? equals ‘1’ if the user is the administrator and ‘0’ if the user is not. If we place it within the create_permitted? method, Hobo only permits users who are administrators to create database records related to the model containing the method. 
Note: The ‘?’ after signed up indicates the method is a Boolean method.
The meaning of the default permissions code can be summarized simply now. Only the administrator is permitted to create, update or destroy records and anyone can view records. Using the view_permitted? method is a little more involved so we will wait until the intermediate tutorials to tell you about it.
Before trying this out, it is useful to understand how Hobo implements these permissions within Hobo’s UI. Yes, Hobo not only provides the facility to set permissions but it also takes care of providing the right links and controls within the UI.
When there is no create permission, there is no “Create a New {model_name} ” link.
When there is no update permission, there is no edit link and no way to populate a form with an existing record.
When there is no destroy permission, there is no “Remove this Record?” link. 
This will make more sense when you learn about controller actions in the next tutorial. Hobo permissions essentially turn controller actions (what users do in the UI) on or off depending on defined logical conditions.
Let’s try something out now.
As of now in your code, users who are not the admin can only view the records entered by the administrator. The user has no create, edit or delete permission; these options do not appear in the user interface.
	Now let’s make a minor change and see how the UI responds. 
	CHANGE:
def create_permitted?
	acting_user.administrator?
end
		TO:
def create_permitted?
	acting_user.signed_up?
end
	Update your browser and you will see the New Recipe link appear at the bottom of both the Home and Recipes tabs. Now do the following:

CHANGE:
def update_permitted?
	acting_user.administrator?
end

def destroy_permitted?
	acting_user.administrator?
end
TO:
def update_permitted?
	acting_user.signed_up? 
end

def destroy_permitted?
	acting_user.signed_up?
end
	Click a recipe title. On the right hand side of the screen showing the record, you will see an Edit Recipe link now indicating editing permission. Click this edit link and you will now see a full editing page as well as a Remove This Recipe delete link in the upper right of the page.

	
	Try changing all of the signed_up? methods to guest and you will observe that you have full permissions even if you are not signed in.
	Complete the tutorial by putting back all three methods to signed_up?.
Tutorial 5 –  Controllers

Topics
Introduce Hobo’s controller/routing system.
Hobo automatic actions
Show examples of the permission system working with controllers
Tutorial Application: one_table	

Steps
1.	Demonstrate controller actions. Hobo has a set of built in actions for responding to user-initiated requests from browser actions (clicks). For example, when Hobo displayed the Recipes in Tutorial 3, it is the result of the index action found in the /app/controllers/recipes_controller.rb file. Open this file.  
Note: Recall that controller and model files contain Ruby code whereas view templates contain HTML with embedded Ruby code.

class RecipesController < ApplicationController
	hobo_model_controller

 	auto_actions :all
end
There is not much you can see--but there is a lot going on behind the scenes.
The first line is similar to the first line of the Recipe model we told you about in Tutorial 1. It indicates that the RecipesController is part of the Rails  ApplicationController and inherits general capabilities from this master controller. 
The next line, hobo_model_controller, tells Rails to use Hobo’s controller functionality to control the Recipe model and views.  It is actually short for:
#Do not copy - although it won’t change anything if you do.
hobo_model_controller Recipe 
Hobo automatically infers the model name from the controller name in the first line above. 
Note: The pound (or “hash”) character (#) is the symbol to indicate a Ruby comment. Everything on a line following # will be ignored by Ruby. Code starts again on the next line. To create view template comments, where you are not in a Ruby file you must surround comments like this <!--Comment-->.
The next line, auto_actions :all, makes all the standard actions available to the controller including: index (meaning “list”), show, new, create, edit, update, and destroy (meaning “delete”). If you are familiar with Rails, you will realize that Hobo has replaced quite a bit of Rails code in these two lines. 
2.	Edit the auto_actions. Clicking the Recipes tab in your app invokes the index action of the Recipes controller. The index action of the controller tells Hobo to list the records of the model. You probably noticed this as you created new records. Each time you created a new one, you probably clicked on the tab to see a list of all the records you created.  
Now notice something else that you will learn to be important. When you click on the Recipes tab, the URL that is displayed in the URL window says: 
http://localhost:3000/recipes
As you learn about the functions of the fundamental Hobo actions (listed in Step 1 above), you will learn that there is a unique URL entirely specified by the action and model name.  Look at figure earlier in this book about  “Actions and Routes”, and you will see the URL for an index action is the base URL, http://localhost:3000/ concatenated with the plural of the model name, which in this case is “recipes”.  
We are going to further demonstrate that attempting to route to this URL invokes the index action by turning off the action in Hobo and then putting turning it back on. First go to your home page by clicking the Home tab. Then, in recipes_controller.rb,
CHANGE:
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :all

end
TO:
class RecipesController < ApplicationController

	hobo_model_controller 
	
	auto_actions :all, :except => :index

end
The  except clause in this code tells the controller to turn off the index action. 
Refresh your browser and you should see this display:


Your Recipes tab disappeared. You can also try invoking the index action by typing http://localhost:3000/recipes into your URL window. You will get a blank page.
Hobo will no longer invoke the index action because you told it not to in your code. Hobo decided to do more though; it changed the UI also. 
In Tutorial 3, you learned that Hobo figures out how your UI should look depending on your model code. There it changed what links were available depending on permissions you specified in the code. In this case, Hobo figures out how to change the UI depending on the controller code. Here it has removed a tab, the Recipes tab, because you disallowed the action that it would invoke. Now remove the except clause and you should get your Recipes tab back.
Note: If you are new to Ruby you are probably noticing all the colons(:) and arrows (=>). For now.  Think of these two as a way of connecting a Ruby symbol (any text that begins with a colon) to a value (the entity after the expression  “=>”).  We recommend a companion book such as Peter Cooper’s “Beginning Ruby:  From Novice to Professional” to learn more about Ruby symbols and their importance.
Now turn the index action back on by deleting the :except clause.
class RecipesController < ApplicationController

  hobo_model_controller

  auto_actions :all
  
end
3. 	Remove and restore the new and show actions. Hobo allows you to edit this in two ways. You can either stipulate you want all except certain actions or that you want only specific actions. In other words, you can either indicate which actions you wish to include or indicate which actions you wish to exclude. The former is what you did in step three. Let’s try the latter where you declare which actions you want. The following code will do exactly what you did before but in a different way.
First, use the following code to include all seven actions, including the index action. This code is equivalent to the auto_actions :all statement above.
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :index, :show, :new, :create, :edit, :update, :destroy

end
Try removing the index action. When you save your code and refresh your browser, you will obtain the same result using the :except => index code. Now put back the index action and try removing the :new option.
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :index, :show, :create, :edit, :update, :destroy

end
The result is that the New Recipe link to http://localhost:3000/recipes/new, the URL associated with the new action disappears. This is because you have disallowed the new action and Hobo takes care of cleaning up your UI for you. Even if you try to go to that URL by typing http://localhost:3000/recipes/new into the browser, Hobo tells you that you can no longer go there.

Put the :new action back in and click the Recipes tab. Mouse over the Recipe links and note that the URL’s look like,  http://localhost:3000/recipes/2-omelette which are of the form http://localhost:3000/model(plural)/ID-model_name_variable which is the form that we discussed earlier in this tutorial for the show action. 
Note: Hobo assigns a name variable to the model equal to the value of the field it thinks is the most likely summary field. Hobo first looks for a field called name.  Next it looks for the next most likely, which in this case it guesses is title. You can override the automatic name assignment by adding the option :name => true to the field you would like displayed as the “name”. 

Figure 67: How Hobo finds the default "name" attribute for a model
You can also use a little “Hobo magic” to create your own version of name using a Ruby method as below:

Figure 68: Creating your own custom "name" attribute




Figure 69: Page view of the custom name attribute

Now back to our original train of thought…Remove the :show action.:
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :index, :new, :create, :edit, :update, :destroy

end
Now when you refresh your browser you will note that you no longer have links to show(display) the details of a particular Recipe record. Even if you try to navigate your browser to http://localhost:3000/recipes/2-omelette, you will get an error.
Now let’s try one more but using the except version of auto_actions again but first make sure you are back to the all actions state. Use the code below.
class RecipesController < ApplicationController

	hobo_model_controller 
	
	auto_actions :all

end
Navigate to the Recipes link where you should now see a list of hyperlinks to each recipe. Click on a recipe.


Observe the Edit Recipe link on the right hand side of the display. Click or mouse over it to convince yourself that the URL associated with this link is:
    http://localhost:3000/recipes/6-hamburger/edit
This is just the result you would expect for the edit action of the form: 
    http://localhost:3000/model(plural)/ID-model_name_variable/edit
Now make sure you are on the screen above, a particular Recipe. Edit your code to remove the edit action.
class RecipesController < ApplicationController
	 hobo_model_controller 
	 auto_actions :all, :except => :edit
end
Now you should see that Hobo removes the links to the edit action and even if you try to force Hobo to go to the above URL, it will not, giving you an error:


1. Remove multiple actions. So far we have showed you how to remove one action at a time. You can use the two methods we have showed you to remove two or more actions at a time. If you use the listing approach and you are starting with all the actions as in:
class RecipesController < ApplicationController
	
   hobo_model_controller
  
   auto_actions :index, :show, :new, :create, :edit, :update, :destroy

end
If you want to remove both the new and the create actions, just delete them from your list so that you have:
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :index, :show, :edit, :update, :destroy

end
If you start be specifying all actions and use the except clause, the equivalent code to the above will be:
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :all, :except => [:new, :create]

end

Note: When removing the :new action, this actually adds a 'New' facility below the list of Recipes. When you remove the :show action, Hobo places an 'Edit' link against each listed item.

You may be wondering why the :except option encloses the list of actions in square brackets and the listing approach does not. The Ruby :except method takes a Ruby array as an input and Ruby arrays are enclosed in square brackets. 
5.	Using controller short cuts. There is one other way to add or remove controller actions and that is through the use of short cuts. The code:
auto_actions :read_only
is the same as:
auto_actions :index, :show
The code:
auto_actions :write_only
is the same as:
auto_actions :create, :update, :destroy

Note: You can append actions or use the except actions clause with either of these short cuts. The proviso is that you must use the shortcut first and [use only one] and use the except clause last.

6.     Hobo Controller action summary. Below is a list of all controller actions 
Action
Summary Meaning
URL Mapping
Example
(model -  recipe)
index
display list of records
/base/model(plural)
/base/recipes
show
display a single record
/base/model(plural)/ID-name
/base/recipes/2-omelette
new
allocate memory for a new record and open a form to hold it.
/base/model(plural)/ID-name
/base/recipes/new
create
save the new record.
link without landing
/base/recipes
edit
retrieve a record from the database and display it in a form
/base/model(plural)/ID-name/edit
/base/recipes
update
save the contents of an edited record
lands on show
/base/recipes
destroy
delete the record
lands on index
/base/recipes
Figure 72: Hobo Controller action summary
 
Tutorial 6 – Navigation Tabs

This tutorial provides an introduction to Hobo’s automatically generated tags. We will start with the navigation tabs that are generated for each mode.  We will show you where to find them and how to make a simple edit to change how navigation tabs are displayed. We will explore this more deeply in Chapter 4. 
Topics
Locate Rapid directories
Edit the navigation tab
Tutorial Application: one_table	
Steps
1.	Find Hobo’s auto-generated tags. Open up the views directory and navigate to the rapid directory by following this tree: views/taglibs/auto/rapid. You will see three files called: pages.dryml, forms.dryml, and cards.dryml. It is here that Hobo keeps its default definition of the tags its uses to generate view templates.
2.	Open the pages.dryml. file. Take a quick look through this file and you will see tag definitions such as:
<def tag="main-nav"> . . . 
<def tag="index-page" for="Recipe">
<def tag="new-page" for="Recipe">
<def tag="show-page" for="Recipe">
<def tag="edit-page" for="Recipe">
Notice how, except for the <main-nav> tag these correspond to the actions of Hobo Controller action summary above in Tutorial 5. You will further note that these are just the actions that require a view (remember index means list). The other actions, create, update, and destroy only needed a hyperlink. We are only mentioning this now to pique your curiosity for Chapter 4 where you will delve deeply into Hobo’s way of creating and editing view templates.
3.	Edit the <main-nav> tag. Copy the following code and paste it into your views/taglibs/application.dryml file. Hobo automatically uses code in this file instead of what it finds in pages.dryml. In other words, application.dryml overrides pages.dryml and further makes it available to the entire application. 
<def tag="main-nav">
  <navigation class="main-nav" merge-attrs param="default">
    <nav-item href="#{base_url}/">Home</nav-item>
    <nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
  </navigation>
</def>
5.	Rename a Navigation Tab. By convention, Hobo names tabs, other than the Home tab with the plural of the model name. In this case, that is ‘Recipes’ Let’s try renaming this to ‘My Recipes’.  There are a couple of ways to do this:
Use Hobo’s i18n module to specify a new value for the recipe.nav_item key
Override the main-nav tag in application.dryml and rewrite it to specify ‘My Recipes’ as the Recipe tab label
The preferred way of doing this is the first option and specify a new value for the recipe.nav_item key, the reason for this is that this maintains the application’s ability to handle multiple languages.  If we overrode the main-nav tag in application.dryml, this would be a ‘hard-coded’ solution and would always show ‘My Recipes’ regardless of the current locale/language.
Just add the following to your config/locales/app.en.yml file:
en:
  recipe:
    nav_item: "My Recipes"
Refresh your browser and you will see a renamed tab:



6.  Remove the Home Tab. Instead of deleting the Home tab, just comment it out by surrounding it with <!-- ...-->.
Note: Since view files are essentially HTML and not Ruby code, you use the HTML commenting syntax instead of the Ruby comment syntax.

<def tag="main-nav">
	<navigation class="main-nav" merge-attrs>
		<!--<nav-item href="#{base_url}/">Home</nav-item>-->
		<nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
	</navigation>
</def>

Now refresh your browser and you will see the Home tab has been removed:


7.	Reset the tabs. Since editing the application.dryml file will interfere with future tutorials, delete the code you copied above.
<def tag="main-nav">
	<navigation class="main-nav" merge-attrs>
		<!--<nav-item href="#{base_url}/">Home</nav-item>-->
		<nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
	</navigation>
</def>




Tutorial 7 – Model Relationships: Part 1	

You will learn how to create a new model that is related to another table. You will replace one of your table’s original fields with a key that is linked to a foreign key in order to select values. You will see how Hobo automatically creates a drop-down control to select values that you have entered.
You will also make some controller action edits [and some permissions changes] to refine the user interface.
More specifically, you will add a new model to hold the names of countries that a user will select from the New Recipe page. The application will identify the foreign key for that country and place it in the recipes table.
Topics
Model relationships
Foreign keys
Drop-down list boxes

Tutorial Application: one_table
Steps

1. Copy the Application. If you would like to preserve your application in its state as of the end of Tutorial 6, you may wish to copy the application and work on the new version. Copy the entire application directory and paste it into a folder called two_table in your tutorials directory. 
To change the application name, make the following change to config/application.rb:											
Figure 75: Changing the Application Name
Shut down the web server by issuing a <control-c> in the command window where you issued the rails server command. 
Restart the web server and you are ready to go.
\two_table> rails server 
2.	Add drop down control for preset selections. This tutorial is about adding associations between tables. In subsequent steps, we are going to show you how to create a new Countries table to store the values of country names to associate with your recipes. Hobo will take care of the user interface rendering, as you will soon see.
Before we do that though, let’s demonstrate the simpler approach. This is the easy way to go for applications when you know at design time all the possible values of a category. In this case, you would not need to add the additional complexity of creating a table to maintain all values for countries. All that is needed is to specify  in the model the list of possible values using the enum_string attribute of a field. In this tutorial let’s assume the only values for country will be: American, French & Chinese.
Your recipe.rb model code should now look like:
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    title   :string
    body    :text
    #country :string
    country enum_string(:American, :French, :Chinese)
    timestamps
  end
We have used the enum_string field method to declare the possible values for country. So we can easily see what we have done, we have commented out the old version of the country field declaration by preceding it with a ‘#’ (hash). Now refresh your browser and click ‘New Recipe’ and you will see a drop-down control that lets you select values for country.


This is fine as long as you don’t have to change the possible values. In the next steps, we will show you how to create a new table to store country values and be able to edit it on the fly and have it be reflected in your GUI. You will not have to write any queries. Hobo will take care of everything for you.
3.	Remove drop down control. First let’s get back to where we started before adding a new table. Edit your code to look like this.
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    title   :string
    body    :text
    country :string
    #country enum_string(:American, :French, :Chinese)
    timestamps
  end

The drop-down control will now be gone when you refresh your browser.
Note: Remove the custom name attribute you created in the last tutorial before continuing.
4.	Creating model associations. In the next several steps, we will add a Country model, set up a relationship between the Country model and the recipe model and then run a Hobo migration to create the Countries table. This last step will also set up the foreign key in the Recipe model that will maintain the association to the index of the new Country model, country_id. 
When you look in the db/schema file to review the fields in your tables, you will not see the ID’s of any table listed but they are there. Every time you create a table using a migration in Hobo, it will also create the table index with a name defined by convention to be the model name with ‘_ID’ appended.
5.	Add a new model. We will use Hobo’s hobo:resource generator to create a new model with one field to store a country’s name. If you do not have a command prompt window open besides the window you used to start your web server, open a new one now and navigate to the root of the application.
\two_table>
Execute the following command from your command prompt.
\two_table> hobo g resource country name:string
Check the models directory and you should see a country.rb file with the following contents defining the Country name field.
class Country < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end
If you look in the db/schema file, however, you will not see a countries table because you have not run the migration yet. Let’s define our relationships now.
The hobo:resource generator also created some other files. An important one is the controller file called countries_controller.rb. Note that the class names (how Hobo refers to them) are CountriesController for the controller and Country for the model, which you can see, in the first line of code in the respective files. 
Note: The controller has a file and class name that is the plural of the model name. The file names use underscores in the file names and removes them for class names. 
6.	Remove a field. In preparation for setting up a relationship between the Recipe and Country models, you must delete the country field in the Recipe model. It will not be needed any more since it is replaced by the name field in the Country model. 
Open the recipe.rb model file and delete the country field from the fields…do block at the beginning of the file. So you can see what you have done, it would easiest to comment it out. Change this:
…
  fields do
    title   :string
    body    :text
   # country enum_string (:American, :French, :Chinese)
    timestamps
  end
…
7.   Add a  belongs_to relationship. The Recipe model will have what is called a belongs_to relationship with the new Country model. This relationship or association requires that every recipe have at the most one country associated with it. Add the belongs_to declaration just before the #permissions comment.  Any belongs_to declarations must be added after the fields…do block. 
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    title   :string
    body    :text
   # country enum_string (:American, :French, :Chinese)
    timestamps
  end
  
  belongs_to :country 

  validates_presence_of :country
…

	We have also added validation so that the country is always specified for all recipes.

Note: It is useful to read belongs_to as ‘refers to’ to remind yourself that when this relationship is declared, it causes the creation of a key field named country_id in the recipes table to “refer to” the country table, which contains the name field.

In the above belongs_to statement, :country is the name of a relationship. It is not the name of a field. Through its naming conventions, Hobo determines that the model to relate to is named Country. For the case when naming conventions fail, you can force the relationship as in the following code:

  belongs_to :country, :class_name=>"Some_other_model"
8.   Add a  has_many relationship. The Country model needs the inverse relationship to the belongs_to in the Recipe model:. 
class Country < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end
 
 has_many :recipes
...
When you learn to do more sophisticated programming, this feature of naming relationships, which Hobo inherits from Rails, will become a powerful tool. Unlike standard relational database relationships, this capability essentially adds meaning to the relationship.
9. Run the Hobo migration. Now you have done everything needed for Hobo’s intelligence to take over and create the new countries table and set up the proper foreign keys.
Now, go to your command prompt and run the Hobo migration. By doing this you will allow Hobo to accomplish several things. Hobo will: 
Create the migration file for the new table, countries
Remove the country field from the recipes table
Set up a foreign key to handle the relationship between Recipe and Country
Execute the migration to create the new database table, Countries. 
For every recipe record with a country entered, there will now be a country_id value written in the recipestable that corresponds to a country_id in a country record.
\two_table> hobo g migration
You will get the following response:
DROP or RENAME?: column recipes.country
Rename choices: country_id
Enter either 'drop country' or one of the rename choices:
Hobo has noticed that there is an ambiguity you have created that needs to be resolved. There is both a country field and a Country model. It knows you need a foreign key, country_id, to relate to the Countries table. So it gives you a choice to rename country to country_id or drop the country field and create a new country_id field. Since country has real country names in it, not foreign key integer values, it is best to drop it and let Hobo create a new field for the foreign key. 
Enter ‘drop country’ (without quotation marks) in response. 
Next the migration will respond as follows:
What now: [g]enerate migration, generate and [m]igrate now or [c]ancel?
You should type ‘m’.
Last it will prompt you to name the migration file:
Filename [hobo_migration_3]:
Just hit the ‘enter’ key and it will take the default name, hobo_migration_3.
10.  Review the results of your migration. Let’s take a look at the database schema in db/schema.rb:
ActiveRecord::Schema.define(:version => 20100313165708) do

  create_table "countries", :force => true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  create_table "recipes", :force => true do |t|
    t.string   "title"
    t.text     "body"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.integer  "country_id"
  end

  add_index "recipes", ["country_id"], :name => "index_recipes_on_country_id"

  create_table "users", :force => true do |t|
    t.string   "crypted_password",          :limit => 40
    t.string   "salt",                      :limit => 40
    t.string   "remember_token"
    t.datetime "remember_token_expires_at"
    t.string   "name"
    t.string   "email_address"
    t.boolean  "administrator",                           :default => false
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "state",                                   :default => "active"
    t.datetime "key_timestamp"
  end

  add_index "users", ["state"], :name => "index_users_on_state"

end


Note: Hobo automatically creates appropriate indexes for table relationships with foreign keys.  We will discuss how to enhance or disable this feature in a later tutorial.

11. 	Double-check the tab code before refreshing your browser. Back in Tutorial 6 #7, we asked you to delete the <navigation> tag. Go back there and make sure you completed that step before refreshing your browser. You should see a new tab for Countries.  
12.  Review a few features of the UI. Make sure you are signed in as the admin. Go to the Countries tab and click through to enter a few countries. 



Then go to the Recipes tab and click through to edit one of your recipes. You should now see a drop down box just as you saw when you used the enum_string option for your attribute:


The difference is that you are now actually selecting a country_id foreign key behind the scenes. Hobo takes care of querying the  countries table (Country model) and displaying the actual country names. When you save this Recipe record, Hobo maintains all of the necessary related keys automatically.
After you do the save, note that the Country value in the page is an active hyperlink:
. 
	
If you click it, you will see a screen that allows you to edit the Country record.


You can edit a country record because you are logged in as the “administrator”. If you check the countries.rb file, you will see that the permission to edit the Country field is limited to the administrator. This means that if you log in as a regular user, Hobo should not allow the edit. Log out from the administrator account and login as regular user.
class Country < ActiveRecord::Base

. . .
  # --- Permissions --- #

  def create_permitted?
    acting_user.administrator?
  end

  def update_permitted?
    acting_user.administrator?
  end

. . . 
Now go to the Recipes tab, click on a recipe link and edit the recipe. Next click on the country name on the page. Now you see that the Edit Country link is no longer available. 


12.	One-to-many relationship discussion. The relationship or association that you have just implemented is known as a one-to-many relationship. In this particular situation, we have an individual country that is related to many recipes. More specifically, there is one record in the Countries table with the name ‘American,’ but potentially many American recipes.
Tutorial 8 – Model Relationships: Part II

In this tutorial you will learn to implement many-to-many relationships. These relationships are useful, for example, in categorizing a model’s records. You will implement the relationship using the “has_many”, “has_many =>:through”, and “belongs_to” relationship declarations of Rails. You will learn how Hobo establishes a direct relationship between model relationships and the features of the UI.

In terms of our tutorial application, you will be adding recipe categories so that you can categorize recipes as, for example sweet, sour, or hot. You will implement an architecture where it is easy to invert the relationships so that you can display both which categories a recipe belongs to and which recipes are classified in a particular category. 
PREREQUISITES: Tutorials 1-6.
Topics
Many-to-many relationships
Using the has_many, has_many =>:through, and belongs_to rails relationship declarations
Fixing a UI assumption by Hobo when it is not the optimum.

Tutorial Application: four_table
Steps
1.	Copy the Application. Just like you did in Tutorial 7, we suggest you copy your application from Tutorial 7 in order to easily go back to its state at the end of that tutorial. Shut down the web server by issuing a <Control-C> in the command window where you issued the rails server command. 
Then, do a copy in whatever operating system you are using. We have called the new application directory four_table. Navigate to the new directory. Restart the web server and you are ready to go.
\four_table> rails server
You may wish to change the name of your application as displayed in the UI. Go to config/application.rb.  Change the key config.hobo.app_name to read:
config.hobo.app_name = "Four Table" 
Now refresh your browser and you will see the new name.
2. Create the models. We are going to add two new models to our original application and keep the original Recipe and Country models. The first will be a Category model and the second will be a CategoryAssignment model. 
CategoryAssignment will have the two fields, category_id and recipe_id that correspond to keys of the same name in the Category and Recipe models.
Note: If you review the schema in the app/db directory, you will not see these fields listed in the Categories and Recipes table. They are the default keys for these tables. Rails does not list them.
As you will see shortly, you do not have to worry about creating or naming any of these fields, the Hobo generators will take care of it all for you.
Go to your command prompt and issue the following two commands:
\four_table> hobo g resource category name:string
\four_table> hobo g model category_assignment 
The first command will create both a controller and model, Category being the name of the model. The second will create a CategoryAssignment model but no controller. 
When you implement the relationships below, you will see that CategoryAssignment sits in between the Recipe and Category models. You do not need a CategoryAssignments controller because you will be accessing recipes and categories through these models directly and need no actions that pull data directly from the intermediary CategoryAssignment model.
3.	Add relationships to your models. Edit the models as shown below to enter model relationships. 
Note: Hobo migrations rely on both the field declarations in your models AND the relationship declarations. The relationship declarations allows Hobo to setup all the necessary keys to implement real model relationships.
recipe.rb
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    title   :string
    body    :text
    #country :string
    timestamps
  end
  belongs_to :country
  has_many :categories, :through => :category_assignments,  :accessible => true
  has_many :category_assignments, :dependent => :destroy
 


category.rb
class Category < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end

  has_many :recipes, :through => :category_assignments
  has_many :category_assignments, :dependent => :destroy
category_assignment.rb 
class CategoryAssignment < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    timestamps
  end

 belongs_to  :category 
 belongs_to  :recipe
4.	Discussion of model relationships. Note above that you used the has_many and the belongs_to relationships. You further used a has_many relationship with a :through option.
Let’s start with the belongs_to relationship, which we used in Tutorial 7 and declared in the CategoryAssignment model above.
Recall that when you see belongs_to, think refers to, and you will understand that these declarations cause the category_id and recipe_id fields to be placed in the category_assignments table.
The has_many :through statements instructs Hobo/Rails to setup the necessary functions to access a category from a recipe or a recipe from a category. The vanilla has_many statements set up the one to many relationships between the recipes table and the category_assignments tables and between the categories and category_assignments tables.
The :dependent => destroy option makes sure that when either a recipe or category is deleted that the corresponding records in the category_assignments table are removed automatically too. 
5.	Run the hobo g migration. Go to your command prompt and run the following.
\four_table> hobo g migration
Remember to respond ‘m’ when prompted for migration and just press <enter> when prompted with the migration file name.
Note: At this point, if your web server is still running from earlier tutorials, you need to terminate it and restart it. Rails and Hobo will not recognize a new database table without doing so.

\four_table> rails server
6.	Populate the new table. Open up your browser to http://localhost:3000/ and you should see the following (since you had copied over all the files from the Two Table application, your database came with you so you will not see the Register Administrator form):


Now go to the new Categories tab and enter in some food categories:


7.	Adding new records to the relationships. Go to the Recipes tab. Click on one of the recipes and you should get this.


Notice there is no category assignment.
Then click Edit Recipe on the right.


Now you can see a new drop-down box that lets you add categories to your recipe. Hobo has taken care of this for you by inferring that you need it from your model relationship declarations.
Note: Here is a good example of the DRY (Don’t Repeat Yourself) notion playing out. If the necessary UI controls can be directly inferred from model structure, there should be no need to directly code it yourself. You may wish to use a different control but Hobo picks a reasonable one for you so you do not have to bother unless you want to.
Take a look at the URL that activated the page. You will see that the URL is of the form for a “controller edit” action. If you need to remind yourself of the form look at the Hobo Controller Action Summary figure in Tutorial 5 step 6.
Try adding a couple of categories and save the changes. 


Here, on the Edit Recipe screen, you can see that Hobo is displaying the entries for the Recipe categories you have chosen to associate with the recipe, namely hot and sour. So far, Hobo is doing just what we would expect.
8.	Add information to the model in order to display the associations. Hobo, before version 1.3, used ViewHints to indicate to the application how you would like to display related information on a model’s show page.  To simplify things, this functionality has been moved into the model itself and ViewHints are no longer used as of Hobo 1.3.  So now you modify the ActiveRecord model itself.  
Edit the app/models/recipe.rb file.  Enter the code (in bold italics below) to tell Hobo explicitly to use categories as the child of recipes in its displays.
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name   :string
    body    :text
    timestamps
  end

  belongs_to :country
  has_many :categories, :through => :category_assignments,  :accessible => true
  has_many :category_assignments, :dependent => :destroy

  children :categories

  [ ... ]

Now edit country.rb:

class Country < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end

  has_many :recipes
  
  children :recipes

  [ ... ]

Now refresh your browser and choose a recipe to view:


If you wish to see all the recipes, which are ‘hot’, you would click on ‘hot’ to check this out; or you could go to ‘Categories’ and then click on ‘hot’.


Now let’s enhance this view. Edit  app/models/category.rb: 
Enter the code (in italics and bold below) to tell Hobo explicitly to use recipes as the child of categories in its displays.
class Category < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end

  has_many :recipes, :through => :category_assignments
  has_many :category_assignments, :dependent => :destroy
  
  children :recipes

  [ ... ]
Refresh your browser.


Now you can see all of the “children” of the category “Hot” on the Category “show” page.

9.	Comments on the many-to-many relationship. Now let’s review how you got this all to work. The end product is that you can see the categories associated with each recipe and the recipes associated with each category. 
In each case you can click through to look at individual categories or recipes and edit them if you wish.
All of this is a result of having a recipe model related to a category_assignment model, which is, in turn, related to the category, model and vice versa. We will call the category_assignment model the intermediary model and the other two, “outer” models.
You have created a symmetrical set of model relationships where the two outer models have has_many relationships with the intermediary model and has_many :through relationships with each other. Conversely, the intermediary model has a belongs_to relationship with each of the outer models. 

This structure will be used frequently in most data-rich applications. It is worth noting how you need only a few lines of code to implement this structure and how it lets you access each outer model from the other.
CHAPTER 4 – INTERMEDIATE TUTORIALS

Introductory Concepts and Comments
Tutorial 9 - Editing Auto-Generated Tag
Tutorial 10 - DRYML I:  A First Look at DRYML 
Tutorial 11 - DRYML
Tutorial 12 - Rapid, DRYML
Tutorial 13 - Listing Data in Table Form
Tutorial 14 - Working with the Show Page 
Tutorial 15 - New and Edit Pages With The Form Tag 
Tutorial 16 - The <a> Tag Hyperlink



	

Introductory Concepts and Comments

In Chapter 3 we deliberately focused on helping you get something done without spending much time looking under the hood--or should we say--behind the “Magic Curtain.” 
When Jeff and I first discovered Hobo, we were impressed by what seemed like little magic tricks that Tom had Hobo perform for us:  dynamic AJAX without coding; automatic page flow; automatic checking and executing changes to the database when declarations change; built-in permissions system and data lifecycles; high-level declarative markup language: you can do so much that looks and acts great.
Of course, there will ALWAYS be something you need to do that doesn’t come ready-made out-of-the-box. So--just like learning magic tricks--you can learn how Hobo works and create some new magic tricks of your own to impress and help your clients in Rapid time.
No magician worth his salt will reveal his tricks to an apprentice all at once.  There is only so much we can absorb at one time. The trick to learning--as well as developing software--is to do it incrementally. Get grounded at each step. Most magic tricks use the same knowledge of human perception, habits and expectations to create the illusions.  
Learning one trick helps you learn another faster. Then you learn the patterns.  And after that, you learn to make more patterns that you and others can use again and again.
So, in this chapter we will start revealing how “Rapid” (Hobo’s process of automatically rendering forms, views and routing) works in a way we think it can best be absorbed.
One of the ways is to examine the code that the author has written that runs the application itself.  In the early versions of Hobo, the rendering of pages, forms, and navigation flow was done “auto-magically” by Rapid.  You couldn’t see how it worked until version  0.8.0.  It was in this release that Tom Locke made visible the DRYML code that was being executed in the background, invisibly.
So now you can look, learn, and copy the DRYML that “Rapid” actually uses to generate Pages, Cards, Forms and the Main Navigation Menu.
Take a close look at \apps\views\taglibs\auto\rapid folder of any of your Hobo apps:


Notice that there are three DRYML files: cards.dryml, forms.dryml, and pages.dryml. These files include the DRYML XML-like formatted tags that are the declarative statements used as templates to render web page views and forms. They provide the logic to render a combination of HTML, JavaScript, and CSS code when needed.
DRYML provides a high-level of abstraction for formatting web pages and dealing with all aspects of data-driven applications.  Listing, displaying, creating, editing and deleting records are simplified without the necessity of specifying the granular level of detail that other frameworks require, such as Rails with its ERB (embedded Ruby) pages that are a hybrid of Ruby and HTML.
In this chapter we will explore:
(1) The Hobo Rapid library of tags
(2)  The auto-generated DRYML files that expose the Rapid process
(3)  User-defined tags that you can use to extend Hobo
Hobo Rapid Library of Tags. Hobo comes with a pre-coded set of tags that you can use to build other tags. It provides tags to handle forms, display collections of records, and render a table of records. Hobo uses these to build the Rapid default web pages.  You will learn to use some of the more common Rapid tags in this chapter.

Auto-generated DRYML. These DRYML files are saved replicas of Hobo’s way of coding the view associated with all of the web site actions. For example, there is a <show-page> tag involved with displaying a single record, and <index-page> tag to display a list of records, and a <new-page> tag involved with generating the form to accept the data for a new record.

User-defined Tags. In order to create your own tags, Hobo provides tag definition language elements. You can build custom tags that include HTML, DRYML tags defined in Hobo’s Rapid library, and even imbedded custom Ruby code. There is great flexibility. The end result can be simple tag that you use in a Hobo view template to include in the definition of a web page.
Tutorial 9 – Editing Auto-Generated Tags 

In this tutorial, you will learn about Hobo’s auto-generated tags that render views in response to controller actions. You will find your way around Hobo’s Rapid directories and files where the auto-generated tags are stored. You will also learn how to make minor edits to the auto-generated tags to prepare you for making tags from tags and redefining tags in later tutorials.
Hobo’s Rapid component handles the generation of an application’s auto-generated tags. The auto-generated tags are built from both HTML and Hobo’s internal library of XML tags called the Rapid Library.
The most important lesson you will learn in this tutorial is how Hobo associates its fundamental auto-generated tags with the four fundamental controller actions: 
index for listing collections of records
show for displaying a single record
new for creating records
edit for editing a single record
The other fundamental actions of saving new and edited records and deleting records are embedded within these fundamental tags as links because they do not need their own web pages. In addition to these four main tags, there is also a navigation tag that defines certain parts of the navigation interface.
Topics
Edit an index page tag
Edit a card tag
Edit a form tag
Edit the Navigation tags 

Tutorial Application: four_table
	
Steps
1.	Start your web server. We are going to continue on from Chapter 3 and use the four_table application. If you don’t have it started, navigate to your four_table directory, in tutorials/four_table, and start the application.

\four_table> rails server
You should now have a UI that looks like this:


Now open your editor and navigate to the views/taglibs/auto/rapid directory:

Figure 92: Folder view of the rapid DRYML files
Take a look at this directory structure. Focus on the files in the views/taglibs/auto/rapid directory. The Rapid auto-generated tags are stored in these files. Hobo updates the three Rapid directory files, pages.dryml, forms.dryml and cards.dryml every time you run a hobo g migration. Don’t edit these files because Hobo will overwrite them.  You can copy and paste pieces, and therefore override them, with code placed in either the application.dryml file or in a template file in a view directory named for a specific model, e.g., views/recipes. This will be explained below in this tutorial.
2.	Familiarize yourself with the Rapid auto-generated files. Let’s look at the pages.dryml file first. Open up the views/taglibs/auto/rapid/pages.dryml file. You will see a series of tag definitions. Look through the file. Notice that there is a Main Navigation section, a Recipes section and a Users section.  There are also sections  related to the app’s other models.
We will be talking about the Recipes and Navigation section in this tutorial.
Open up the forms.dryml and cards.dryml files and page through them. You will see similar structures. You will see a section describing Recipes and the other models we have built so far.
Now that you have familiarized yourself with the three Rapid auto-generated tag files, go back to the pages.dryml file. 
3.	Understanding the pages.dryml file. We are not going to explain every detail about what you see in pages.dryml at this point. In subsequent tutorials in this chapter, you will learn most of the key points. The goal in this tutorial is to get some familiarity with the tag structures and how Hobo uses and overrides them. 
Now focus in on the Recipes section. You will see four tag definitions: <index-page>, <show-page>, <new-page> and <edit-page>:

<!-- ====== Recipe Pages ====== -->

<def tag="index-page" for="Recipe"> . . . 
</def>

<def tag="new-page" for="Recipe"> . . .
</def>

<def tag="show-page" for="Recipe"> . . .
</def>

<def tag="edit-page" for="Recipe"> . . .
</def>

The following table explains what each of these does. Rapid automatically creates this set of four tags for each model in your application.
Tag
Meaning
Calls
Controller Action
Route (URL)
<index-page>
renders a list of model records
Cards
index
*/model_name(plural)
<new-page>
renders a data entry page for a new record.
Forms
new
*/model_name/new
<show-page>
renders a single record.
None
show
*/model_name/ID-record_name
<edit-page>
renders a data entry page for an existing record.
Forms
edit
*/model_name/edit/ID-record_name
Figure 93: Hobo Page Action Tag definitions
You cannot see it explicitly in the pages.dryml file, but the <index-page> tag calls the Recipe <card> tag. We will demonstrate this by editing them shortly. The <new-page> and <edit-page> tags call the Recipe <form> tags. 
These auto-generated tags, each of the four tags above as well as the <form> and <card> tags, are built from tags defined in the Rapid library of tags. The four page tags are built from the Rapid <page> tag, the form tag from the Rapid <form> tag and the card tag from the Rapid <card> tag. 
You might be confused at first because the auto-generated tags <form> and <card> have the same names as the Rapid auto-generated tags. What Hobo is really doing is redefining these tags and using the same tag name in the redefined tag.
The last important point to realize is that there is a one-to-one association between these four tags and both controller actions and their associated routes. Routes are the URLs related to the web pages resulting from a particular controller action. Hobo automatically defines the routes, although they can be user-defined and customized too. 
The controller action can be executed by navigating to the browser route URL listed in the figure at the top of this page.
Note:  The asterisk (*) refers to the route URL for your app, which is usually http://localhost:3000 for Ruby on Rails development setups.
4.	Edit the index page (method 1). Open up the pages.dryml file and look at the <index-page> tag definition. Here is what it looks like:


You invoke the index action by clicking on a tab with a particular model name, which is Recipes in this example. Go ahead and click the Recipes tab to remind yourself where you left off in Tutorial 6 of Chapter 3: 


Note that the URL that generates the “Recipes Index” page, http://localhost:3000/recipes, has the form of an index action. (Refer to the Hobo Page Action Tag definitions figure earlier in this tutorial.) You can see three lines of text in the body of the tab beginning with the ‘Recipes’ title, then ‘There are 3 Recipes’, a ‘New Recipe’ hyperlink, and finally the list of recipes. 
There are three levels of overriding. Hobo handles these by checking sequentially in three directories for the tags or tag definitions it will use to render a view template.
The first place Hobo looks to find the information it needs to render a view template corresponding to a particular model is the /views directory corresponding to that model. 
Note: Prior to Hobo 1.3, a view folder for each generated model was created.  This is no longer the case. In the figure below, the categories, countries, and recipes folders were created manually.
In this case, note that /views/recipes is empty.


The next place Hobo goes is the views/taglibs/application.dryml file. The last place Hobo goes is the views/taglibs/auto/rapid/pages.dryml file. 
You are going to put the recipe index tag definition in application.dryml causing Hobo to use level 2. So take the code above from pages.dryml beginning with 
<def tag="index-page" for="Recipe">
and paste it into /views/taglibs/application.dryml file. Paste it below the following code in views/taglibs/application.dryml file.
<include src="rapid" plugin="hobo"/>

<include src="taglibs/auto/rapid/cards"/>
<include src="taglibs/auto/rapid/pages"/>
<include src="taglibs/auto/rapid/forms"/>

<set-theme name="clean"/>
<def tag="index-page" for="Recipe">
. . . 

	The line in bold italics above is the first line from your copied code.


Note: As you learn Hobo you might get confused between tag definitions and tags. This is often the case because Hobo does not need you to specifically invoke the tags that are defined in the Rapid files (pages.dryml,forms.dryml etc…) or in the application.dryml file. If the tags have the default names “index”, “new”,” show”, or “edit”, then Hobo creates the template on the fly. You do not have to put tag code in a template yourself unless you do not want to use Hobo’s default template.
First, refresh your browser to confirm that the UI has not changed. Simply copying a tag definition from pages.dryml to application.dryml with no changes to the tag definition should not change the page rendering. It is a good idea to double check in case you copied something wrong so you won’t confuse a copy mistake with a coding mistake.
Let’s make a minor change to convince you that this is what is happening. Note that the line in bold italics below is what has changed.

<def tag="index-page" for="Recipe">
  <page merge title="#{ht 'recipe.index.title', :default=>[model.model_name.human(:count=>100)] }">
    <body: class="index-page recipe" param/>

    <content: param>
      <header param="content-header">
        <h2 param="heading">
          My Recipes
        </h2>

        <p param="count" if>
          <ht key="recipe.collection.count" count="&this.size">
            <count summary/>
          </ht>
        </p>
      </header>

      <section param="content-body">
        <a action="new" to="&model" param="new-link">
          <ht key="recipe.actions.new">New Recipe</ht>
        </a>

        <page-nav param="top-page-nav"/>

        <collection param/>

        <page-nav param="bottom-page-nav"/>


      </section>
    </content:>
  </page>
</def>
Now refresh your browser and you will see that Hobo has changed the template it generated dynamically:


Figure 98: Page view of "My Recipes" after modifying the <index-page> tag
You should see that the first line of the page has changed from “Recipes” to “My Recipes”.
Let us describe what happened. 
Step 1: Hobo looked for a template in the views/recipes/ directory called index.dryml. 
Step 2: Since views/recipes/index.dryml did not exist, Hobo next looked in views/taglib/application.dryml where it found the tag definition for the index page.
Step 3: Hobo used this tag definition to generate the contents of the “index” page.
5.	Change the index page(method 2). If you want to change the index page directly, you can create a new file in the views/recipes directory called index.dryml.
	We haven’t given you enough information for you to build your own index.dryml template using Hobo’s tag library yet.  We said above that Hobo will look there first for a page to render when the index action is invoked. 
So if you place an empty file here, you get a blank page rendered. Go ahead and create a file called index.dryml in the views/recipes directory. Confirm for yourself that you get a blank page.
Now let’s do something a little more useful. Add the single line of code below to the index.dryml file: 
<index-page/> 


Note: The Hobo tag syntax is just like you would expect from HTML or XML. The code <index-page/> is equivalent to <index-page></index-page>. Watch your placement of “/”. It was our most frequent error when we started with DRYML.
Now refresh your browser and you will see the same page rendered as in Step 4. What has happened is that Hobo has checked in the views/recipes directory for a file called index.dryml, found one and rendered it. When it encountered the <index-page/> tag, it first checked in index.dryml for a tag definition. Not finding one there, it checked in application.dryml where it found one to use in rendering the <index-page/> tag in index.dryml. If it had not found a tag definition in application.dryml, Hobo would have gone back to pages.dryml for the default <index-page> definition.
Note: You can put a tag definition in either a view template file or in application.dryml but Hobo will ignore tags in application.dryml. The application.dryml file is for tag definitions only. 
6.	Edit an individual record’s view in the index page. By now, you should have entered a couple of recipes. Be sure to do that if you have not.
In Table 1 above, we indicated that the <index-page> tag calls <card> tags to render individual records. We can demonstrate this process by changing a <card> tag. Go to the cards.dryml file in the rapid directory and copy the <card> definition for recipe cards into the application.dryml file below the <index-page> definition. Hobo will now use this version of the <card> tag when it uses the  <index-page>.

<def tag="card" for="Recipe">
	 <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a></h4>
    </header:>
    <body: param>
      <ht key="category.collection.count" count="&this.categories.size">
         <count:categories param/>
      </ht>
    </body:>
  </card>
</def>
Again, we will not explain the detailed syntax of this tag yet. Let’s just make a simple change (in bold italics below) to demonstrate how Hobo works:
<def tag="card" for="Recipe">
	 <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a>…test</h4>
    </header:>
    <body: param>
      <ht key="category.collection.count" count="&this.categories.size">
         <count:categories param/>
      </ht>
    </body:>
  </card>
</def>
Now refresh your browser. Click the ‘Recipes’ tab to invoke the index action using the <index-page> tag.

Figure 100: How a change to the <index-page> tag affects a collection
You see how each record displayed has been changed. You didn’t need to iterate through a loop. Iterating through all records in a collection is built in to Hobo’s tag processing. If you look back to Step 4 to see the <index-page> tag definition, you will see the following line:
<collection param/>
It is here that the <card> tag is called. The <collection> tag refers to a collection of records from a data model. 
Now click on one of the recipe name hyperlinks, which will invoke the <show-page> tag in pages.dryml. Since you haven’t changed this tag and since it does not use the <card> tag, you will NOT see ‘....test’ appended to recipe names as you do when Hobo lists recipes using the <index-page> tag.
To finish up this step, remove the text ‘....test’ to keep things looking nice. 
6.	Editing a form. To modify a form, you can do something similar to editing the <card> tag above. In this case, the relevant page tag is the <new-page> tag in pages.dryml. It calls the <form> tag. You can see that in the forms.dryml file. 
7.	Editing navigation tabs and their order. As you have seen, Hobo provides a predefined tab-based user interface. By default, it arranges the tabs alphabetically by model. This is probably not what you want. You more than likely want to set up an order that makes sense for your application.
This is readily done. Find the <main-nav> tag definition in the pages.dryml file and copy it into application.dryml right after the <app-name> tag definition.
<def tag="main-nav">
  <navigation class="main-nav" merge-attrs param="default">
    <nav-item href="#{base_url}/">Home</nav-item>
    <nav-item with="&Category"><ht key="category.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
    <nav-item with="&Country"><ht key="country.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
    <nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
  </navigation>
</def>
Now let’s change the order of the tabs in your UI. Change the order of your tabs by moving the Recipes tab up to the position noted below in bold italics.
<def tag="main-nav">
  <navigation class="main-nav" merge-attrs param="default">
    <nav-item href="#{base_url}/">Home</nav-item>
	   <nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
    <nav-item with="&Category"><ht key="category.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
    <nav-item with="&Country"><ht key="country.nav_item" count="100"><model-name-human count="100"/></ht></nav-item> 
  </navigation>
</def>

Now refresh your browser and you will see the new tab order:


8.	Editing an application name. If you want to change the name of the application that appears on all the UI web pages, you can do this easily also. The config.hobo.app_name key is found in the config/application.rb file and can be edited to change the application name.  Make the following change, then restart the application, and then refresh your browser:
config.hobo.app_name = "Four Tables, No Waiting"	


9.  Summary. The Hobo Rapid generator creates tag definitions and places them in the files of the Rapid directory. The programmer overrides, redefines, and defines new tags in application.dryml. These definitions are available throughout the application. So far, you have just learned how to override tags.
There are no tag calls in application.dryml except within a tag definition because application.dryml is NOT a template file (see it as a library file). The programmer invokes--that is--calls tags in template files placed in the view/<model_name> directories. 
The programmer may also override, redefine, or define a new tag within a template, but this modification is local (e.g., only available within that template).

Note: A new feature of Hobo 1.3 is that application tag definitions can be organized into multiple dryml files as long as they reside in the app/views/application directory.

So instead of having one large application.dryml file, you can organize your application specific tag definitions into multiple files and place them in the app/views/application directory.
Tutorial 10 – DRYML I:  A First Look at DRYML

You will be introduced to the concept of a user-defined tag, called a DRYML tag. The tutorial shows you how to make minor changes to the home page template by defining DRYML tags. You will also learn how to parameterize tags with the DRYML parameter attribute, param.
Note: Be sure not to confuse the DRYML param with the Rails params object. 
Topics
Define a DRYML tag in the front/index.dryml template
Call the DRYML tag in the front/index.dryml template
Add a parameter to the DRYML tag
Add an attribute to the DRYML tag
Tutorial Application: four_table
Steps
1.	Define a tag.  Open up the views/front/index.dryml file of the four_table application. This is Hobo’s home page.
At the top of the file enter the following code. The <def> tag below is Hobo’s DRYML tag for defining a custom tag. The code below defines a <messages> tag.
<def tag="messages">
	<br/><br/>
	<ul>
		<li >Message 1</li>
		<li >Message 2</li>
		<li >Message 3</li>
	</ul>
</def>
The entire markup between the <def> tags is standard HTML. When called, this <messages> tag will emit a three-line list.
2.	Call the tag. Go to the line that reads:
<h3>Congratulations! Your Hobo Rails App is up and running</h3>
Add a line after this one so that it reads:
<h3>Congratulations! Your Hobo Rails App is up and running</h3>
<messages/>

Note: The correct syntax is to place the forward slash after the tag name when you use the tag as a single tag rather than in the form of an opening and closing tag with no content in between.


Then refresh your browser:



One of the things that is different from Tutorial 1, is that you are now working both with a DRYML tag definition and with a DRYML tag. In the previous tutorial, you edited the tag definitions but you did not invoke a tag such as <index-page> explicitly.
Hobo took care of invoking the tags for you on-the-fly. Since Hobo’s Rapid component knows what the basic structure of a data driven web page is, it does not require you to code the template explicitly except when you want something different than the Hobo default.
In this tutorial you will be defining new tags unknown to Hobo, so you of course must invoke them explicitly.
3.	Parameterize the tag. Change the following code in the <messages> tag definition from:
		<li >Message 1</li>
		<li >Message 2</li>
		<li >Message 3</li>
	to:
		<li param="msg1">Message 1</li>
		<li param="msg2">Message 2</li>
		<li param="msg3">Message 3</li>
You have now created three parameters, which can be invoked in the following way:
<msg1:>message text</msg1:> 
<msg1:> is called a parameter tag. 
Note: The colon (:) suffix indicates that the tag is a defined parameter tag. Later you will learn that some parameter tags are defined for you in the Rapid library.
4.	Use a parameter. Let’s invoke the <messages> tag but change the third message by addressing the <msg3:> parameter tag.
<h3>Congratulations! Your Hobo Rails App is up and running</h3>
<messages>
	<msg3:>This is the third message passed as a parameter.</msg3>
</messages>
The first two lines will remain the same while the third changes due to the use of the <msg3:> parameter tag. You have used a tag to pass data from the <msg3:> parameter tag into the <messages> tag.




5. Use some more parameters. Change the other two message lines likewise to:
<messages>
	<msg1:>This is the first message called as a parameter</msg1>
	<msg2:>This is the second message called as a parameter.</msg2>
	<msg3:>This is the third message called as a parameter.</msg3>
</messages>
and you should see:


6. Reverse the order of the parameter call. Now try the following code.
<messages>
	<msg2:>This is the second message.</msg2:>
	<msg1:>This is the first message.</msg1:>
	<msg3:>This is the third message.</msg3:>
<messages>
You will see that this edit will not change the order of the list because the order is defined by the tag definition not by its call. The tag calls the messages in the order set in the tag definition, namely <msg1:>, then <msg2:> and then <msg3:>.
7.	Create an html-like tag using param = ”default”. In the preceding steps, you learned how to reach into a tag with three parameter tags and change the default message text of the defined <messages> tag. Next you will emulate a regular HTML formatting tag using the param=”default” attribute.
Note: We have referred to an attribute above rather than a parameter because a change will be made by setting param to a value rather than by using a parameter tag.
Go back to the top of the views/front/index.dryml file and enter the following code after the first <def> . . . </def> tags. 
<def tag="bd-it">
	<br/>
	<b><i><span param>stuff</span></i></b>
</def>
Here we have redefined the HTML <span> tag to format the tag content with bold AND italic formatting. Since the <span> tag is now parameterized, you can now replace the ‘stuff’ continent with something you might want to format.
Call the <bd-it> tag right after the closing </messages> tag without using the <span:> parameter. This will demonstrate that the tag will just emit the formatted default word stuff.
<messages>
	<msg2:>This is the second message.</msg2:>
	<msg1:>This is the first message.</msg1:>
	<msg3:>This is the third message.</msg3:>
</messages>
<bd-it/>


If you use the <span:> parameter tag, you will format your content. 
<bd-it/>	
<bd-it><span:>More stuff</span:></bd-it>

	
But the second line is a kind of clumsy looking way to get: More stuff. Instead, change your <def> code to:
<def tag="bd-it">
<br/>
<b><i><span param="default">stuff</span></i></b>
</def>
The param=”default” text is saying is that the <span:> parameter is automatically assumed when you call the <bd-it> tag. You do not have to explicitly call it. Now change your call to:
<bd-it/>	
<bd-it>More Stuff</bd-it>

So now you have created a DRYML tag that looks just like an HTML tag. 
Note: Once you change the <span:> parameter to the default parameter, Hobo will ignore explicit uses of it and only emit the default content if you call it explicitly. Once you use the default parameter attribute you are committed to the more compact notation. There can only be one “default” parameter in a tag definition.
The entire /views/front/index.dryml contents at the end of this tutorial is as follows:
<def tag="messages">
	<br/><br/>
	<ul>
		<li param="msg1">Message 1</li>
		<li param="msg2">Message 2</li>
		<li param="msg3">Message 3</li>
	</ul>
</def>

<def tag="bd-it">
    <br/>
    <b><i><span param="default">stuff</span></i></b>
</def>

<page title="Home">
	<body: class="front-page"/>
   <content:>
    <header class="content-header">
      <h1>Welcome to <app-name/></h1>
      <section class="welcome-message">
        <h3>Congratulations! Your Hobo Rails App is up and running</h3>
         <messages>
          <msg2:>This is the seond message.</msg2>
          <msg1:>This is the first messsage.</msg1>
          <msg3:>This is the third message passed as a parameter.</msg3>
         </messages>
         <bd-it/>
         <bd-it>More stuff</bd-it>
	  </section>
    </header>
    <section class="content-body">
    </section>
  </content:>
</page>

Tutorial 11 – DRYML II: Creating Tags from Tags

You will go to the next step in your understanding of DRYML. You will learn how to define tags from other tags. Specifically, you will learn how to create new tags that inherit parameters from the tags they are based on.
Tutorial Application: four_table
Topics
Defining tags from tags using the merge tag
Defining tags from tags using the extend tag
Replacing tag parameters (not tag content)
1.	Define a tag based on another tag: Method 1. In Tutorial 10, you learned how to define a tag called <messages> that output three lines of HTML. Now you will define a new tag based on <messages> called <more-messages>. Place the following code below the <messages> tag definition. (The order of tag definitions does not matter. This was just a recommendation for neatness.) 
<def tag="more-messages">
	<messages merge>
		<msg2: param>Message 2 Changed</msg2:>
	</messages>
</def>
What you have done here is to edit the <msg2:> parameter tag of the <messages> tag so that it has different default content. By using the merge attribute, you have told Hobo to use everything from the <messages> tag except for the change. Now let’s invoke this tag. Place the following code below your last code from the previous tutorial.
<more-messages/>
		

Refresh your browser to see the change the below. 


Note: Later in this Chapter you will also learn how to add attributes to tags in addition to parameters. Merge means merge parameters AND attributes.
Remember that the text, ‘Message 1’ and ‘Message 3’ is the default text from the <messages> tag.
2. Define a tag based on another tag: Method 2. In the last example, you learned how to define a new tag based on an old tag. The new tag is defined with a new name, <more-messages>. You cannot use the merge method to define a tag from a tag without changing the name.
Go ahead and change <more-messages> to <messages> to convince yourself that you will get an error.
However, Hobo does have a way of preserving tag names while creating tags from tags. It is called extending a tag. It works basically the same way as merging tags, except it uses the <extend> tag instead of the <def> tag to define the new tag.
Now let’s create an extended tag. We will begin by creating a new tag called <messagex> and then extend it using the same name.
<def tag="messagex">
<br/> <br/>
	<ul>
		<li param="msg1">Message 1</li>
		<li param="msg2">Message 2</li>
		<li param="msg3">Message 3</li>
	</ul>
</def>

<extend tag="messagex">
	<old-messagex merge>
		<msg2: param>Message 2 Extended</msg2:>
	</old-messagex>
</extend>	
Instead of placing the code above in front\.index.dryml, you need to put it in views/taglibs/application.dryml. Recall this will make the tag definition available throughout your application. But there is another reason for putting it here. You cannot use the <extend> tag in a view template, you can only use it within application.dryml.  
Note: To extend this tag and have the original one still available, you can use the Hobo “alias-of” parameter:

     <def tag="new-messagex” alias-of="messagex"/>
 
And then extend “new-messagex” with the functionality you need.
 




Before trying this out, you should delete (or comment out) the code for  <more-messages> so you will not get confused. 
In the code example above, we created a new tag <messagex> just like the old <messages> tag. We then extended it so that it would look just like the 
<more-messages> tag from Step 1.
Now call the <messagex> tag in front/index.dryml to confirm that it yields output like the <more-messages> tag.
	<messagex/>
You should see the following rendering:



3.  Edit the merged tag in more ways. Let’s modify our <more-messages> tag of Step 1,  which is defined in front/index.dryml. Remove or comment out the <messagex> tag so you won’t get confused.
We are going to show you now that DRYML can do lots of things within the same tag definition with ease. First we will add a new parameter tag before the merge line to demonstrate that you do not have to have the merge line right after your <def> line. 
Next we will show you that you can put both parameter tags and non-parameter HTML after merge markup. Let’s do this in two steps.
Edit your <more-messages> tag to look like the following:
<def tag="more-messages">
	<br/><br/>
	<li param="msg0">Message 0</li>
	<messages merge>
		<msg2: param>Message 2 changed in merge.</msg2:>
	</messages>
</def> 
Make sure you call your <more-messages> tag and refresh your browser.

Figure 115: Page view of the <more-messages> tag usage
Let’s demonstrate that <msg0:> is a real parameter tag with the following code where you call the <more-messages> tag.
<more-messages>
	<msg0:> Message 0 changed with parameter tag.</msg0:>
</more-messages> 


We have chosen this exercise to remind you that you have changed the text in two ways. 
You changed the third block of messages by changing the tag definition within a merge. 
You changed the second block (Message 0) by calling a parameter tag within a tag.
Now let’s edit the <more-messages> definition after the merge is closed with </messages>. We have added two lines of DRYML. The first is a parameter tag, <msg4:>. The second is pure HTML without any parameterization.
<def tag="more-messages">
	<li param="msg0">Message 0</li>
	<messages merge>
		<msg2: param>Message 2 changed in merge.</msg2:>
	</messages>
	<li param="msg4">Message 4</li>
	<li>No Parameter Here</li>
</def>



Now let’s invoke <more-messages> and change the default content of the <msg4:> parameter tag.
<more-messages>
	<msg0:> Message 0 changed with parameter tag.</msg0:>
	<msg4:> Message 4 has changed with parameter tag too.</msg4:>
</more-messages> 

Figure 117: More parameter magic
Tutorial 12 – Rapid, DRYML and Record Collections

You will learn how to create a new index page that will replace the default index page that Hobo generates on the fly, and learn how to display data on this index page that is related through a many-to-many relationship. 
Tutorial Application: four_table
Topics
Learn how to create your own index template in a view/model directory.
Work on using the application.dryml directory to override auto-generated tags.
Learn about the Rapid collection tag.
Get introduced to the Rapid <a> tag.
Learn how to use the <repeat>, <if> and <else> tags.
Steps
1.	Click the model(Recipes) tab.  Load your browser again with the Four Table application we ended up with in Tutorial 11.  Click the Recipes tag to remind yourself how Hobo automatically creates a list of your recipes. This is different than the Home tab you were working with in Tutorial 11. When you click the Recipes tab, Hobo goes through the three-step check you learned about in Tutorial 1 to locate a template or template definition.
Since we have already moved the <index-page> tag for recipes to \taglibs\application.dryml, Hobo will obtain its tag definition for generation of a view template here. 
Note: You learned back in Tutorial 1 that each of Hobo’s tabs, named with the plural of the model name by default, invoke the index action and list the records in the model.
Since there is not a file called views\recipes\index.dryml, Hobo will create its own template on the fly from the <index-page> tag definition in \taglibs\application.dryml. (We created a views\recipes\index.dryml in Step 1 but we asked you to remove it. If you did not do that, do it now so you do not have any conflicts as we proceed).


2. Create a new template file. Now, create the new file called index.dryml in the views/recipes folder. This is the folder automatically created when you did the hobo g resource generation in Tutorial 1. This file is called a DRYML template. 
Note: We have used the word template quite frequently now but it is still worth reminding you not to be confused by it. It is a file used to render a specific web page, not a framework for creating one as the word may imply.
Now that this file exists, Hobo will use it when it finds it so let’s put a tag in it to make sure Hobo has a template to render.
<index-page/>

Refresh your browser. It should look just like it did in Step 1. This is because <index-page> is exactly the tag that Hobo is calling to display this page. Instead of doing it automatically, you have added one step. Before, since there was no file in views\recipes, Hobo created its own version of the page using this tag. Now it looks in the folder, finds the index.dryml file and does what it would have done anyways, namely use the <index-page> tag.
3.	Work with the <collection> tag. From here on in this tutorial we will be moving back and forth between the template views/recipes/index.dryml and the <index-page> definition in views\taglibs\application.dryml. Keep this in mind so you do not get confused.
Go to the application.dryml and find the <index-page> tag definition for the Recipe model. Note the <collection> tag in italics and bold below.
<def tag="index-page" for="Recipe">
  <page merge title="#{ht 'recipe.index.title', :default=>[model.model_name.human(:count=>100)] }">
    <body: class="index-page recipe" param/>

    <content: param>
      <header param="content-header">
        <h2 param="heading">
          My Recipes
        </h2>

        <p param="count" if>
          <ht key="recipe.collection.count" count="&this.size">
            <count summary/>
          </ht>
        </p>
      </header>

      <section param="content-body">
        <a action="new" to="&model" param="new-link">
          <ht key="recipe.actions.new">New Recipe</ht>
        </a>

        <page-nav param="top-page-nav"/>

        <collection param/>

        <page-nav param="bottom-page-nav"/>

      </section>
    </content:>
  </page>
</def>
To remind yourself that this is the tag responsible for listing the recipe records, delete it and refresh your browser. You will still see a template rendered but without the list of recipes. OK, now let’s put back the <collection> tag so that your file still reads like the above code.
Now let’s move back to the  views/recipes/index.dryml template and explicitly call the collection tag. Change your code to read like this:
<index-page>
	<collection:/>
</index-page>
Your Recipes template should still look exactly like the one in Step 1.
You are now calling the <collection> tag. Notice the trailing colon (:). This colon is here because you are calling a parameter tag. You can see above that the <collection> tag was parameterized in application.dryml by adding the param attribute to the declaration. You might be wondering where the <collection> tag is defined. 
Actually, it is a member of the Rapid library of tags that we have mentioned. As we go through these tutorials, we will point out where tags, and in particular parameters tags come from. Here is a list of tag situations you will encounter:
HTML tags which are often parameterized
Rapid library tags which are often parameterized
Rapid parameter tags, not defined in your app
User-defined tags which are often parameterized
Rapid auto-generated tags which are not usually parameterized
As we go forward, you will gradually learn how the auto-generated tags are built up out of Rapid library tags.
OK, let’s learn a little more about the <collection> tag. The <collection> tag does the following:
Repeats the body (stuff between the tags) of the tag inside a <ul> list with one item for each object in the collection of records.
If there is no content for the body, it renders a <card> inside the <li> tag nested within the <ul> tags.
The following code corresponds to "no body":
<collection:/>
and this code corresponds to an empty or blank body:
<collection:></collection:>
You have already seen what the former will do, namely list your records in a bolded hyperlinked format, which it derives from the <card> tag. Now try the latter. You will get the blank repeated as many times as there are recipe records, that is, nothing.

Figure 120: page view of using a blank "<collection:></collection:>" tag
Now try the following code.
<collection:>Hello!</collection:>
Since there is a body, the ‘Hello!’ will be repeated and the <card> will no longer be called.


There are three records in our Recipes table so ‘Hello!’ is repeated three times. If you examine your page a little more in detail by hovering your mouse over the ‘Hello’s’, you will see that each is linked to different records and has a different route associated with it.
Now let’s get some content displayed. We are going to use Rapid’s <a> tag, which is similar to the HTML <a> tag but has been redefined. The <a> tag is extended in Rapid to automatically provide a hyperlink to the route to show a particular record of the model. Let’s try this out with the following code.
<collection:><a/></collection:>


If you mouse over or click on one of the links you will discover a route like this
http://localhost:3000/recipes/2-omelette
The <a> link has created this route, which is the route for a show action.
Let’s do a comparison with the <card> tag that Hobo would call if you were not overriding it. Here is the <card> tag definition.
<def tag="card" for="Recipe">
  <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a></h4>
    </header:>
    <body: param>
      <ht key="category.collection.count" count="&this.categories.size">
         <count:categories param/>
      </ht>
    </body:>
  </card>
</def>
The <card> tag uses an <h4> heading tag which bolds and applies a larger font according to Hobo’s CSS files. It also uses the <a> tag with a body provided by the <name> tag, which renders the field that Hobo figures out automatically to be the most likely field you want to display. The <name> tag will pick out field names such as title, for example, which is the name of the field in our Recipe model.
If you wish to explicitly display a different field other than the one that Hobo provides by default, you can use the Rapid <view> tag. The syntax for this tag is different than you have encountered so far. Right now we are just going to give you a simplified description of the syntax and postpone a more detailed discussion for a later chapter:
<index-page>
	<collection:><view:title/></collection:>
</index-page>

Note: You will observe the trailing colon (:) with the <view> tag. This is an entirely different use of colon (:) than you have seen with parameter tags. Here the colon (:) is telling Hobo to figure out what model you are referring to and display the field from that particular model. This called implicit context, Hobo’s ability to know at all times what model you are working with in a particular view. In a later chapter you will learn how to change the implicit context. 
If you refresh your browser, you will note that the recipes displayed are not clickable. That is because of the way that the <collection> tag works. Remember that when you add a body to the tag, it no longer uses the <card> tag so you are only asking Hobo to display the title field, not create a hyperlink. That is easily remedied by doing the following.
<index-page>
	<collection:><a><view:title/></a></collection:>
</index-page>
Refresh your browser and see what you’ve got now:


This looks pretty close to the default version of the <collection> tag. With the following use of the <h4> HTML tag, you can almost bring back the default appearance. 
<index-page>
	<collection:><h4><a><view:title/></a></h4></collection:>
</index-page>
The only difference is the background provided to the record that you see above in Step 1 and the lack of the category count. The background is Hobo’s default CSS formatting which in this case is associated with the <card> tag and since you are not using it, the formatting does not appear. Understanding how Hobo utilizes CSS files is covered in a later Chapter.

	
4.	Display the associated record collection. Now that you see how to display collections of records, let’s go a bit deeper. Our Recipe model has a many-to-many relationship with the Category Model. It would be nice to see this relationship without having to click through to an individual recipe.
You can do this in several different ways. First we will do it in views/recipes/index.dryml template. Then we will try it in a <card> definition in application.dryml. Try out the following code.
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<view:categories/>
</collection:>
</index-page>


What we did here with the <view> tag was to tell Hobo to change its implicit context to the Categories model. The colon(:) is what did the trick and, of course, all the machinery inside Hobo which keeps it informed about the relationship between models that we set up.
Now we are going to do this slightly differently by using another Rapid library tag called <repeat>.
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<repeat:categories><a/></repeat>
</collection:>
</index-page>
The repeat tag with the colon (:) tells Hobo to loop through the records in the implicit context and to display what is in the body of the tag, namely <a/>. Try it and you will see the categories as hyperlinks but all run together. Fortunately, <repeat> has a join attribute to put in some additional character punctuation. Try this.
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<repeat:categories join=", "><a/></repeat>
	</collection:>
</index-page>
Now you get this:


If you don’t want to have your categories linked you could do this,
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<repeat:categories join=", "><name/></repeat>
</collection:>
</index-page>
or you could do this.
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<repeat:categories join=", "><view:name/></repeat>
</collection:>
</index-page>

Note: The <name/> tag and the name attribute in <view:name/> are not the same. In the former, Hobo looks at the Category model to find a candidate field to output from the <name> tag. We made it easy for Hobo since there is a field called name, which it picks, and displays. In the second example, we explicitly tell Hobo to display the name field of the categories model.  
Now we are going to try the same thing within a tag definition so put your template, views/recipes/index.dryml back to the following:
<index-page/>
Now go into application.dryml and find the recipe <card> definition. It should be there from Tutorial 1. If it is not there copy it from views\taglibs\auto\rapid\cards.dryml. 
Edit it to look like the below. Not the added code in italics and bold. We have added the same code we put in the template above. Since the code is now in the <card> tag definition, we should get all the formatting set up pre-defined in Hobo.
<def tag="card" for="Recipe">
  <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a></h4>
    </header:>
    <body: param>
      <ht key="category.collection.count" count="&this.categories.size">
         <count:categories param/>
      </ht>
		 <br/><view:categories/>
    </body:>
  </card>
</def>
Refresh your browser.


Now you have succeeded in editing the recipe <card> tag to drill down to assigned categories for your recipes.
5.	Use the <if> and <else> tags. We are going to show you one more version way of displaying the recipe records and the categories assigned to them. Notice that when there are no categories assigned, the <view> tag puts out the text, ‘none’. Let’s try to make this look a little nicer.
The <if> tag checks for null records in a record collection and outputs the body of the tag when the record exists. You use the <else> tag for the case when the record does not exist. Try this.
<def tag="card" for="Recipe">
  <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a></h4>
    </header:>
    <body: param>
      
	  <if:categories><view/></if>
	  <else>There are no assigned categories yet.</else>

    </body:>
  </card>
</def>


In the examples above, we used the trailing colon (:) syntax to tell Hobo what model context we wanted in the <view> or <repeat> tags. In this example, we take care of changing the context with the <if> tag so there is no need to do it again. In fact, if we introduced this redundancy, as in the code below, we would get an error:
<!--THIS CODE PRODUCES AN ERROR-->
<if:categories><view:categories/></if>
<else>There are no assigned categories yet.</else>
Tutorial 13 – Listing Data in Table Form

You will learn how to display your data in a sortable, searchable table. The search will actually extend beyond the table entries to all the fields of each record. The sort and search code is an advanced topic that is provided here for completeness.
Tutorial Application: four_table
Topics
Display model data in table form.
Use the replace attribute to change the content of a parameter tag.
Display associated record counts in the table
Add search and sort to the table.
Steps
1.	Display model in table form. In the following code, we use another built in feature of Hobo’s parameter tags, the ability to replace what the parameter does with new tag code. The code below should be entered into your views/recipes/index.dryml file. Delete or comment out the <index-page> tag from Tutorial 12. 
<index-page >
	<collection: replace>
		<div>
	      <table-plus fields="title,country"/>
	    </div>
	  </collection:>
</index-page>
Refresh your browser to see your new table:


The fields attribute of the <table-plus> tag lets you specify a list of fields that will become the columns of a table. 
So essentially one line of code sets up a pretty good table for you in Hobo.
2.	Make your data hyperlinked. You might have noticed that the country names are clickable but the titles are not. Hobo provides a way to do this using the this keyword. This refers to the object currently in scope.
 Note: The  this keyword actually has a far deeper meaning that will be explored in more depth later. For now we will just outline how to use it.
Make the following change to your code and refresh your browser.
<index-page >
	<collection: replace>
		<div>
	      <table-plus fields="this, country"/>
	    </div>
	  </collection:>
</index-page>
Now your recipes are hyperlinked to the show route that displays individual recipe records.
3.	Show associated record counts. It would be nice to display how many associated category records there are. Again, since Hobo knows all about the relationships between records, you know it can figure this out. 
However, if you are familiar with database programming, you know queries have to be done to compute this value. The Hobo framework does not require you to do this extra work. You already know what you want--so you should be able to declare it. Here is how you do it:
<index-page >
	<collection: replace>
		<div>
			<table-plus fields="this, categories.count, country"/>
	    </div>
	  </collection:>
</index-page>


That was pretty straightforward. Before we refresh our browser again, let’s also display the actual categories in addition to the count. 
Again, with other frameworks this would be a bit more complicated, but Hobo makes this easy. In the previous tutorial, you learned a few ways to display the categories associated with an individual recipe, the simplest of which was the <view> tag. 
Here it is even easier--just add categories to the fields attribute:
<index-page >
	<collection: replace>
		<div>
			<table-plus fields="this, categories.count, categories, country"/>
	    </div>
	  </collection:>
</index-page>


4. Add search and sort capability to the table. Until now we have worked with controllers relatively little. If you think about it a bit, you will quickly realize that to add search and sort, we will have to make a change in the recipe controller. You can understand this by realizing that we want our application to respond to a click with two specific actions: one is a sort and the other is a search.
Go to your controllers/recipes_controller.rb file.
Note: This is actually an advanced topic since we are adding some Ruby code. You will learn more about the meaning of all the unfamiliar syntax in subsequent chapters. But for now, let’s polish off this table functionality.

To get the search feature working, we need to update the controller side. Add an index method to app/controllers/recipes_controller.rb like this:

def index
 hobo_index Recipe.apply_scopes(:search => [params[:search],:title,:body], :joins=>:country, :order_by  => parse_sort_param(:title, :country, :count))
end

Note: The “apply scopes” for the search facility can only contain fields within the recipe model—not related models at this time, but the “order  by” can.

Clicking on the Country label twice will trigger sorting in descending alphabetical order:

	
Now search/filter by “French” in the title or body:


Tutorial 14 – Working with the Show Page Tag

In this tutorial you will learn the options for displaying details about single records. In the last two tutorials, we focused on displaying lists of records. Hobo has a specific auto-generated tag for handling the display of individual records and a route and view template associated with it. 
Tutorial Application: four_table
Topics
Edit the <show-page> tag.
Create and work with the show.dryml template.
Work with <field-list>, <fieldname-label> and <view> tags. 
Steps
1.	Copy the <show-page> tag. Go to pages.dryml and copy the <show-page> tag for Recipes to application.dryml. 
<def tag="show-page" for="Recipe">
  <page merge title="#{ht 'recipe.show.title', :default=>['Recipe'] }">

    <body: class="show-page recipe" param/>

    <content: param>
          <header param="content-header">
            <a:country param="parent-link">&laquo; <ht key="recipe.actions.back_to_parent" parent="Country" name="&this">Back to <name/></ht></a:country>
            <h2 param="heading">
              <ht key="recipe.show.heading" name="&this.respond_to?(:name) ? this.name : ''">
                <name/>
              </ht>
            </h2>

            <record-flags fields="" param/>

            <a action="edit" if="&can_edit?" param="edit-link">
              <ht key="recipe.actions.edit" name="&this.respond_to?(:name) ? this.name : ''">
                Edit Recipe
              </ht>
            </a>
          </header>

          <section param="content-body">
            <view:body param="description"/>
            <field-list fields="country" param/>
            <section param="collection-section">
              <h3 param="collection-heading">
                <ht key="category.collection.heading" count="&this.categories.count" >
                  <human-collection-name collection="categories" your/>
                </ht>
              </h3>

              <collection:categories param/>
            </section>
          </section>
    </content:>

  </page>
</def>
We are going to focus in on three display components of this tag, noted in bold italics above, to help you understand how to change the display of individual records.  (Add the ‘<field-list fields="country" param/>’ if it is not present.)
Click on the Recipes tab and then click on an individual recipe.


Now comment out the three lines above in bold italics using <!-- ... -->, and confirm that you have removed the display of the individual recipe record.
2.	Create the show.dryml template. Go to views/recipes and create a new template file called show.dryml. When a user invokes the show action by requesting the display of a single record, this is the first of the three places Hobo looks to determine how to display the record. 
As with the index action, its next two stops are the application.dryml file to look for application wide tag definitions and finally in pages.dryml for the auto-generated tag definitions which are based on model and controller code.
Place the following code in show.dryml to invoke your show page. 
<show-page/>
Refresh your browser and you should see the following:


3.	Use the <field-list> tag. The <field-list> tag allows you to display rows of data in two columns. The first column contains the name of the field and the second column contains the contents of that field. The <field-list> tag has been parameterized in the <show-page> tag so we need to invoke it with a trailing colon (:). 
Remove the comments around the <field-list> tag in application.dryml and try the following in show.dryml.
<show-page>
	<field-list: fields = "body, country"/>
</show-page>
Here you are using the attribute  fields to declare which fields in your model you wish to display.


Hobo can even reach into the associated table and display the categories using <field-list>. Try this.
<show-page>
	<field-list: fields = "body, country, categories"/>
</show-page>
You can remove the collection heading since you no longer need it by observing that the <show-page> tag has a parameterized <h3> tag renamed as the <collection-heading:> parameter tag. You will see the following code in the <show-page> definition.
<h3 param="collection-heading">Categories</h3>
Now go into your show.dryml file and replace the default contents of the tag with nothing. 
<show-page>
	<field-list: fields = "body, country, categories"/>
	<collection-heading:></collection-heading:>
</show-page>

Now you should have the following after refreshing your browser.


4. Changing the <field-list> labels. We can now see that the <field-list> tag does a nice job of formatting the display of the fields of a record. The default display pictured in Step 1 uses a combination of the <view> and <field-list> tags. However the <view> tag does not automatically provide a label like the <field-list> tag. We will cover this further in Step 5. Now let’s learn how to change the labels.
Try the following code to change the body label to ‘Recipe’.
<show-page>
 <collection-heading:></collection-heading:>
   <field-list: fields = "body, country, categories"> 
    <body-label:>Recipe</body-label:>  
   </field-list>
<show-page>


There are a few new things going on here that you have not seen before.
The <body-label:> tag is a parameter tag defined in the Rapid Library. 
The <body-label:> tag is a user customized Rapid library tag derived from the generic <fieldname-label> tag.
The <body-label:> tag is nested within the <field-list> tag.
Let’s go through these points one at a time.
Rapid Parameter Tag. This the tag is used with a trailing colon (:), meaning that <body-label:> is a parameter tag. However, it is not defined anywhere within either your code or the auto-generated code. (You will see user-customized tags again with pseudo tags in the next tutorial.)
If you have done any coding besides this tutorial, you have probably run into the error “You cannot mix parameter and non-parameter tags”.
If there were not a Rapid parameter tag to use here and you tried to use a regular Rapid tag, you would get an error. Try deleting the colon (:) from <body-label:> to confirm this.
User-customized tags. The tag name is dynamic depending on what field in the <field-list> is being addressed. For example, to change the label of the country field, you would use the <country-label> tag.
Tag nesting. The feature that you see here is the ability to nest tags in order to pass data. Here you are passing the content of the tag to the label variable of the <field-list> tag.
Let’s go one step further and re-label the other two fields displayed on our page. You can just nest each <fieldname-label> tag after the other within <field-list> and Hobo will pass the content into the <field-list> tag.
You might be noticing that categories is not a field at all; it is a collection. That is not a problem for Hobo. Hobo can address the label using the <categories-label> just as if it was a field: 
<show-page>
   <collection-heading:></collection-heading:>
	<field-list: fields = "body, country, categories">
		<body-label:>Recipe</body-label:>
		<country-label:>Origin</country-label:>
		<categories-label:>Flavors</categories-label:>
	</field-list>
<show-page>
Refresh your browser and try this out.


5. Using the <view> tag to display a record. There is still another way to work with the fields of an individual record and its associated records using the <view> tag.
Let’s make a tag from the <show-page> tag within application.dryml. Recall that you can use the merge attribute within a template although you can’t use the <extend> tag in a template, only in application.dryml.
Let’s try out the following code in application.dryml. 
<def tag="show-page-new">
	<show-page merge>
		<content-body:>
			<h2>Title:</h2>
			<view:title/><br/>
			<h2>Recipe:</h2>
			<view:body/>
			<h2>Categories:</h2>
			<view:categories/>
			<h2>Country:</h2>
			<view:country/>
		</content-body:>
	</show-page>
</def>
<show-page-new/>
In the above code, we are using the parameter tag <content-body:> defined from a parameterized <section> tag in the <show-page> tag:
<section param="content-body">
By placing new HTML and Rapid library tags within the <content-body:> tags, we are changing the default content defined in the <show-page> tag to the new content and preserving everything else in the <show-page> tag. We are not only preserving the content but also the formatting. Hobo has predefined CSS formatting as you probably have gathered that correspond to the Rapid tags. 
If, for example, we had used the replace attribute in the <content-body:> tag like this…
<content-body: replace>
..we would have removed Hobo’s built-in formatting. 
Remove the last code in show.dryml  and put <show-page-new/> at the top.
Refresh your browser without using the replace attribute and then try it with the attribute to see confirm that the formatting will be removed.


Here is what happens when you add the replace attribute. 





Now take out the replace attribute before proceeding.
6.	Summary. You have now learned to create a new template called show.dryml in the views/recipes directory that is used whenever there is an action to display an individual recipe record. Before you created this file, Hobo was constructing the template on the fly from the auto-generated <show-page> tag in pages.dryml.

Tutorial 15 – New and Edit Pages with The Form Tag	

In this tutorial you will be introduced to the <new-page> and <edit-page> auto-generated tags. Both of these tags utilize the Rapid <form> tag as their basic building block. You will learn how the <form> tag utilizes both the <field-list> and <input> tags. You will also learn about the concept of a “polymorphic” tag, which renders form components based on field type and model structure.
Tutorial Application: four_table
Topics
The <new-page> and <edit-page> tags
The <field-list> tag
The <input-tag>
Steps
1.	Get introduced to the <new-page> and <edit-page> tags. Go into pages.dryml and take a look at the code for both of these tags. Here is the  <new-page> definition:
<def tag="new-page" for="Recipe">
  <page merge title="#{ht 'recipe.new.title', :default=>[' New Recipe'] }">
    <body: class="new-page recipe" param/>

    <content: param>
      <section param="content-header">
        <h2 param="heading">
          <ht key="recipe.new.heading">
            New Recipe
          </ht>
        </h2>
      </section>

      <section param="content-body">
        <form param>
          <submit: label="#{ht 'recipe.actions.create', :default=>['Create Recipe']}"/>
        </form>
      </section>
    </content:>
  </page>
</def>
And here is the <edit-page> definition:
<def tag="edit-page" for="Recipe">
  <page merge title="#{ht 'recipe.edit.title', :default=>['Edit Recipe'] }">

    <body: class="edit-page recipe" param/>

    <content:>
      <section param="content-header">
        <h2 param="heading">
          <ht key="recipe.edit.heading" name="&this.respond_to?(:name) ? this.name : ''">
            Edit Recipe
          </ht>
        </h2>
        <delete-button label="#{ht 'recipe.actions.delete', :default=>['Remove This Recipe']}" param/>
      </section>

      <section param="content-body">
        <form param/>
      </section>
    </content:>

  </page>
</def>

The components that we are going to focus on are shown in bold italics. Let’s also take a look at the <form> tag that both of these tags call.
<def tag="form" for="Recipe">
  <form merge param="default">
    <error-messages param/>	
    <field-list fields="title, body, categories, category_assignments, country" param/>
    <div param="actions">
      <submit label="Save" param/><or-cancel param="cancel"/>
    </div>
  </form>
</def>
In a nutshell, you can see that each of these auto-generated tags call the auto-generated  <form> tag which is defined by merging the Rapid <form> tag in addition to other tags. The specific fields that will be used in the form are declared within the fields attribute of the <field-list> tag that you learned about in Tutorial 14 on the <show-page> tag.
You no doubt are noticing that the <field-list> tag is doing something different here. Instead of displaying a two-column table consisting of field labels in the first column and field data in the second, it is putting the appropriate data entry control in the second column. The data entry control choice depends on the type of field that was defined in the model.
Hobo puts a one-line data entry box for the title field, which is a string field and a larger box for the body field, which is a text field.  Notice that Hobo also creates drop-down combo controls for the country field and for the categories collection. 
Hobo does this from inspecting table relationships.  The recipe model is related to both the country model and the category model. This is a pretty powerful capability for just one tag, especially given that the Category model is related to the Recipe model through a many-to-many relationship through the CategoryAssignment model.


All of this capability results from Hobo’s implementation of tag polymorphism, an ability to do what is necessary from the context of the code. Polymorphism means ‘many forms (not data entry form)’ or ‘many structures’. It is a hallmark feature of the Ruby language.
(There is even more going on in the <field-list> tag but we will wait to discuss it until the next step.)
Before moving on, let’s take care of a detail by using your knowledge of parameter tags. You will note that the <new-page> tag calls the <submit:> parameter tag and that the <edit-page> tag does not. But there is still a submit button on the edit page. The explanation can be found in the definition of the <form> tag. There you will see that the <submit> tag is declared as a parameter tag as is the <or-cancel> tag.
The <new-page> tag calls the <submit:> parameter tag and changes the label from its default value of ‘Save’ to a new value of ‘Create Recipe’. There is no need to call the <or-cancel> tag with its parameterized name, <cancel>, because it is not changed.
On the other hand, the <edit-page> tag just relies on the default for both of these tags so there are no calls to them in the <edit-page> tag definition.
2.	Working with the <field-list> tag. You have already done some work with this tag in the last tutorial.  Experiment with removing a field by editing the tag’s fields attribute. First copy the three tags above into application.dryml
     (As we have mentioned, you probably want to be careful about editing tags this way in a real application. But this is the easiest way for us to acquaint you with how Hobo works.) 
Let’s remove the categories drop-down box as an experiment. Working in application.dryml, edit the <form> definition code. Change 
<field-list fields="title, body, categories, category_assignments, country" param/>
to:
<field-list fields="title, body, category_assignments, country" param/>


Now your categories drop-down box is gone.
You may be wondering why we did not remove the category_assignments attribute also or for that matter why it is there at all. First, try removing category_assignments without removing categories. There is no effect. Try removing both. You get the same result as with removing categories alone. This is just how the <field-list> tag works. On the other hand, the model structure that connects the Recipe model to the Category model through the CategoryAssignments model must, of course, be there for the drop-down box to be there at all. Put back the categories drop-down box to end this step of the tutorial.
3.  Working with the  <field-list> and <input> tags. In the same way that <field-list> calls the <view> tag when it is showing a record’s data, <field-list> calls the <input> tag when it is creating an empty form to enter a record or populating a form for editing a record. This is an illustration of tag polymorphism. That is, <field-list> does many different things depending on the context of its use.
The overall syntax of the <input> tag is the same as the <view> tag. When you wish to create an input control on a form, one at a time, you can invoke the control in the following way.
<input:title>
In the code above you are requesting that an input field be created for the title field of the Recipe model. Hobo knows to use the Recipe model as long as you are in the context of the Recipe model, which in this case is set by working within the Recipe form. Further, as you’ve seen before, Hobo knows just what kind of control you are likely to need.
Below we are going to show you how to construct essentially the same form out of <input> tags that you created with the <field-list> tag in the previous step.
Let’s be a bit more rigorous now in constructing tags from tags. First remove the form definition tag from application.dryml. You will now use the <extend> tag to redefine an auto-generated <form> tag with the same name.
First, let’s create the skeleton of an extend tag so we can watch what happens one step at a time. The following code placed in application.dryml will cause no change because it substitutes this  <form> tag for the original <form> tag.
<extend tag="form" for ="Recipe">
	<old-form merge/>
</extend>
The following code, which might seem to be identical, actually is not. 
<extend tag="form" for ="Recipe">
	<old-form merge>
	</old-form>
</extend>
In the above case, Hobo replaced the default content of the parameterized <form> tag with blank content resulting in a blank form. Go to the ‘Recipes’ tab and pick a recipe. Then click ‘New Recipe’ to see the blank form.
Now let’s get some content into the parameter tag. Copy the following code into application.dryml:
<extend tag="form" for ="Recipe">
	<old-form merge>
		<error-messages param/>
		<p><input:title/><p/>
	    <div param="actions">
	      <submit label="Save" param/><or-cancel param="cancel"/>
	    </div>
	</old-form>
</extend>
Refresh your browser.


We’ve got an entry control but <input> has no built in labeling like <field-list>. We need to add it like we did with the <view> tag.

<extend tag="form" for ="Recipe">
	<old-form merge>
			<error-messages param/>
		<p><b>Title</b></p>
		<p><input:title/><p/><br/><br/>
	    <div param="actions">
	      <submit label="Save" param/><or-cancel param="cancel"/>
	    </div>
	</old-form>
</extend>
Refresh your browser:


Do the same thing for the rest of the fields. (Some of Hobo’s tags have differing built-in breaks, which is why the number of breaks varies some below.)
<extend tag="form" for ="Recipe">
 <old-form merge>
   <error-messages param/>
   <p><b>Title</b></p>
   <p><input:title/></p>

   <p><b>Recipe</b></p>
   <p><input:body/></p>

   <p><b>Categories</b></p>
   <p><input:categories/></p>

   <p><b>Country</b></p>
   <p><input:country/></p>

   <div param="actions">
     <submit label="Save" param/><or-cancel param="cancel"/>
   </div>
 </old-form>
</extend>



Now you have succeeded in reconstructing a form with the <input> tag and a little bit of additional HTML formatting. 
Summary. Hobo provides some great functionality for fine-tuning your application when the default rendering is not quite what you would like. You can experiment with them by going through the documentation on the Hobo web site or learn more about them in later chapters of this book.
Tutorial 16 – The <a> Hyperlink Tag 

In this tutorial you will learn to develop sophisticated data-driven hyperlinks in you Hobo pages. 
Tutorial Application: four_table
Topics
The <a> “hyperlink” tag for calling data-driven pages
Steps
1. Review the <a> tag usage within Hobo’s auto-generated tags. Let’s take a look at the <a> tag usage in the auto-generated tags for the Recipe model.
<!--New Page Link from the Index Page Tag-->
<a action="new" to="&model" param="new-link"/>
This tag results in the ‘New Recipe’ hyperlink with the route ‘http://localhost:3000/recipes/new’.
<!--Edit Page Link from the Show Page Tag-->
<a action="edit" if="&can_edit?" param="edit-link">Edit Recipe</a>
This tag results in the ‘Edit Recipe’ hyperlink with a route like http://localhost:3000/recipes/2-omelette/edit.
2. Construct a link to an index (record listing) page. Let’s work in the home page in the file views/front/index.html. We will place our test code after the “Congratulations . . . “ message. 
<br/><h4>
<a to="&Country" action="index" >List My Countries</a><br/>
</h4>
This code will generate a link to a listing of countries in your database. 

	
Note: The to attribute defines the model to be used in the listing. It is always prefixed by the & character. The action attribute defines the controller action, which in the above case uses Hobo’s built-in index action. As you get more sophisticated, you will learn to define your own controller actions. These can be referred to by the action attribute too.
Of course, if you click on the ‘List My Countries’ link, you will now see a listing of countries.


3.	Construct a link to a new record page. We can construct a link to create new countries in much the same way.
<a to="&Country" action="new" >New Country</a><br/>


Now you’ve got another link to try out.
4.	Construct a link to an edit record page. If you want to create a custom link to an edit page, you have to be sure you are in the right context. Hobo can implicitly figure out which record you wish to edit, but only if you are displaying a particular record.
     In the example from Step 1 above, the ‘edit page’ link occurs in a <show-page> tag definition so Hobo knows what record you want to edit.
Let’s create our own link on the Country <show-page> tag by using the <content-body:> parameter tag that is defined in the auto-generated <show-page> tag for the Country model. Create a new file called show.dryml in your views/countries directory.
You need to use the parameter tag or Hobo will ignore your code. This is just how the <show-page> tag was defined.
<show-page>
	<content-body:>
		<a action="edit" >Edit My Country</a><br/>
	</content-body:>
</show-page>
Go ahead and refresh your browser, click on the ‘Country’ tab and click on a country and you will see your new link to edit it on the bottom left.

Figure 150: Page view of custom <show-page> tag
5.   Construct a link to a specific record. In general, Hobo takes care of linking to specific records for you by setting up the links implicitly in the <index-page>. If you need to link to a specific record, that will require a little Ruby to address a specific record in the database. 



