SECTION 2: TUTORIALS
CHAPTER  3 - INTRODUCTOR TUTORIALS

Introductory Concepts and Comments
Tutorial 1 - Directories and Generators  	
Tutorial 2 - Changing Field Names
Tutorial 3 - Field Validation
Tutorial 4 - Introduction to Permissions
Tutorial 5 - Hobo
Tutorial 6 - Editing the Navigation Tabs
Tutorial 7 - Model Relationships
Tutorial 8 - Model Relationships












Introductory Concepts and Comments

If you explain a magic trick before it is performed, you risk spoiling the enjoyment. There will be plenty of time after you work through a few of the tutorials to learn what is going on “behind the curtain.”
So, in the spirit of this adventure we will explain just enough right now to allow you to dive in head first…
Tutorial 1 – Directories and Generators 

You will create a single-table application that demonstrates how Hobo constructs a nice user interface that includes a built-in login system and basic search capability.  Hobo 1.3 generators are compatible with the new Rails 3 generator API and operate quite differently from Hobo 1.0 and Rails 2.x.  We will explain in more detail below.
Tutorial Application: my-first-app
Topics
Creating a Hobo application
Learning the Hobo Directory structure
Generating Hobo models and controllers 
Generating Hobo models 
Generating Hobo controllers 
Creating Migrations and Databases 
Editing Models and propagating the changes 
Tutorial Application: my-first-app
Steps
1. Description of development tools. You will use three tools to do the work in these tutorials. They include:
A shell command prompt to run scripts 
A text editor for you to edit your application files
A browser to run and test your application
Ordinarily you will have two shell windows or tabs open: one from which to run Hobo  scripts or operating system commands and one from which to run a web server (Mongrel in these tutorials). These tutorials are not done with an integrated development environment (IDE). 
2. Create a Hobo application directory. Before you create your first Hobo application, create a directory called tutorials. This will be the directory where you keep all of your Hobo tutorials. Navigate to the tutorials directory using your shell application.  
	You should now see the following prompt:
\tutorials>
3. Create a Hobo application. All you have to do to create a Hobo application is to issue the Hobo command:
\tutorials> hobo new my-first-app

Note: The screen captures were taken with Hobo 1.3 pre-release # 26 as of 2/15/2011.
You will see a log of what Hobo is creating go by within the shell window that you will better understand as you learn Hobo’s directory structure. The first prompt from the Hobo Setup Wizard will appear as follows:

The Hobo Setup Wizard will present you with the following eight options, for this tutorial choose the following “default” options:


Question
Defaults 
Do you want to customize the test_framework? [y|n] 
n
a. Choose a name for the user resource [<enter>=user|<custom_name>]
<enter>
b. Do you want to send an activation email to activate the user? [y|n] 
n
c. Do you want to add the features for an invite only website? [y|n] 
n
d. Will you application use only hobo/dryml web page templates? (Choose 'n' only if you also plan to use plain rails/erb web page templates) [y|n]
y
e. Choose a name for the front controller [<enter>=front|<custom_name>]:
<enter>
f. Initial Migration: [s]kip, [g]enerate migration file only, generate and [m]igrate [s|g|m]: 
m
g. Type the locales (space separated) you want to add to your application or <enter> for 'en':
<enter>
h. Do you want to initialize a git repository now? [y|n] 
n


You will see the following message upon completion:



4. Start the web server. Create a second shell window (or tab).  You are now going to start a local web server on your computer. This will enable you to run the Hobo application and see what a deployed application looks like in your browser.
Navigate to your application directory and fire up the local web server by issuing the following command at your command prompt. 
\my-first-app> rails server 
While your server is executing, it does not return you to your command prompt. As you run your application, it logs what it is doing to this shell. You can terminate the web server by typing control-c and restart it the same way you started it above, but do not terminate the server.
5. Open your application in a web browser. Type the following URL into your browser:
	 http://localhost:3000/
The following “Register Administrator” page will appear:

Hobo, by default, assumes the first person that launches the application will be an administrator.  Go ahead and enter the information required and click on the “Register Administrator” button:
Note: The first person to register is assigned the administrator privileges by Hobo.  Notice that in the upper right-hand corner of your web page there is a drop-down list of created users that allows you to sign in automatically to any of the user accounts without going through the login page if you are in development mode. This is turned off in production mode.


This is how your app looks after registering:

Now let’s take a look at what Hobo has generated so far.  Use your text editor to locate the user.rb file under the app/models directory:

Figure 34: The default User model created by Hobo
Hobo took care of building the User model and generating the database table needed because we selected the “m” (generate and migrate) option for step 6 of the Hobo Setup Wizard:
Initial Migration: [s]kip, [g]enerate migration file only, generate and [m]igrate [s|g|m]: 
6. Examine what Hobo created during the first “migration”. In the following figure, you can see that the db directory is populated. 
a. The file, development.sqllite3, is the database file. 
b. The <timestamp>_initial_migration.rb file defines the database table that will be created when the migration is executed. 
c. The schema.rb file shows the current database schema after all migration executions to date.  In this case we have only created the user table.

Figure 35: Contents of the first Hobo migration file
Take a look at the schema and you will see that it corresponds to the migration file:

Figure 36: Contents of the "schema.rb" file after the first migration

Note:  You can see that the User model does not display all the fields that are implemented in the database. Hobo does not expose all of the User fields but reserves them for its own use.  All of the fields in other models will be reflected in the schema file.
Click on the “Logout” link and then click on the “Signup” link to create another account.  In the example below we are creating another account for “John Smith”. We will call this and all other accounts you create user accounts, because by default they will not have administrative privileges.
Log out of the user (e.g., John Smith) account you just created and login using the account you created as administrator (e.g., Owen Dall) for now. 
Note: You will use the user’s email address and password to log in, not the user’s name. Also, notice that in the upper right corner of your web page, there is a drop down box that lets you automatically login to any of your accounts without using the normal login page.  This speeds up testing permission customizations in development mode. In production mode this option disappears.  More on switching modes later.

	
7. Check the changes in the views/taglibs directory. Notice that since you fired up your web server, there is now a change in the taglibs directory. There is a new branch called views/taglibs/auto/rapid and three files in that directory: cards.dryml, forms.dryml and pages.dryml. We are going to show you a few things to pique your curiosity but we will not cover how Hobo handles views in any detail until the intermediate tutorials. We will just make a few high level comments here in case you know something about Ruby on Rails and so you know what is coming.
Familiarize yourself with the contents of these files. You will see many lines that look similar to:

<def tag= new-page>
.....
</end>
You will see mark-up in between the “def” and “end” tags. The contents are what we have mentioned before as “tag definitions.”  Hobo uses them to construct view templates on the fly.
These three files contain the libraries of tags that Hobo uses to construct view templates.
 

Note: When Hobo makes a web page, it takes tags from the pages.dryml file. When it wants to construct a data entry form, tags in the pages.dryml file call tags in the form.dryml file. When Hobo wants to list the records from a table, tags in the pages.dryml file call tags in the cards.dryml file. Card tags define how individual database table records are rendered.
(Actually, these files are a copy of what Hobo is doing on the fly behind the scenes but it is easier to think of it in this way.)
You will learn that you can edit and redefine the tags from the /rapid directory. When you want your changes to be available to the application, you can either put the new tags in the application.dryml file or create a taglibs/application folder and save your tags to a taglibs/application/<filename>.dryml.  Any dryml file located in the taglibs/application directory will automatically loaded and its tags will be available application wide. When you want them to be available only in a particular view you can put them in a dryml file under the app/views/<model> directory named for the model. 
So far, we only have the front (home page) and the users template directories. You will see after creating a new model (running hobo g resource or hobo g model) and running hobo g migration, that directories will be created and named for your new models.
8. Create a new model and controller. Let’s create a simple contacts model and see what Hobo does for us.
\my-first-app> hobo g resource contact name:string company:string 
This generator will create both a model and controller. Execute it and then take a look at what has changed in your application directories.
You will see the new contacts_controller.rb file in the /controllers directory and the new contact.rb file in the /models directory. 
Note: Unlike Hobo 1.0, a view template file is not created in the views/contacts folder.  We will discuss later how the rapid taglibs in the /auto/rapid folder take care of the default views for you).

Figure 39: Folder location for Models and Views
9. Run a Hobo migration. Before you run the migration, take a look at the contact.rb model file. We just want to review the relevant part for now. The permissions part will be explained in a later tutorial.
Here is the code that declares the fields that you want in your database table that will be called contacts. When you ran hobo g resource, it generated this code. 
class Contact < ActiveRecord::Base

 hobo_model # Don't put anything above this
 
 fields do
    name    :string
    company :string
    timestamps
 end
When you run hobo g migration, Hobo will take this declaration and create a migration file. It will then in turn use the migration file to create the database table. These two steps will be executed within a single Hobo migration. You could do them separately but we will not do that here.
Now run hobo g migration and observe what happens.
\my-first-app> hobo g migration
Remember to select the ‘m’ option to both create and execute the migration file. Then hit return to accept the proposed name of the migration file.
You will notice some changes now in the my-first-app/db directory of your app. 


There is a new migration file and changes in your schema file as well. The new migration file contains the following code:
  def self.up
    create_table :contacts do |t|
      t.string   :name
      t.string   :company
      t.datetime :created_at
      t.datetime :updated_at
  end

The schema file (schema.rb), reflecting this code, shows the current state of the database in the db/schema file:

 create_table "contacts", :force => true do |t|
    t.string   "name"
    t.string   "company"
    t.datetime "created_at"
    t.datetime "updated_at"
 end
Now check out the application in your browser with the following URL after running the command rails server
      http://localhost:3000/


Now you have a new tab called “Contacts.”
10. Create some contacts. Now you should be able to create a new contact by clicking the ‘New Contact’ link in the Contacts tab. Go ahead and create a couple of new contacts to convince yourself that the database entry actually works. While you are at it also try editing a contact.
So far, Hobo is doing a pretty decent job. You have a usable UI, I/O capability for your contact model and a login system and you have written no code.
11. Try out the search facility. Type the name of one your contacts to exercise the search facility. The default search searches “name” fields.  You need at lease three characters for a partial word search.
12. Add columns to the database. Now we are going to add a couple more fields to the model and have hobo add columns to the database. In this and the following steps, you will get a sense for the power of the hobo g migration generator.  Since we have already generated our model using hobo g resource, we do not have to do that again. Go into the model and add some new fields. Your code should now look like this:

class Contact < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name    :string
    company :string
    address_1 :string
    address_2 :string
    city      :string
    state     :string
    date_met  :date
    married   :boolean
    age       :integer
    notes     :text
    timestamps
  end
Make sure you save your changes and run hobo g migration. Select the ‘m’ option and accept the default filename for the migration.
\my-first-app> hobo g migration
Now refresh your browser. Go to the contacts tab and click ‘New Contact ’


Note what Hobo has done for you. It determines which entry controls you need based on the type of field you defined in your model. It has one-line fields for strings, a set of three combo boxes for dates, a one-line field for integers, a check box for boolean field, and a multi-line box for text fields. Later you will see that Hobo can provide the controls you need for multi-model situations.
Hobo has also provided reasonable names and styles from the field names. It removed the underscore characters and appropriately capitalized words to give the presentation a nice look and feel.
13. Remove columns from the database. Now suppose you decide that you need only one address field and you decide to remove the second one. Go back to the Contact model and delete it (we just commented it out with the # sign so you can see things clearer.)


class Contact < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name      :string
    company   :string
    address_1 :string
    #address_2:string
    city      :string
    state     :string
    date_met  :date
    married   :boolean
    age       :integer
    notes     :text
    timestamps
  end
Run hobo g migration again.
\my-first-app> hobo g migration
Hobo notices that you have deleted a model field and responds in this way.
CONFIRM DROP! column contacts.address_2
Enter 'drop address_2' to confirm:
You respond by typing what it asks (without the quotes).
CONFIRM DROP! column contacts.address_2
Enter 'drop address_2' to confirm: drop address_2
Complete the migration as you have learned above. Then go check the db directory. You will see another migration, *_hobo_migration_4.rb  with the following code. (The asterisk (*) here stands for the time/date stamp that precedes the rest of the migration file name.)
class HoboMigration4 < ActiveRecord::Migration
  def self.up
    remove_column :contacts, :address_2
  end

  def self.down
    add_column :contacts, :address_2, :string
  end
end
Check out the schema.rb file now.
ActiveRecord::Schema.define(:version => 20090220154125) do

  create_table "contacts", :force => true do |t|
    t.string   "name"
    t.string   "company"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "address_1"
    t.string   "city"
    t.string   "state"
    t.date     "date_met"
    t.boolean  "married"
    t.integer  “age”
    t.text     "notes"
  end
You can see that address_2 is gone.
14. Adding and removing database tables. You can also use hobo g migration to remove (drop) a table. Delete the model file and the associated helper and controller files. Then run hobo g migration.  You will be prompted to confirm that you wish to drop the table. (If you neglect to delete the helper and controller file for this model you will get an error.)
15. Going back to earlier migrations. Hobo does not provide this facility within hobo g migration. You will need to use the rake db:migrate VERSION = XXX procedure. You can roll back your tables but the rest of your changes will not be synchronized so you will have to perform manual edits.
Tutorial 2 – Changing Field Names

We are going to continue from the previous tutorial and show you how to do rename fields in a couple of different ways and improve your UI with hints about what to enter in a particular field.
Topics
Two ways of changing field names displayed
Displaying data entry hints
Changing field sizes: Hobo does not provide this facility now.
Tutorial Application: my-first-app
Steps 
1.	Rename a database column. In Tutorial 1, we showed you how to make changes to your database by editing the model file. You can rename a field and database column in the same way. We will try this with the married field. Go to your contacts.rb file and rename married to married_now and run the hobo g migration.
class Contact < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name			  :string
    company	       :string
    address_1     :string
    #address_2    :string
    city     	    :string
    state		    :string
    date_met      :date
    #married      :boolean
    married_now   :Boolean
	   age	          :integer   
    notes         :text
    timestamps
  end

\my-first-app> hobo g migration
Hobo should now respond:
DROP, RENAME or KEEP?: column contacts.married
Rename choices: married_now
Enter either 'drop married' or one of the rename choices or press enter to keep:
Hobo is trying to confirm that what you really want to do is rename the column and not drop it. Enter married_now to rename. Check your schema.db file and you will see that the column has been renamed.  The KEEP option is a safety option in case you mistakenly renamed the column,
Note: Do not use question marks (?) in field names. You will get an error.
Refresh your browser and you will now see the field labeled ‘Married Now.’
2.  Changing field names. There is no need to change the name of a field or column if all you wish to do is to change the name of a label in the user interface.  Hobo provides this as part of its new Internationalization (i18n) module.  This i18n module is very versatile and can be used for providing field/model renaming capabilities up to full multi-lingual support for your application.  The  i18n module is comprised of .yml files that reside in the config/locales directory; if you look in the directory you will see these files:
app.en.yml (or app.<locale>.yml)
hobo.en.yml (or hobo.<locale>.yml)
For this tutorial we will assume that english (en) was specified as the default locale.  The hobo.en.yml file contains all the strings that the hobo framework uses, while application specific strings are stored in the app.en.yml file.  We will modify the app.en.yml file to rename a couple of fields in the Contact model.  When you open the config/locales/app.en.yml file, you will see:

Figure 44: Default config/locales/app.en.yml File

The commented yaml code is very useful in understanding how to setup your locale file.  Our goal is to rename the name and address_1 fields of the Contact model.  To do this, add the illustrated code to the file:

Figure 45: app.en.yml File with Fields Renamed
As shown above, to declare new names for model fields in the app.en.yml file, the following pattern must be followed:
  activerecord:
    attributes:
      <model1>:
        <field1>: Label/Rename
        <field2>: Label/Rename
			…

      <model2>:
        <field1>: Label/Rename
        <field2>: Label/Rename
			…

			

Note: Indentation and spacing is very important when working with yml files; the activerecord: line must start with 2 spaces.
Refresh your browser and you should see the fields relabeled with your choices from above. Notice that a migration is not necessary for any changes made using the i18n module.


3.   Using the i18n module to suggest field uses. The application locale (app.en.yml) file also provides the facility to provide a suggestion below the field on what to enter into it. Edit your app.en.yml file to look like this.




Now refresh your browser and you will see hints on the field use in a small font below:


Note: In the Intermediate tutorials you will also learn how to use yet another way to manipulate the labels on a web page by using Hobo’s view markup language called DRYML (Don’t Repeat Yourself Markup Language).  DRYML is used by the Rapid UI generator that creates much of Hobo’s magic.
4. Changing field sizes.  As of the latest version of Hobo, the way to change the field length on an input form is to add an entry to application.css that will override any other reference to the element you wish to modify.
Look for the relevant class definition used by Hobo’s “Rapid” UI generator:  rapid-ui.css, located at:
/public/hobothemes/clean/stylesheets/rapid-ui.css

Figure 49: CSS definitions for the input text fields

	

Figure 50: Modified entry in "application.css" to shorten text prompts
Tutorial 3 – Field Validation

You will be introduced to a couple of ways of validating data entry fields. This is a capability that is derived from what are called Rails helper methods. There are a couple of enhancements Hobo has made for the most common need.  
Topics
Field validation using Hobo’s enhancements
Field validation using Rails helper methods
Validation on save, create and update processes

Tutorial Application: my-first-app

1.	Make sure data is entered. Open up the model contact.rb file.  Add the following code to the “name” field definition   
name   :string, :required
This is the simplified version that Hobo provides. To do this in the “normal” rails way, you would need to add this line after the “fields/do” block:
validates_presence_of :name   
(The difference in the two is a matter of taste, but the former seems “DRYer”  to us.)
By default Hobo will provide a message if a user fails to enter data. Try it out by trying to create a contact record with no data in it. Click the Contacts tab and then New Contact. 
Without entering anything in the form, click Create Contact.


2.	Validate multiple fields. In order to validate multiple fields, add the “:required” label to another field:
address_1   :string, :required

Click the Contacts tab and then New Contact. Without entering anything in the form, click Create Contact.

Notice the “declarative” nature of this validation.  All you need to do is use the label “:required”  for the name and address_1 fields and Hobo takes care of all of the logic associated with validation and delivering error messages. 
Now let’s try some other validations. 
3.	Make sure the integer field contains a number.  Add this validation to the “age” field after the “fields do/end” block:
validates_numericality_of  :age



Now try this out by entering the text “old” in the age field. (Also put something in the name and address_1 fields so you won’t trip the validations we put into place earlier in the tutorial.)

Figure 54: Page view of triggering the "validates_numericality_of" error

Note: When you cause a validation error for integer, Hobo/Rails replaces what you entered with a zero (0).  If the validation rule was not there, the text will be replaced by a zero, but the validation error will not be displayed.
4.   Prevent the entry of duplicates. Use the following code to prevent  a user from entering code that duplicates an existing record with a column value that is the same as the new record.
name  :string, :required, :unique


Note: This particular validation will only verify that there is no existing record with the same field value at the time of validation. In a multi-user application, there is still a chance that records could be entered nearly at the same time resulting in a duplicate entry. The most reliable way to enforce uniqueness is with a database-level constraint. 
5.	Including and excluding values. Now suppose we wish to exclude people who have an age between 0 and 17, and include people under 65 years of age. Try the following code after the “fields do/end” block:
validates_inclusion_of :age, :in => 18..65, :message => "Must be between 18 and 65"


6.	Validate length of entry. Suppose you wish to check the length of a string entry. You can specify a length range in the following way.
validates_length_of :name, :within => 2..20, :too_long => "pick a shorter name", :too_short => "pick a longer name" 
Try to enter a one-character name. You will get the following response:
 
7.	Validate acceptance. If you wish to get the user to accept a contract, for example, you can use the following validation code. Assume you have a Boolean variable named contract_agree, which would show up in the UI as a checkbox.
validates_acceptance_of :contract_agree, :accept => true
Hobo will generate an error if the contract_agree check box is not checked setting the value to 1.

	
8.	Summary. Here is the list of validations we accumulated during this tutorial:
address_1   :string, :required
name  :string, :required, :unique

validates_numericality_of  :age

validates_acceptance_of :contract_agree, :accept => true

validates_length_of :name, :within => 2..20, :too_long => "pick a shorter name", :too_short => "pick a longer name" 

validates_inclusion_of :age, :in => 18..65, :message => "Must be between 18 and 65"

There are several other very useful validation functions provided by Rails,  and the ones that we have shown you above have many other options.  These functions can provide very sophisticated business rule execution.
For example, the following is a sample of the list of options for the validates_length_of and validates_size_of (synonym) declarative expressions:
:minimum - The minimum size of the attribute. 
:maximum - The maximum size of the attribute. 
:is - The exact size of the attribute. 
:within - A range specifying the minimum and maximum size of the attribute. 
:in - A synonym(or alias) for :within. 
:allow_nil - Attribute may be nil; skip validation. 
:allow_blank - Attribute may be blank; skip validation. 
:too_long - The error message if the attribute goes over the maximum (default is: "is too long (maximum is {{count}} characters)"). 
:too_short - The error message if the attribute goes under the minimum (default is: "is too short (min is {{count}} characters)"). 
:wrong_length - The error message if using the :is method and the attribute is the wrong size (default is: "is the wrong length (should be {{count}} characters)"). 
:message - The error message to use for a :minimum, :maximum, or :is violation. An alias of the appropriate too_long/too_short/wrong_length message. 
:on - Specifies when this validation is active (default is :save, other options :create, :update). 
:if - Specifies a method, procedure,  or string to call to determine if the validation should occur:
 :if => :allow_validation 
The method, procedure, or string should return or evaluate to a true or false value. 
:unless - Specifies a method, procedure  or string to call to determine if the validation should not occur:
 :unless => :skip_validation
The method, procedure, or string should return or evaluate to a true or false value. 
We encourage you to read about validation helpers (what Rails calls functions) in the many good Ruby on Rails references. The following is a useful on-line reference:
http://api.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html
Tutorial 4 – Permissions 

In this tutorial you will learn some elementary aspects of Hobo’s permission system by changing what the admin user and users can do. Specifically, you will determine   whether a user is permitted to view, create, edit or delete records in the database.
Topics
Experiment with altering user permissions.
Naming conventions for database tables, models, controllers and views.
Tutorial Application: one_table	
Steps
1.	Create the Hobo application. Create the one_table Hobo application by issuing the following command at the command prompt.   By adding the --setup command line parameter the application will bypass the setup wizard and create the application with default settings, Then change directory to the subdirectory one_table:
\tutorials> hobo new one_table --setup
\tutorials> cd one_table
\one_table>
Recall from Tutorial 1 that this sets up the Hobo directory tree and the user model and controller. 
Note: Look at the file \one_table\app\models\user.rb and at the database schema file \one_table\db\schema.rb. There are more fields in the users table than in the user model. This is because Hobo creates several user model fields for you automatically. This will not be the case for models you create. 
3.	Start the web server. Open a new command prompt and navigate to the \tutorials\one_table  directory.  Fire up your web server by issuing the following command.
\one_table> rails server
4. Initiate the web application. Enter the local URL for the application in your browser’s URL window:
 	http://localhost:3000/

You should now see the following displayed on your browser.



5. Create user accounts. You will need a couple of accounts to exercise the functions of the One Table application. Let’s do this now like you did in Tutorial 1. 
Click Register Administrator to create the administrator account.  We refer to this account as the admin account. Logout and create a second account. We will refer to this second account as the user account in the following tutorials. By default, the user account does not have administrative privileges.
Later in the tutorial, you will learn to customize the default permission features.
Log out of the user account and login to the admin account for now.  Remember that you will use the admin email address and password to login, not the name.
6. Create the recipe model. Next create a model using the hobo:resource generator, which will be called Recipe. It will contain three fields: title, body and country. We will complete this step by rerunning the Hobo migration from Step 3. This will take the model definitions and create a migration file and the database table recipes.
\one_table> hobo g resource recipe title:string body:text country:string
	This generator created a recipe.rb model from which the hobo:migration generator will create a migration file and a database table.
Note: When we talk about a model’s name we are referring to its Ruby Class name that can be found at the top of the file.
	It also created the recipes_controller.rb controller, the recipes_helper.rb helper file, and recipes view folder. Run the hobo:migration generator:
\one_table>  hobo g migration

IMPORTANT: Hobo is different from Rails in that the migration file and database table are both the result of the hobo:migration generator. In Rails, generators typically create both models AND migration files but NOT database tables. 
	Refresh your browser and you should see a Recipes tab added. 


7. Confirm your login info. Make sure you are logged in as the administrator.  As long as you are logged in, you should see the “New Recipe” link on the left. 
	Create three recipes and take care to add info in all three fields. You can create them either from the Home or Recipes tab. The finished recipes should be displayed in both the Home tab and the Recipes tab automatically. You can click on any of the names of the recipes to edit them. Try it out.

Figure 61: Page view of created recipes
8. Login as a user. Sign out of the admin account and sign in as another. Note that you can still see the recipe title. Now, you can click on the recipe title and view the entire recipe record but you cannot create or edit a recipe. This is governed by the Hobo “Permissions” module. In the next step, you will change the user permissions and see how the user interface responds by automatically providing creation and editing capabilities in the user interface.
9. Edit permissions: Take a look at the recipe.rb model file. 
# --- Permissions --- #

def create_permitted?
	acting_user.administrator?
end

def update_permitted?
	acting_user.administrator?
end

def destroy_permitted?
	acting_user.administrator?
end

def view_permitted?(field)
	true
end
	There are four methods that define the basic permission system: create_permitted?, update_permitted?, destroy_permitted? and view_permitted?. In exercising the permission system, you are editing Ruby code. The permission methods are defined within Hobo. Each method evaluates a boolean-valued variable (actually a method on an object) that indicates whether the named action is allowed or not allowed. 
Method
Refers to permission to:
create_permitted?
create a record
update_permitted?
edit a record
destroy_permitted?
delete a record
View_permitted?(field)
view a record or field
Figure 62: Table of Hobo permission methods
For the code that is generated by the hobo:resource generator, the method is checking whether the acting user, which is the user that is signed on, is or is not the administrator. In practice though, the boolean value may ask another question or a more complex question. 
For example, one could write a line of Ruby code that determined if the signed on user was the admin AND the time was between 8:00 AM and 5:00 PM. In other words, there can be other logical determinations but you have to know a little Ruby.
acting_user method
Meaning
administrator?
first user to sign up
signed_up?
any user who is signed up (including the administrator)
guest?
any user who is not signed up
	Figure 63: Table of Hobo "acting_user" options
For these tutorials, we will use the acting_user object and its methods: administrator?, signed_up?, and guest?. Hobo encodes information about the user of its applications in the active_user object that determines if the user is an administrator, other signed up user or a guest user.
 	For example, acting_user.administrator? equals ‘1’ if the user is the administrator and ‘0’ if the user is not. If we place it within the create_permitted? method, Hobo only permits users who are administrators to create database records related to the model containing the method. 
Note: The ‘?’ after signed up indicates the method is a Boolean method.
The meaning of the default permissions code can be summarized simply now. Only the administrator is permitted to create, update or destroy records and anyone can view records. Using the view_permitted? method is a little more involved so we will wait until the intermediate tutorials to tell you about it.
Before trying this out, it is useful to understand how Hobo implements these permissions within Hobo’s UI. Yes, Hobo not only provides the facility to set permissions but it also takes care of providing the right links and controls within the UI.
When there is no create permission, there is no “Create a New {model_name} ” link.
When there is no update permission, there is no edit link and no way to populate a form with an existing record.
When there is no destroy permission, there is no “Remove this Record?” link. 
This will make more sense when you learn about controller actions in the next tutorial. Hobo permissions essentially turn controller actions (what users do in the UI) on or off depending on defined logical conditions.
Let’s try something out now.
As of now in your code, users who are not the admin can only view the records entered by the administrator. The user has no create, edit or delete permission; these options do not appear in the user interface.
	Now let’s make a minor change and see how the UI responds. 
	CHANGE:
def create_permitted?
	acting_user.administrator?
end
		TO:
def create_permitted?
	acting_user.signed_up?
end
	Update your browser and you will see the New Recipe link appear at the bottom of both the Home and Recipes tabs. Now do the following:

CHANGE:
def update_permitted?
	acting_user.administrator?
end

def destroy_permitted?
	acting_user.administrator?
end
TO:
def update_permitted?
	acting_user.signed_up? 
end

def destroy_permitted?
	acting_user.signed_up?
end
	Click a recipe title. On the right hand side of the screen showing the record, you will see an Edit Recipe link now indicating editing permission. Click this edit link and you will now see a full editing page as well as a Remove This Recipe delete link in the upper right of the page.

	
	Try changing all of the signed_up? methods to guest and you will observe that you have full permissions even if you are not signed in.
	Complete the tutorial by putting back all three methods to signed_up?.
Tutorial 5 –  Controllers

Topics
Introduce Hobo’s controller/routing system.
Hobo automatic actions
Show examples of the permission system working with controllers
Tutorial Application: one_table	

Steps
1.	Demonstrate controller actions. Hobo has a set of built in actions for responding to user-initiated requests from browser actions (clicks). For example, when Hobo displayed the Recipes in Tutorial 3, it is the result of the index action found in the /app/controllers/recipes_controller.rb file. Open this file.  
Note: Recall that controller and model files contain Ruby code whereas view templates contain HTML with embedded Ruby code.

class RecipesController < ApplicationController
	hobo_model_controller

 	auto_actions :all
end
There is not much you can see--but there is a lot going on behind the scenes.
The first line is similar to the first line of the Recipe model we told you about in Tutorial 1. It indicates that the RecipesController is part of the Rails  ApplicationController and inherits general capabilities from this master controller. 
The next line, hobo_model_controller, tells Rails to use Hobo’s controller functionality to control the Recipe model and views.  It is actually short for:
#Do not copy - although it won’t change anything if you do.
hobo_model_controller Recipe 
Hobo automatically infers the model name from the controller name in the first line above. 
Note: The pound (or “hash”) character (#) is the symbol to indicate a Ruby comment. Everything on a line following # will be ignored by Ruby. Code starts again on the next line. To create view template comments, where you are not in a Ruby file you must surround comments like this <!--Comment-->.
The next line, auto_actions :all, makes all the standard actions available to the controller including: index (meaning “list”), show, new, create, edit, update, and destroy (meaning “delete”). If you are familiar with Rails, you will realize that Hobo has replaced quite a bit of Rails code in these two lines. 
2.	Edit the auto_actions. Clicking the Recipes tab in your app invokes the index action of the Recipes controller. The index action of the controller tells Hobo to list the records of the model. You probably noticed this as you created new records. Each time you created a new one, you probably clicked on the tab to see a list of all the records you created.  
Now notice something else that you will learn to be important. When you click on the Recipes tab, the URL that is displayed in the URL window says: 
http://localhost:3000/recipes
As you learn about the functions of the fundamental Hobo actions (listed in Step 1 above), you will learn that there is a unique URL entirely specified by the action and model name.  Look at figure earlier in this book about  “Actions and Routes”, and you will see the URL for an index action is the base URL, http://localhost:3000/ concatenated with the plural of the model name, which in this case is “recipes”.  
We are going to further demonstrate that attempting to route to this URL invokes the index action by turning off the action in Hobo and then putting turning it back on. First go to your home page by clicking the Home tab. Then, in recipes_controller.rb,
CHANGE:
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :all

end
TO:
class RecipesController < ApplicationController

	hobo_model_controller 
	
	auto_actions :all, :except => :index

end
The  except clause in this code tells the controller to turn off the index action. 
Refresh your browser and you should see this display:


Your Recipes tab disappeared. You can also try invoking the index action by typing http://localhost:3000/recipes into your URL window. You will get a blank page.
Hobo will no longer invoke the index action because you told it not to in your code. Hobo decided to do more though; it changed the UI also. 
In Tutorial 3, you learned that Hobo figures out how your UI should look depending on your model code. There it changed what links were available depending on permissions you specified in the code. In this case, Hobo figures out how to change the UI depending on the controller code. Here it has removed a tab, the Recipes tab, because you disallowed the action that it would invoke. Now remove the except clause and you should get your Recipes tab back.
Note: If you are new to Ruby you are probably noticing all the colons(:) and arrows (=>). For now.  Think of these two as a way of connecting a Ruby symbol (any text that begins with a colon) to a value (the entity after the expression  “=>”).  We recommend a companion book such as Peter Cooper’s “Beginning Ruby:  From Novice to Professional” to learn more about Ruby symbols and their importance.
Now turn the index action back on by deleting the :except clause.
class RecipesController < ApplicationController

  hobo_model_controller

  auto_actions :all
  
end
3. 	Remove and restore the new and show actions. Hobo allows you to edit this in two ways. You can either stipulate you want all except certain actions or that you want only specific actions. In other words, you can either indicate which actions you wish to include or indicate which actions you wish to exclude. The former is what you did in step three. Let’s try the latter where you declare which actions you want. The following code will do exactly what you did before but in a different way.
First, use the following code to include all seven actions, including the index action. This code is equivalent to the auto_actions :all statement above.
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :index, :show, :new, :create, :edit, :update, :destroy

end
Try removing the index action. When you save your code and refresh your browser, you will obtain the same result using the :except => index code. Now put back the index action and try removing the :new option.
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :index, :show, :create, :edit, :update, :destroy

end
The result is that the New Recipe link to http://localhost:3000/recipes/new, the URL associated with the new action disappears. This is because you have disallowed the new action and Hobo takes care of cleaning up your UI for you. Even if you try to go to that URL by typing http://localhost:3000/recipes/new into the browser, Hobo tells you that you can no longer go there.

Put the :new action back in and click the Recipes tab. Mouse over the Recipe links and note that the URL’s look like,  http://localhost:3000/recipes/2-omelette which are of the form http://localhost:3000/model(plural)/ID-model_name_variable which is the form that we discussed earlier in this tutorial for the show action. 
Note: Hobo assigns a name variable to the model equal to the value of the field it thinks is the most likely summary field. Hobo first looks for a field called name.  Next it looks for the next most likely, which in this case it guesses is title. You can override the automatic name assignment by adding the option :name => true to the field you would like displayed as the “name”. 

Figure 67: How Hobo finds the default "name" attribute for a model
You can also use a little “Hobo magic” to create your own version of name using a Ruby method as below:

Figure 68: Creating your own custom "name" attribute




Figure 69: Page view of the custom name attribute

Now back to our original train of thought…Remove the :show action.:
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :index, :new, :create, :edit, :update, :destroy

end
Now when you refresh your browser you will note that you no longer have links to show(display) the details of a particular Recipe record. Even if you try to navigate your browser to http://localhost:3000/recipes/2-omelette, you will get an error.
Now let’s try one more but using the except version of auto_actions again but first make sure you are back to the all actions state. Use the code below.
class RecipesController < ApplicationController

	hobo_model_controller 
	
	auto_actions :all

end
Navigate to the Recipes link where you should now see a list of hyperlinks to each recipe. Click on a recipe.


Observe the Edit Recipe link on the right hand side of the display. Click or mouse over it to convince yourself that the URL associated with this link is:
    http://localhost:3000/recipes/6-hamburger/edit
This is just the result you would expect for the edit action of the form: 
    http://localhost:3000/model(plural)/ID-model_name_variable/edit
Now make sure you are on the screen above, a particular Recipe. Edit your code to remove the edit action.
class RecipesController < ApplicationController
	 hobo_model_controller 
	 auto_actions :all, :except => :edit
end
Now you should see that Hobo removes the links to the edit action and even if you try to force Hobo to go to the above URL, it will not, giving you an error:


1. Remove multiple actions. So far we have showed you how to remove one action at a time. You can use the two methods we have showed you to remove two or more actions at a time. If you use the listing approach and you are starting with all the actions as in:
class RecipesController < ApplicationController
	
   hobo_model_controller
  
   auto_actions :index, :show, :new, :create, :edit, :update, :destroy

end
If you want to remove both the new and the create actions, just delete them from your list so that you have:
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :index, :show, :edit, :update, :destroy

end
If you start be specifying all actions and use the except clause, the equivalent code to the above will be:
class RecipesController < ApplicationController

	hobo_model_controller
	
	auto_actions :all, :except => [:new, :create]

end

Note: When removing the :new action, this actually adds a 'New' facility below the list of Recipes. When you remove the :show action, Hobo places an 'Edit' link against each listed item.

You may be wondering why the :except option encloses the list of actions in square brackets and the listing approach does not. The Ruby :except method takes a Ruby array as an input and Ruby arrays are enclosed in square brackets. 
5.	Using controller short cuts. There is one other way to add or remove controller actions and that is through the use of short cuts. The code:
auto_actions :read_only
is the same as:
auto_actions :index, :show
The code:
auto_actions :write_only
is the same as:
auto_actions :create, :update, :destroy

Note: You can append actions or use the except actions clause with either of these short cuts. The proviso is that you must use the shortcut first and [use only one] and use the except clause last.

6.     Hobo Controller action summary. Below is a list of all controller actions 
Action
Summary Meaning
URL Mapping
Example
(model -  recipe)
index
display list of records
/base/model(plural)
/base/recipes
show
display a single record
/base/model(plural)/ID-name
/base/recipes/2-omelette
new
allocate memory for a new record and open a form to hold it.
/base/model(plural)/ID-name
/base/recipes/new
create
save the new record.
link without landing
/base/recipes
edit
retrieve a record from the database and display it in a form
/base/model(plural)/ID-name/edit
/base/recipes
update
save the contents of an edited record
lands on show
/base/recipes
destroy
delete the record
lands on index
/base/recipes
Figure 72: Hobo Controller action summary
 
Tutorial 6 – Navigation Tabs

This tutorial provides an introduction to Hobo’s automatically generated tags. We will start with the navigation tabs that are generated for each mode.  We will show you where to find them and how to make a simple edit to change how navigation tabs are displayed. We will explore this more deeply in Chapter 4. 
Topics
Locate Rapid directories
Edit the navigation tab
Tutorial Application: one_table	
Steps
1.	Find Hobo’s auto-generated tags. Open up the views directory and navigate to the rapid directory by following this tree: views/taglibs/auto/rapid. You will see three files called: pages.dryml, forms.dryml, and cards.dryml. It is here that Hobo keeps its default definition of the tags its uses to generate view templates.
2.	Open the pages.dryml. file. Take a quick look through this file and you will see tag definitions such as:
<def tag="main-nav"> . . . 
<def tag="index-page" for="Recipe">
<def tag="new-page" for="Recipe">
<def tag="show-page" for="Recipe">
<def tag="edit-page" for="Recipe">
Notice how, except for the <main-nav> tag these correspond to the actions of Hobo Controller action summary above in Tutorial 5. You will further note that these are just the actions that require a view (remember index means list). The other actions, create, update, and destroy only needed a hyperlink. We are only mentioning this now to pique your curiosity for Chapter 4 where you will delve deeply into Hobo’s way of creating and editing view templates.
3.	Edit the <main-nav> tag. Copy the following code and paste it into your views/taglibs/application.dryml file. Hobo automatically uses code in this file instead of what it finds in pages.dryml. In other words, application.dryml overrides pages.dryml and further makes it available to the entire application. 
<def tag="main-nav">
  <navigation class="main-nav" merge-attrs param="default">
    <nav-item href="#{base_url}/">Home</nav-item>
    <nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
  </navigation>
</def>
5.	Rename a Navigation Tab. By convention, Hobo names tabs, other than the Home tab with the plural of the model name. In this case, that is ‘Recipes’ Let’s try renaming this to ‘My Recipes’.  There are a couple of ways to do this:
Use Hobo’s i18n module to specify a new value for the recipe.nav_item key
Override the main-nav tag in application.dryml and rewrite it to specify ‘My Recipes’ as the Recipe tab label
The preferred way of doing this is the first option and specify a new value for the recipe.nav_item key, the reason for this is that this maintains the application’s ability to handle multiple languages.  If we overrode the main-nav tag in application.dryml, this would be a ‘hard-coded’ solution and would always show ‘My Recipes’ regardless of the current locale/language.
Just add the following to your config/locales/app.en.yml file:
en:
  recipe:
    nav_item: "My Recipes"
Refresh your browser and you will see a renamed tab:



6.  Remove the Home Tab. Instead of deleting the Home tab, just comment it out by surrounding it with <!-- ...-->.
Note: Since view files are essentially HTML and not Ruby code, you use the HTML commenting syntax instead of the Ruby comment syntax.

<def tag="main-nav">
	<navigation class="main-nav" merge-attrs>
		<!--<nav-item href="#{base_url}/">Home</nav-item>-->
		<nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
	</navigation>
</def>

Now refresh your browser and you will see the Home tab has been removed:


7.	Reset the tabs. Since editing the application.dryml file will interfere with future tutorials, delete the code you copied above.
<def tag="main-nav">
	<navigation class="main-nav" merge-attrs>
		<!--<nav-item href="#{base_url}/">Home</nav-item>-->
		<nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
	</navigation>
</def>




Tutorial 7 – Model Relationships: Part 1	

You will learn how to create a new model that is related to another table. You will replace one of your table’s original fields with a key that is linked to a foreign key in order to select values. You will see how Hobo automatically creates a drop-down control to select values that you have entered.
You will also make some controller action edits [and some permissions changes] to refine the user interface.
More specifically, you will add a new model to hold the names of countries that a user will select from the New Recipe page. The application will identify the foreign key for that country and place it in the recipes table.
Topics
Model relationships
Foreign keys
Drop-down list boxes

Tutorial Application: one_table
Steps

1. Copy the Application. If you would like to preserve your application in its state as of the end of Tutorial 6, you may wish to copy the application and work on the new version. Copy the entire application directory and paste it into a folder called two_table in your tutorials directory. 
To change the application name, make the following change to config/application.rb:											
Figure 75: Changing the Application Name
Shut down the web server by issuing a <control-c> in the command window where you issued the rails server command. 
Restart the web server and you are ready to go.
\two_table> rails server 
2.	Add drop down control for preset selections. This tutorial is about adding associations between tables. In subsequent steps, we are going to show you how to create a new Countries table to store the values of country names to associate with your recipes. Hobo will take care of the user interface rendering, as you will soon see.
Before we do that though, let’s demonstrate the simpler approach. This is the easy way to go for applications when you know at design time all the possible values of a category. In this case, you would not need to add the additional complexity of creating a table to maintain all values for countries. All that is needed is to specify  in the model the list of possible values using the enum_string attribute of a field. In this tutorial let’s assume the only values for country will be: American, French & Chinese.
Your recipe.rb model code should now look like:
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    title   :string
    body    :text
    #country :string
    country enum_string(:American, :French, :Chinese)
    timestamps
  end
We have used the enum_string field method to declare the possible values for country. So we can easily see what we have done, we have commented out the old version of the country field declaration by preceding it with a ‘#’ (hash). Now refresh your browser and click ‘New Recipe’ and you will see a drop-down control that lets you select values for country.


This is fine as long as you don’t have to change the possible values. In the next steps, we will show you how to create a new table to store country values and be able to edit it on the fly and have it be reflected in your GUI. You will not have to write any queries. Hobo will take care of everything for you.
3.	Remove drop down control. First let’s get back to where we started before adding a new table. Edit your code to look like this.
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    title   :string
    body    :text
    country :string
    #country enum_string(:American, :French, :Chinese)
    timestamps
  end

The drop-down control will now be gone when you refresh your browser.
Note: Remove the custom name attribute you created in the last tutorial before continuing.
4.	Creating model associations. In the next several steps, we will add a Country model, set up a relationship between the Country model and the recipe model and then run a Hobo migration to create the Countries table. This last step will also set up the foreign key in the Recipe model that will maintain the association to the index of the new Country model, country_id. 
When you look in the db/schema file to review the fields in your tables, you will not see the ID’s of any table listed but they are there. Every time you create a table using a migration in Hobo, it will also create the table index with a name defined by convention to be the model name with ‘_ID’ appended.
5.	Add a new model. We will use Hobo’s hobo:resource generator to create a new model with one field to store a country’s name. If you do not have a command prompt window open besides the window you used to start your web server, open a new one now and navigate to the root of the application.
\two_table>
Execute the following command from your command prompt.
\two_table> hobo g resource country name:string
Check the models directory and you should see a country.rb file with the following contents defining the Country name field.
class Country < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end
If you look in the db/schema file, however, you will not see a countries table because you have not run the migration yet. Let’s define our relationships now.
The hobo:resource generator also created some other files. An important one is the controller file called countries_controller.rb. Note that the class names (how Hobo refers to them) are CountriesController for the controller and Country for the model, which you can see, in the first line of code in the respective files. 
Note: The controller has a file and class name that is the plural of the model name. The file names use underscores in the file names and removes them for class names. 
6.	Remove a field. In preparation for setting up a relationship between the Recipe and Country models, you must delete the country field in the Recipe model. It will not be needed any more since it is replaced by the name field in the Country model. 
Open the recipe.rb model file and delete the country field from the fields…do block at the beginning of the file. So you can see what you have done, it would easiest to comment it out. Change this:
…
  fields do
    title   :string
    body    :text
   # country enum_string (:American, :French, :Chinese)
    timestamps
  end
…
7.   Add a  belongs_to relationship. The Recipe model will have what is called a belongs_to relationship with the new Country model. This relationship or association requires that every recipe have at the most one country associated with it. Add the belongs_to declaration just before the #permissions comment.  Any belongs_to declarations must be added after the fields…do block. 
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    title   :string
    body    :text
   # country enum_string (:American, :French, :Chinese)
    timestamps
  end
  
  belongs_to :country 

  validates_presence_of :country
…

	We have also added validation so that the country is always specified for all recipes.

Note: It is useful to read belongs_to as ‘refers to’ to remind yourself that when this relationship is declared, it causes the creation of a key field named country_id in the recipes table to “refer to” the country table, which contains the name field.

In the above belongs_to statement, :country is the name of a relationship. It is not the name of a field. Through its naming conventions, Hobo determines that the model to relate to is named Country. For the case when naming conventions fail, you can force the relationship as in the following code:

  belongs_to :country, :class_name=>"Some_other_model"
8.   Add a  has_many relationship. The Country model needs the inverse relationship to the belongs_to in the Recipe model:. 
class Country < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end
 
 has_many :recipes
...
When you learn to do more sophisticated programming, this feature of naming relationships, which Hobo inherits from Rails, will become a powerful tool. Unlike standard relational database relationships, this capability essentially adds meaning to the relationship.
9. Run the Hobo migration. Now you have done everything needed for Hobo’s intelligence to take over and create the new countries table and set up the proper foreign keys.
Now, go to your command prompt and run the Hobo migration. By doing this you will allow Hobo to accomplish several things. Hobo will: 
Create the migration file for the new table, countries
Remove the country field from the recipes table
Set up a foreign key to handle the relationship between Recipe and Country
Execute the migration to create the new database table, Countries. 
For every recipe record with a country entered, there will now be a country_id value written in the recipestable that corresponds to a country_id in a country record.
\two_table> hobo g migration
You will get the following response:
DROP or RENAME?: column recipes.country
Rename choices: country_id
Enter either 'drop country' or one of the rename choices:
Hobo has noticed that there is an ambiguity you have created that needs to be resolved. There is both a country field and a Country model. It knows you need a foreign key, country_id, to relate to the Countries table. So it gives you a choice to rename country to country_id or drop the country field and create a new country_id field. Since country has real country names in it, not foreign key integer values, it is best to drop it and let Hobo create a new field for the foreign key. 
Enter ‘drop country’ (without quotation marks) in response. 
Next the migration will respond as follows:
What now: [g]enerate migration, generate and [m]igrate now or [c]ancel?
You should type ‘m’.
Last it will prompt you to name the migration file:
Filename [hobo_migration_3]:
Just hit the ‘enter’ key and it will take the default name, hobo_migration_3.
10.  Review the results of your migration. Let’s take a look at the database schema in db/schema.rb:
ActiveRecord::Schema.define(:version => 20100313165708) do

  create_table "countries", :force => true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  create_table "recipes", :force => true do |t|
    t.string   "title"
    t.text     "body"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.integer  "country_id"
  end

  add_index "recipes", ["country_id"], :name => "index_recipes_on_country_id"

  create_table "users", :force => true do |t|
    t.string   "crypted_password",          :limit => 40
    t.string   "salt",                      :limit => 40
    t.string   "remember_token"
    t.datetime "remember_token_expires_at"
    t.string   "name"
    t.string   "email_address"
    t.boolean  "administrator",                           :default => false
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "state",                                   :default => "active"
    t.datetime "key_timestamp"
  end

  add_index "users", ["state"], :name => "index_users_on_state"

end


Note: Hobo automatically creates appropriate indexes for table relationships with foreign keys.  We will discuss how to enhance or disable this feature in a later tutorial.

11. 	Double-check the tab code before refreshing your browser. Back in Tutorial 6 #7, we asked you to delete the <navigation> tag. Go back there and make sure you completed that step before refreshing your browser. You should see a new tab for Countries.  
12.  Review a few features of the UI. Make sure you are signed in as the admin. Go to the Countries tab and click through to enter a few countries. 



Then go to the Recipes tab and click through to edit one of your recipes. You should now see a drop down box just as you saw when you used the enum_string option for your attribute:


The difference is that you are now actually selecting a country_id foreign key behind the scenes. Hobo takes care of querying the  countries table (Country model) and displaying the actual country names. When you save this Recipe record, Hobo maintains all of the necessary related keys automatically.
After you do the save, note that the Country value in the page is an active hyperlink:
. 
	
If you click it, you will see a screen that allows you to edit the Country record.


You can edit a country record because you are logged in as the “administrator”. If you check the countries.rb file, you will see that the permission to edit the Country field is limited to the administrator. This means that if you log in as a regular user, Hobo should not allow the edit. Log out from the administrator account and login as regular user.
class Country < ActiveRecord::Base

. . .
  # --- Permissions --- #

  def create_permitted?
    acting_user.administrator?
  end

  def update_permitted?
    acting_user.administrator?
  end

. . . 
Now go to the Recipes tab, click on a recipe link and edit the recipe. Next click on the country name on the page. Now you see that the Edit Country link is no longer available. 


12.	One-to-many relationship discussion. The relationship or association that you have just implemented is known as a one-to-many relationship. In this particular situation, we have an individual country that is related to many recipes. More specifically, there is one record in the Countries table with the name ‘American,’ but potentially many American recipes.
Tutorial 8 – Model Relationships: Part II

In this tutorial you will learn to implement many-to-many relationships. These relationships are useful, for example, in categorizing a model’s records. You will implement the relationship using the “has_many”, “has_many =>:through”, and “belongs_to” relationship declarations of Rails. You will learn how Hobo establishes a direct relationship between model relationships and the features of the UI.

In terms of our tutorial application, you will be adding recipe categories so that you can categorize recipes as, for example sweet, sour, or hot. You will implement an architecture where it is easy to invert the relationships so that you can display both which categories a recipe belongs to and which recipes are classified in a particular category. 
PREREQUISITES: Tutorials 1-6.
Topics
Many-to-many relationships
Using the has_many, has_many =>:through, and belongs_to rails relationship declarations
Fixing a UI assumption by Hobo when it is not the optimum.

Tutorial Application: four_table
Steps
1.	Copy the Application. Just like you did in Tutorial 7, we suggest you copy your application from Tutorial 7 in order to easily go back to its state at the end of that tutorial. Shut down the web server by issuing a <Control-C> in the command window where you issued the rails server command. 
Then, do a copy in whatever operating system you are using. We have called the new application directory four_table. Navigate to the new directory. Restart the web server and you are ready to go.
\four_table> rails server
You may wish to change the name of your application as displayed in the UI. Go to config/application.rb.  Change the key config.hobo.app_name to read:
config.hobo.app_name = "Four Table" 
Now refresh your browser and you will see the new name.
2. Create the models. We are going to add two new models to our original application and keep the original Recipe and Country models. The first will be a Category model and the second will be a CategoryAssignment model. 
CategoryAssignment will have the two fields, category_id and recipe_id that correspond to keys of the same name in the Category and Recipe models.
Note: If you review the schema in the app/db directory, you will not see these fields listed in the Categories and Recipes table. They are the default keys for these tables. Rails does not list them.
As you will see shortly, you do not have to worry about creating or naming any of these fields, the Hobo generators will take care of it all for you.
Go to your command prompt and issue the following two commands:
\four_table> hobo g resource category name:string
\four_table> hobo g model category_assignment 
The first command will create both a controller and model, Category being the name of the model. The second will create a CategoryAssignment model but no controller. 
When you implement the relationships below, you will see that CategoryAssignment sits in between the Recipe and Category models. You do not need a CategoryAssignments controller because you will be accessing recipes and categories through these models directly and need no actions that pull data directly from the intermediary CategoryAssignment model.
3.	Add relationships to your models. Edit the models as shown below to enter model relationships. 
Note: Hobo migrations rely on both the field declarations in your models AND the relationship declarations. The relationship declarations allows Hobo to setup all the necessary keys to implement real model relationships.
recipe.rb
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    title   :string
    body    :text
    #country :string
    timestamps
  end
  belongs_to :country
  has_many :categories, :through => :category_assignments,  :accessible => true
  has_many :category_assignments, :dependent => :destroy
 


category.rb
class Category < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end

  has_many :recipes, :through => :category_assignments
  has_many :category_assignments, :dependent => :destroy
category_assignment.rb 
class CategoryAssignment < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    timestamps
  end

 belongs_to  :category 
 belongs_to  :recipe
4.	Discussion of model relationships. Note above that you used the has_many and the belongs_to relationships. You further used a has_many relationship with a :through option.
Let’s start with the belongs_to relationship, which we used in Tutorial 7 and declared in the CategoryAssignment model above.
Recall that when you see belongs_to, think refers to, and you will understand that these declarations cause the category_id and recipe_id fields to be placed in the category_assignments table.
The has_many :through statements instructs Hobo/Rails to setup the necessary functions to access a category from a recipe or a recipe from a category. The vanilla has_many statements set up the one to many relationships between the recipes table and the category_assignments tables and between the categories and category_assignments tables.
The :dependent => destroy option makes sure that when either a recipe or category is deleted that the corresponding records in the category_assignments table are removed automatically too. 
5.	Run the hobo g migration. Go to your command prompt and run the following.
\four_table> hobo g migration
Remember to respond ‘m’ when prompted for migration and just press <enter> when prompted with the migration file name.
Note: At this point, if your web server is still running from earlier tutorials, you need to terminate it and restart it. Rails and Hobo will not recognize a new database table without doing so.

\four_table> rails server
6.	Populate the new table. Open up your browser to http://localhost:3000/ and you should see the following (since you had copied over all the files from the Two Table application, your database came with you so you will not see the Register Administrator form):


Now go to the new Categories tab and enter in some food categories:


7.	Adding new records to the relationships. Go to the Recipes tab. Click on one of the recipes and you should get this.


Notice there is no category assignment.
Then click Edit Recipe on the right.


Now you can see a new drop-down box that lets you add categories to your recipe. Hobo has taken care of this for you by inferring that you need it from your model relationship declarations.
Note: Here is a good example of the DRY (Don’t Repeat Yourself) notion playing out. If the necessary UI controls can be directly inferred from model structure, there should be no need to directly code it yourself. You may wish to use a different control but Hobo picks a reasonable one for you so you do not have to bother unless you want to.
Take a look at the URL that activated the page. You will see that the URL is of the form for a “controller edit” action. If you need to remind yourself of the form look at the Hobo Controller Action Summary figure in Tutorial 5 step 6.
Try adding a couple of categories and save the changes. 


Here, on the Edit Recipe screen, you can see that Hobo is displaying the entries for the Recipe categories you have chosen to associate with the recipe, namely hot and sour. So far, Hobo is doing just what we would expect.
8.	Add information to the model in order to display the associations. Hobo, before version 1.3, used ViewHints to indicate to the application how you would like to display related information on a model’s show page.  To simplify things, this functionality has been moved into the model itself and ViewHints are no longer used as of Hobo 1.3.  So now you modify the ActiveRecord model itself.  
Edit the app/models/recipe.rb file.  Enter the code (in bold italics below) to tell Hobo explicitly to use categories as the child of recipes in its displays.
class Recipe < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name   :string
    body    :text
    timestamps
  end

  belongs_to :country
  has_many :categories, :through => :category_assignments,  :accessible => true
  has_many :category_assignments, :dependent => :destroy

  children :categories

  [ ... ]

Now edit country.rb:

class Country < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end

  has_many :recipes
  
  children :recipes

  [ ... ]

Now refresh your browser and choose a recipe to view:


If you wish to see all the recipes, which are ‘hot’, you would click on ‘hot’ to check this out; or you could go to ‘Categories’ and then click on ‘hot’.


Now let’s enhance this view. Edit  app/models/category.rb: 
Enter the code (in italics and bold below) to tell Hobo explicitly to use recipes as the child of categories in its displays.
class Category < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end

  has_many :recipes, :through => :category_assignments
  has_many :category_assignments, :dependent => :destroy
  
  children :recipes

  [ ... ]
Refresh your browser.


Now you can see all of the “children” of the category “Hot” on the Category “show” page.

9.	Comments on the many-to-many relationship. Now let’s review how you got this all to work. The end product is that you can see the categories associated with each recipe and the recipes associated with each category. 
In each case you can click through to look at individual categories or recipes and edit them if you wish.
All of this is a result of having a recipe model related to a category_assignment model, which is, in turn, related to the category, model and vice versa. We will call the category_assignment model the intermediary model and the other two, “outer” models.
You have created a symmetrical set of model relationships where the two outer models have has_many relationships with the intermediary model and has_many :through relationships with each other. Conversely, the intermediary model has a belongs_to relationship with each of the outer models. 

This structure will be used frequently in most data-rich applications. It is worth noting how you need only a few lines of code to implement this structure and how it lets you access each outer model from the other.
CHAPTER 4 – INTERMEDIATE TUTORIALS

Introductory Concepts and Comments
Tutorial 9 - Editing Auto-Generated Tag
Tutorial 10 - DRYML I:  A First Look at DRYML 
Tutorial 11 - DRYML
Tutorial 12 - Rapid, DRYML
Tutorial 13 - Listing Data in Table Form
Tutorial 14 - Working with the Show Page 
Tutorial 15 - New and Edit Pages With The Form Tag 
Tutorial 16 - The <a> Tag Hyperlink



	

Introductory Concepts and Comments

In Chapter 3 we deliberately focused on helping you get something done without spending much time looking under the hood--or should we say--behind the “Magic Curtain.” 
When Jeff and I first discovered Hobo, we were impressed by what seemed like little magic tricks that Tom had Hobo perform for us:  dynamic AJAX without coding; automatic page flow; automatic checking and executing changes to the database when declarations change; built-in permissions system and data lifecycles; high-level declarative markup language: you can do so much that looks and acts great.
Of course, there will ALWAYS be something you need to do that doesn’t come ready-made out-of-the-box. So--just like learning magic tricks--you can learn how Hobo works and create some new magic tricks of your own to impress and help your clients in Rapid time.
No magician worth his salt will reveal his tricks to an apprentice all at once.  There is only so much we can absorb at one time. The trick to learning--as well as developing software--is to do it incrementally. Get grounded at each step. Most magic tricks use the same knowledge of human perception, habits and expectations to create the illusions.  
Learning one trick helps you learn another faster. Then you learn the patterns.  And after that, you learn to make more patterns that you and others can use again and again.
So, in this chapter we will start revealing how “Rapid” (Hobo’s process of automatically rendering forms, views and routing) works in a way we think it can best be absorbed.
One of the ways is to examine the code that the author has written that runs the application itself.  In the early versions of Hobo, the rendering of pages, forms, and navigation flow was done “auto-magically” by Rapid.  You couldn’t see how it worked until version  0.8.0.  It was in this release that Tom Locke made visible the DRYML code that was being executed in the background, invisibly.
So now you can look, learn, and copy the DRYML that “Rapid” actually uses to generate Pages, Cards, Forms and the Main Navigation Menu.
Take a close look at \apps\views\taglibs\auto\rapid folder of any of your Hobo apps:


Notice that there are three DRYML files: cards.dryml, forms.dryml, and pages.dryml. These files include the DRYML XML-like formatted tags that are the declarative statements used as templates to render web page views and forms. They provide the logic to render a combination of HTML, JavaScript, and CSS code when needed.
DRYML provides a high-level of abstraction for formatting web pages and dealing with all aspects of data-driven applications.  Listing, displaying, creating, editing and deleting records are simplified without the necessity of specifying the granular level of detail that other frameworks require, such as Rails with its ERB (embedded Ruby) pages that are a hybrid of Ruby and HTML.
In this chapter we will explore:
(1) The Hobo Rapid library of tags
(2)  The auto-generated DRYML files that expose the Rapid process
(3)  User-defined tags that you can use to extend Hobo
Hobo Rapid Library of Tags. Hobo comes with a pre-coded set of tags that you can use to build other tags. It provides tags to handle forms, display collections of records, and render a table of records. Hobo uses these to build the Rapid default web pages.  You will learn to use some of the more common Rapid tags in this chapter.

Auto-generated DRYML. These DRYML files are saved replicas of Hobo’s way of coding the view associated with all of the web site actions. For example, there is a <show-page> tag involved with displaying a single record, and <index-page> tag to display a list of records, and a <new-page> tag involved with generating the form to accept the data for a new record.

User-defined Tags. In order to create your own tags, Hobo provides tag definition language elements. You can build custom tags that include HTML, DRYML tags defined in Hobo’s Rapid library, and even imbedded custom Ruby code. There is great flexibility. The end result can be simple tag that you use in a Hobo view template to include in the definition of a web page.
Tutorial 9 – Editing Auto-Generated Tags 

In this tutorial, you will learn about Hobo’s auto-generated tags that render views in response to controller actions. You will find your way around Hobo’s Rapid directories and files where the auto-generated tags are stored. You will also learn how to make minor edits to the auto-generated tags to prepare you for making tags from tags and redefining tags in later tutorials.
Hobo’s Rapid component handles the generation of an application’s auto-generated tags. The auto-generated tags are built from both HTML and Hobo’s internal library of XML tags called the Rapid Library.
The most important lesson you will learn in this tutorial is how Hobo associates its fundamental auto-generated tags with the four fundamental controller actions: 
index for listing collections of records
show for displaying a single record
new for creating records
edit for editing a single record
The other fundamental actions of saving new and edited records and deleting records are embedded within these fundamental tags as links because they do not need their own web pages. In addition to these four main tags, there is also a navigation tag that defines certain parts of the navigation interface.
Topics
Edit an index page tag
Edit a card tag
Edit a form tag
Edit the Navigation tags 

Tutorial Application: four_table
	
Steps
1.	Start your web server. We are going to continue on from Chapter 3 and use the four_table application. If you don’t have it started, navigate to your four_table directory, in tutorials/four_table, and start the application.

\four_table> rails server
You should now have a UI that looks like this:


Now open your editor and navigate to the views/taglibs/auto/rapid directory:

Figure 92: Folder view of the rapid DRYML files
Take a look at this directory structure. Focus on the files in the views/taglibs/auto/rapid directory. The Rapid auto-generated tags are stored in these files. Hobo updates the three Rapid directory files, pages.dryml, forms.dryml and cards.dryml every time you run a hobo g migration. Don’t edit these files because Hobo will overwrite them.  You can copy and paste pieces, and therefore override them, with code placed in either the application.dryml file or in a template file in a view directory named for a specific model, e.g., views/recipes. This will be explained below in this tutorial.
2.	Familiarize yourself with the Rapid auto-generated files. Let’s look at the pages.dryml file first. Open up the views/taglibs/auto/rapid/pages.dryml file. You will see a series of tag definitions. Look through the file. Notice that there is a Main Navigation section, a Recipes section and a Users section.  There are also sections  related to the app’s other models.
We will be talking about the Recipes and Navigation section in this tutorial.
Open up the forms.dryml and cards.dryml files and page through them. You will see similar structures. You will see a section describing Recipes and the other models we have built so far.
Now that you have familiarized yourself with the three Rapid auto-generated tag files, go back to the pages.dryml file. 
3.	Understanding the pages.dryml file. We are not going to explain every detail about what you see in pages.dryml at this point. In subsequent tutorials in this chapter, you will learn most of the key points. The goal in this tutorial is to get some familiarity with the tag structures and how Hobo uses and overrides them. 
Now focus in on the Recipes section. You will see four tag definitions: <index-page>, <show-page>, <new-page> and <edit-page>:

<!-- ====== Recipe Pages ====== -->

<def tag="index-page" for="Recipe"> . . . 
</def>

<def tag="new-page" for="Recipe"> . . .
</def>

<def tag="show-page" for="Recipe"> . . .
</def>

<def tag="edit-page" for="Recipe"> . . .
</def>

The following table explains what each of these does. Rapid automatically creates this set of four tags for each model in your application.
Tag
Meaning
Calls
Controller Action
Route (URL)
<index-page>
renders a list of model records
Cards
index
*/model_name(plural)
<new-page>
renders a data entry page for a new record.
Forms
new
*/model_name/new
<show-page>
renders a single record.
None
show
*/model_name/ID-record_name
<edit-page>
renders a data entry page for an existing record.
Forms
edit
*/model_name/edit/ID-record_name
Figure 93: Hobo Page Action Tag definitions
You cannot see it explicitly in the pages.dryml file, but the <index-page> tag calls the Recipe <card> tag. We will demonstrate this by editing them shortly. The <new-page> and <edit-page> tags call the Recipe <form> tags. 
These auto-generated tags, each of the four tags above as well as the <form> and <card> tags, are built from tags defined in the Rapid library of tags. The four page tags are built from the Rapid <page> tag, the form tag from the Rapid <form> tag and the card tag from the Rapid <card> tag. 
You might be confused at first because the auto-generated tags <form> and <card> have the same names as the Rapid auto-generated tags. What Hobo is really doing is redefining these tags and using the same tag name in the redefined tag.
The last important point to realize is that there is a one-to-one association between these four tags and both controller actions and their associated routes. Routes are the URLs related to the web pages resulting from a particular controller action. Hobo automatically defines the routes, although they can be user-defined and customized too. 
The controller action can be executed by navigating to the browser route URL listed in the figure at the top of this page.
Note:  The asterisk (*) refers to the route URL for your app, which is usually http://localhost:3000 for Ruby on Rails development setups.
4.	Edit the index page (method 1). Open up the pages.dryml file and look at the <index-page> tag definition. Here is what it looks like:


You invoke the index action by clicking on a tab with a particular model name, which is Recipes in this example. Go ahead and click the Recipes tab to remind yourself where you left off in Tutorial 6 of Chapter 3: 


Note that the URL that generates the “Recipes Index” page, http://localhost:3000/recipes, has the form of an index action. (Refer to the Hobo Page Action Tag definitions figure earlier in this tutorial.) You can see three lines of text in the body of the tab beginning with the ‘Recipes’ title, then ‘There are 3 Recipes’, a ‘New Recipe’ hyperlink, and finally the list of recipes. 
There are three levels of overriding. Hobo handles these by checking sequentially in three directories for the tags or tag definitions it will use to render a view template.
The first place Hobo looks to find the information it needs to render a view template corresponding to a particular model is the /views directory corresponding to that model. 
Note: Prior to Hobo 1.3, a view folder for each generated model was created.  This is no longer the case. In the figure below, the categories, countries, and recipes folders were created manually.
In this case, note that /views/recipes is empty.


The next place Hobo goes is the views/taglibs/application.dryml file. The last place Hobo goes is the views/taglibs/auto/rapid/pages.dryml file. 
You are going to put the recipe index tag definition in application.dryml causing Hobo to use level 2. So take the code above from pages.dryml beginning with 
<def tag="index-page" for="Recipe">
and paste it into /views/taglibs/application.dryml file. Paste it below the following code in views/taglibs/application.dryml file.
<include src="rapid" plugin="hobo"/>

<include src="taglibs/auto/rapid/cards"/>
<include src="taglibs/auto/rapid/pages"/>
<include src="taglibs/auto/rapid/forms"/>

<set-theme name="clean"/>
<def tag="index-page" for="Recipe">
. . . 

	The line in bold italics above is the first line from your copied code.


Note: As you learn Hobo you might get confused between tag definitions and tags. This is often the case because Hobo does not need you to specifically invoke the tags that are defined in the Rapid files (pages.dryml,forms.dryml etc…) or in the application.dryml file. If the tags have the default names “index”, “new”,” show”, or “edit”, then Hobo creates the template on the fly. You do not have to put tag code in a template yourself unless you do not want to use Hobo’s default template.
First, refresh your browser to confirm that the UI has not changed. Simply copying a tag definition from pages.dryml to application.dryml with no changes to the tag definition should not change the page rendering. It is a good idea to double check in case you copied something wrong so you won’t confuse a copy mistake with a coding mistake.
Let’s make a minor change to convince you that this is what is happening. Note that the line in bold italics below is what has changed.

<def tag="index-page" for="Recipe">
  <page merge title="#{ht 'recipe.index.title', :default=>[model.model_name.human(:count=>100)] }">
    <body: class="index-page recipe" param/>

    <content: param>
      <header param="content-header">
        <h2 param="heading">
          My Recipes
        </h2>

        <p param="count" if>
          <ht key="recipe.collection.count" count="&this.size">
            <count summary/>
          </ht>
        </p>
      </header>

      <section param="content-body">
        <a action="new" to="&model" param="new-link">
          <ht key="recipe.actions.new">New Recipe</ht>
        </a>

        <page-nav param="top-page-nav"/>

        <collection param/>

        <page-nav param="bottom-page-nav"/>


      </section>
    </content:>
  </page>
</def>
Now refresh your browser and you will see that Hobo has changed the template it generated dynamically:


Figure 98: Page view of "My Recipes" after modifying the <index-page> tag
You should see that the first line of the page has changed from “Recipes” to “My Recipes”.
Let us describe what happened. 
Step 1: Hobo looked for a template in the views/recipes/ directory called index.dryml. 
Step 2: Since views/recipes/index.dryml did not exist, Hobo next looked in views/taglib/application.dryml where it found the tag definition for the index page.
Step 3: Hobo used this tag definition to generate the contents of the “index” page.
5.	Change the index page(method 2). If you want to change the index page directly, you can create a new file in the views/recipes directory called index.dryml.
	We haven’t given you enough information for you to build your own index.dryml template using Hobo’s tag library yet.  We said above that Hobo will look there first for a page to render when the index action is invoked. 
So if you place an empty file here, you get a blank page rendered. Go ahead and create a file called index.dryml in the views/recipes directory. Confirm for yourself that you get a blank page.
Now let’s do something a little more useful. Add the single line of code below to the index.dryml file: 
<index-page/> 


Note: The Hobo tag syntax is just like you would expect from HTML or XML. The code <index-page/> is equivalent to <index-page></index-page>. Watch your placement of “/”. It was our most frequent error when we started with DRYML.
Now refresh your browser and you will see the same page rendered as in Step 4. What has happened is that Hobo has checked in the views/recipes directory for a file called index.dryml, found one and rendered it. When it encountered the <index-page/> tag, it first checked in index.dryml for a tag definition. Not finding one there, it checked in application.dryml where it found one to use in rendering the <index-page/> tag in index.dryml. If it had not found a tag definition in application.dryml, Hobo would have gone back to pages.dryml for the default <index-page> definition.
Note: You can put a tag definition in either a view template file or in application.dryml but Hobo will ignore tags in application.dryml. The application.dryml file is for tag definitions only. 
6.	Edit an individual record’s view in the index page. By now, you should have entered a couple of recipes. Be sure to do that if you have not.
In Table 1 above, we indicated that the <index-page> tag calls <card> tags to render individual records. We can demonstrate this process by changing a <card> tag. Go to the cards.dryml file in the rapid directory and copy the <card> definition for recipe cards into the application.dryml file below the <index-page> definition. Hobo will now use this version of the <card> tag when it uses the  <index-page>.

<def tag="card" for="Recipe">
	 <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a></h4>
    </header:>
    <body: param>
      <ht key="category.collection.count" count="&this.categories.size">
         <count:categories param/>
      </ht>
    </body:>
  </card>
</def>
Again, we will not explain the detailed syntax of this tag yet. Let’s just make a simple change (in bold italics below) to demonstrate how Hobo works:
<def tag="card" for="Recipe">
	 <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a>…test</h4>
    </header:>
    <body: param>
      <ht key="category.collection.count" count="&this.categories.size">
         <count:categories param/>
      </ht>
    </body:>
  </card>
</def>
Now refresh your browser. Click the ‘Recipes’ tab to invoke the index action using the <index-page> tag.

Figure 100: How a change to the <index-page> tag affects a collection
You see how each record displayed has been changed. You didn’t need to iterate through a loop. Iterating through all records in a collection is built in to Hobo’s tag processing. If you look back to Step 4 to see the <index-page> tag definition, you will see the following line:
<collection param/>
It is here that the <card> tag is called. The <collection> tag refers to a collection of records from a data model. 
Now click on one of the recipe name hyperlinks, which will invoke the <show-page> tag in pages.dryml. Since you haven’t changed this tag and since it does not use the <card> tag, you will NOT see ‘....test’ appended to recipe names as you do when Hobo lists recipes using the <index-page> tag.
To finish up this step, remove the text ‘....test’ to keep things looking nice. 
6.	Editing a form. To modify a form, you can do something similar to editing the <card> tag above. In this case, the relevant page tag is the <new-page> tag in pages.dryml. It calls the <form> tag. You can see that in the forms.dryml file. 
7.	Editing navigation tabs and their order. As you have seen, Hobo provides a predefined tab-based user interface. By default, it arranges the tabs alphabetically by model. This is probably not what you want. You more than likely want to set up an order that makes sense for your application.
This is readily done. Find the <main-nav> tag definition in the pages.dryml file and copy it into application.dryml right after the <app-name> tag definition.
<def tag="main-nav">
  <navigation class="main-nav" merge-attrs param="default">
    <nav-item href="#{base_url}/">Home</nav-item>
    <nav-item with="&Category"><ht key="category.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
    <nav-item with="&Country"><ht key="country.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
    <nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
  </navigation>
</def>
Now let’s change the order of the tabs in your UI. Change the order of your tabs by moving the Recipes tab up to the position noted below in bold italics.
<def tag="main-nav">
  <navigation class="main-nav" merge-attrs param="default">
    <nav-item href="#{base_url}/">Home</nav-item>
	   <nav-item with="&Recipe"><ht key="recipe.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
    <nav-item with="&Category"><ht key="category.nav_item" count="100"><model-name-human count="100"/></ht></nav-item>
    <nav-item with="&Country"><ht key="country.nav_item" count="100"><model-name-human count="100"/></ht></nav-item> 
  </navigation>
</def>

Now refresh your browser and you will see the new tab order:


8.	Editing an application name. If you want to change the name of the application that appears on all the UI web pages, you can do this easily also. The config.hobo.app_name key is found in the config/application.rb file and can be edited to change the application name.  Make the following change, then restart the application, and then refresh your browser:
config.hobo.app_name = "Four Tables, No Waiting"	


9.  Summary. The Hobo Rapid generator creates tag definitions and places them in the files of the Rapid directory. The programmer overrides, redefines, and defines new tags in application.dryml. These definitions are available throughout the application. So far, you have just learned how to override tags.
There are no tag calls in application.dryml except within a tag definition because application.dryml is NOT a template file (see it as a library file). The programmer invokes--that is--calls tags in template files placed in the view/<model_name> directories. 
The programmer may also override, redefine, or define a new tag within a template, but this modification is local (e.g., only available within that template).

Note: A new feature of Hobo 1.3 is that application tag definitions can be organized into multiple dryml files as long as they reside in the app/views/application directory.

So instead of having one large application.dryml file, you can organize your application specific tag definitions into multiple files and place them in the app/views/application directory.
Tutorial 10 – DRYML I:  A First Look at DRYML

You will be introduced to the concept of a user-defined tag, called a DRYML tag. The tutorial shows you how to make minor changes to the home page template by defining DRYML tags. You will also learn how to parameterize tags with the DRYML parameter attribute, param.
Note: Be sure not to confuse the DRYML param with the Rails params object. 
Topics
Define a DRYML tag in the front/index.dryml template
Call the DRYML tag in the front/index.dryml template
Add a parameter to the DRYML tag
Add an attribute to the DRYML tag
Tutorial Application: four_table
Steps
1.	Define a tag.  Open up the views/front/index.dryml file of the four_table application. This is Hobo’s home page.
At the top of the file enter the following code. The <def> tag below is Hobo’s DRYML tag for defining a custom tag. The code below defines a <messages> tag.
<def tag="messages">
	<br/><br/>
	<ul>
		<li >Message 1</li>
		<li >Message 2</li>
		<li >Message 3</li>
	</ul>
</def>
The entire markup between the <def> tags is standard HTML. When called, this <messages> tag will emit a three-line list.
2.	Call the tag. Go to the line that reads:
<h3>Congratulations! Your Hobo Rails App is up and running</h3>
Add a line after this one so that it reads:
<h3>Congratulations! Your Hobo Rails App is up and running</h3>
<messages/>

Note: The correct syntax is to place the forward slash after the tag name when you use the tag as a single tag rather than in the form of an opening and closing tag with no content in between.


Then refresh your browser:



One of the things that is different from Tutorial 1, is that you are now working both with a DRYML tag definition and with a DRYML tag. In the previous tutorial, you edited the tag definitions but you did not invoke a tag such as <index-page> explicitly.
Hobo took care of invoking the tags for you on-the-fly. Since Hobo’s Rapid component knows what the basic structure of a data driven web page is, it does not require you to code the template explicitly except when you want something different than the Hobo default.
In this tutorial you will be defining new tags unknown to Hobo, so you of course must invoke them explicitly.
3.	Parameterize the tag. Change the following code in the <messages> tag definition from:
		<li >Message 1</li>
		<li >Message 2</li>
		<li >Message 3</li>
	to:
		<li param="msg1">Message 1</li>
		<li param="msg2">Message 2</li>
		<li param="msg3">Message 3</li>
You have now created three parameters, which can be invoked in the following way:
<msg1:>message text</msg1:> 
<msg1:> is called a parameter tag. 
Note: The colon (:) suffix indicates that the tag is a defined parameter tag. Later you will learn that some parameter tags are defined for you in the Rapid library.
4.	Use a parameter. Let’s invoke the <messages> tag but change the third message by addressing the <msg3:> parameter tag.
<h3>Congratulations! Your Hobo Rails App is up and running</h3>
<messages>
	<msg3:>This is the third message passed as a parameter.</msg3>
</messages>
The first two lines will remain the same while the third changes due to the use of the <msg3:> parameter tag. You have used a tag to pass data from the <msg3:> parameter tag into the <messages> tag.




5. Use some more parameters. Change the other two message lines likewise to:
<messages>
	<msg1:>This is the first message called as a parameter</msg1>
	<msg2:>This is the second message called as a parameter.</msg2>
	<msg3:>This is the third message called as a parameter.</msg3>
</messages>
and you should see:


6. Reverse the order of the parameter call. Now try the following code.
<messages>
	<msg2:>This is the second message.</msg2:>
	<msg1:>This is the first message.</msg1:>
	<msg3:>This is the third message.</msg3:>
<messages>
You will see that this edit will not change the order of the list because the order is defined by the tag definition not by its call. The tag calls the messages in the order set in the tag definition, namely <msg1:>, then <msg2:> and then <msg3:>.
7.	Create an html-like tag using param = ”default”. In the preceding steps, you learned how to reach into a tag with three parameter tags and change the default message text of the defined <messages> tag. Next you will emulate a regular HTML formatting tag using the param=”default” attribute.
Note: We have referred to an attribute above rather than a parameter because a change will be made by setting param to a value rather than by using a parameter tag.
Go back to the top of the views/front/index.dryml file and enter the following code after the first <def> . . . </def> tags. 
<def tag="bd-it">
	<br/>
	<b><i><span param>stuff</span></i></b>
</def>
Here we have redefined the HTML <span> tag to format the tag content with bold AND italic formatting. Since the <span> tag is now parameterized, you can now replace the ‘stuff’ continent with something you might want to format.
Call the <bd-it> tag right after the closing </messages> tag without using the <span:> parameter. This will demonstrate that the tag will just emit the formatted default word stuff.
<messages>
	<msg2:>This is the second message.</msg2:>
	<msg1:>This is the first message.</msg1:>
	<msg3:>This is the third message.</msg3:>
</messages>
<bd-it/>


If you use the <span:> parameter tag, you will format your content. 
<bd-it/>	
<bd-it><span:>More stuff</span:></bd-it>

	
But the second line is a kind of clumsy looking way to get: More stuff. Instead, change your <def> code to:
<def tag="bd-it">
<br/>
<b><i><span param="default">stuff</span></i></b>
</def>
The param=”default” text is saying is that the <span:> parameter is automatically assumed when you call the <bd-it> tag. You do not have to explicitly call it. Now change your call to:
<bd-it/>	
<bd-it>More Stuff</bd-it>

So now you have created a DRYML tag that looks just like an HTML tag. 
Note: Once you change the <span:> parameter to the default parameter, Hobo will ignore explicit uses of it and only emit the default content if you call it explicitly. Once you use the default parameter attribute you are committed to the more compact notation. There can only be one “default” parameter in a tag definition.
The entire /views/front/index.dryml contents at the end of this tutorial is as follows:
<def tag="messages">
	<br/><br/>
	<ul>
		<li param="msg1">Message 1</li>
		<li param="msg2">Message 2</li>
		<li param="msg3">Message 3</li>
	</ul>
</def>

<def tag="bd-it">
    <br/>
    <b><i><span param="default">stuff</span></i></b>
</def>

<page title="Home">
	<body: class="front-page"/>
   <content:>
    <header class="content-header">
      <h1>Welcome to <app-name/></h1>
      <section class="welcome-message">
        <h3>Congratulations! Your Hobo Rails App is up and running</h3>
         <messages>
          <msg2:>This is the seond message.</msg2>
          <msg1:>This is the first messsage.</msg1>
          <msg3:>This is the third message passed as a parameter.</msg3>
         </messages>
         <bd-it/>
         <bd-it>More stuff</bd-it>
	  </section>
    </header>
    <section class="content-body">
    </section>
  </content:>
</page>

Tutorial 11 – DRYML II: Creating Tags from Tags

You will go to the next step in your understanding of DRYML. You will learn how to define tags from other tags. Specifically, you will learn how to create new tags that inherit parameters from the tags they are based on.
Tutorial Application: four_table
Topics
Defining tags from tags using the merge tag
Defining tags from tags using the extend tag
Replacing tag parameters (not tag content)
1.	Define a tag based on another tag: Method 1. In Tutorial 10, you learned how to define a tag called <messages> that output three lines of HTML. Now you will define a new tag based on <messages> called <more-messages>. Place the following code below the <messages> tag definition. (The order of tag definitions does not matter. This was just a recommendation for neatness.) 
<def tag="more-messages">
	<messages merge>
		<msg2: param>Message 2 Changed</msg2:>
	</messages>
</def>
What you have done here is to edit the <msg2:> parameter tag of the <messages> tag so that it has different default content. By using the merge attribute, you have told Hobo to use everything from the <messages> tag except for the change. Now let’s invoke this tag. Place the following code below your last code from the previous tutorial.
<more-messages/>
		

Refresh your browser to see the change the below. 


Note: Later in this Chapter you will also learn how to add attributes to tags in addition to parameters. Merge means merge parameters AND attributes.
Remember that the text, ‘Message 1’ and ‘Message 3’ is the default text from the <messages> tag.
2. Define a tag based on another tag: Method 2. In the last example, you learned how to define a new tag based on an old tag. The new tag is defined with a new name, <more-messages>. You cannot use the merge method to define a tag from a tag without changing the name.
Go ahead and change <more-messages> to <messages> to convince yourself that you will get an error.
However, Hobo does have a way of preserving tag names while creating tags from tags. It is called extending a tag. It works basically the same way as merging tags, except it uses the <extend> tag instead of the <def> tag to define the new tag.
Now let’s create an extended tag. We will begin by creating a new tag called <messagex> and then extend it using the same name.
<def tag="messagex">
<br/> <br/>
	<ul>
		<li param="msg1">Message 1</li>
		<li param="msg2">Message 2</li>
		<li param="msg3">Message 3</li>
	</ul>
</def>

<extend tag="messagex">
	<old-messagex merge>
		<msg2: param>Message 2 Extended</msg2:>
	</old-messagex>
</extend>	
Instead of placing the code above in front\.index.dryml, you need to put it in views/taglibs/application.dryml. Recall this will make the tag definition available throughout your application. But there is another reason for putting it here. You cannot use the <extend> tag in a view template, you can only use it within application.dryml.  
Note: To extend this tag and have the original one still available, you can use the Hobo “alias-of” parameter:

     <def tag="new-messagex” alias-of="messagex"/>
 
And then extend “new-messagex” with the functionality you need.
 




Before trying this out, you should delete (or comment out) the code for  <more-messages> so you will not get confused. 
In the code example above, we created a new tag <messagex> just like the old <messages> tag. We then extended it so that it would look just like the 
<more-messages> tag from Step 1.
Now call the <messagex> tag in front/index.dryml to confirm that it yields output like the <more-messages> tag.
	<messagex/>
You should see the following rendering:



3.  Edit the merged tag in more ways. Let’s modify our <more-messages> tag of Step 1,  which is defined in front/index.dryml. Remove or comment out the <messagex> tag so you won’t get confused.
We are going to show you now that DRYML can do lots of things within the same tag definition with ease. First we will add a new parameter tag before the merge line to demonstrate that you do not have to have the merge line right after your <def> line. 
Next we will show you that you can put both parameter tags and non-parameter HTML after merge markup. Let’s do this in two steps.
Edit your <more-messages> tag to look like the following:
<def tag="more-messages">
	<br/><br/>
	<li param="msg0">Message 0</li>
	<messages merge>
		<msg2: param>Message 2 changed in merge.</msg2:>
	</messages>
</def> 
Make sure you call your <more-messages> tag and refresh your browser.

Figure 115: Page view of the <more-messages> tag usage
Let’s demonstrate that <msg0:> is a real parameter tag with the following code where you call the <more-messages> tag.
<more-messages>
	<msg0:> Message 0 changed with parameter tag.</msg0:>
</more-messages> 


We have chosen this exercise to remind you that you have changed the text in two ways. 
You changed the third block of messages by changing the tag definition within a merge. 
You changed the second block (Message 0) by calling a parameter tag within a tag.
Now let’s edit the <more-messages> definition after the merge is closed with </messages>. We have added two lines of DRYML. The first is a parameter tag, <msg4:>. The second is pure HTML without any parameterization.
<def tag="more-messages">
	<li param="msg0">Message 0</li>
	<messages merge>
		<msg2: param>Message 2 changed in merge.</msg2:>
	</messages>
	<li param="msg4">Message 4</li>
	<li>No Parameter Here</li>
</def>



Now let’s invoke <more-messages> and change the default content of the <msg4:> parameter tag.
<more-messages>
	<msg0:> Message 0 changed with parameter tag.</msg0:>
	<msg4:> Message 4 has changed with parameter tag too.</msg4:>
</more-messages> 

Figure 117: More parameter magic
Tutorial 12 – Rapid, DRYML and Record Collections

You will learn how to create a new index page that will replace the default index page that Hobo generates on the fly, and learn how to display data on this index page that is related through a many-to-many relationship. 
Tutorial Application: four_table
Topics
Learn how to create your own index template in a view/model directory.
Work on using the application.dryml directory to override auto-generated tags.
Learn about the Rapid collection tag.
Get introduced to the Rapid <a> tag.
Learn how to use the <repeat>, <if> and <else> tags.
Steps
1.	Click the model(Recipes) tab.  Load your browser again with the Four Table application we ended up with in Tutorial 11.  Click the Recipes tag to remind yourself how Hobo automatically creates a list of your recipes. This is different than the Home tab you were working with in Tutorial 11. When you click the Recipes tab, Hobo goes through the three-step check you learned about in Tutorial 1 to locate a template or template definition.
Since we have already moved the <index-page> tag for recipes to \taglibs\application.dryml, Hobo will obtain its tag definition for generation of a view template here. 
Note: You learned back in Tutorial 1 that each of Hobo’s tabs, named with the plural of the model name by default, invoke the index action and list the records in the model.
Since there is not a file called views\recipes\index.dryml, Hobo will create its own template on the fly from the <index-page> tag definition in \taglibs\application.dryml. (We created a views\recipes\index.dryml in Step 1 but we asked you to remove it. If you did not do that, do it now so you do not have any conflicts as we proceed).


2. Create a new template file. Now, create the new file called index.dryml in the views/recipes folder. This is the folder automatically created when you did the hobo g resource generation in Tutorial 1. This file is called a DRYML template. 
Note: We have used the word template quite frequently now but it is still worth reminding you not to be confused by it. It is a file used to render a specific web page, not a framework for creating one as the word may imply.
Now that this file exists, Hobo will use it when it finds it so let’s put a tag in it to make sure Hobo has a template to render.
<index-page/>

Refresh your browser. It should look just like it did in Step 1. This is because <index-page> is exactly the tag that Hobo is calling to display this page. Instead of doing it automatically, you have added one step. Before, since there was no file in views\recipes, Hobo created its own version of the page using this tag. Now it looks in the folder, finds the index.dryml file and does what it would have done anyways, namely use the <index-page> tag.
3.	Work with the <collection> tag. From here on in this tutorial we will be moving back and forth between the template views/recipes/index.dryml and the <index-page> definition in views\taglibs\application.dryml. Keep this in mind so you do not get confused.
Go to the application.dryml and find the <index-page> tag definition for the Recipe model. Note the <collection> tag in italics and bold below.
<def tag="index-page" for="Recipe">
  <page merge title="#{ht 'recipe.index.title', :default=>[model.model_name.human(:count=>100)] }">
    <body: class="index-page recipe" param/>

    <content: param>
      <header param="content-header">
        <h2 param="heading">
          My Recipes
        </h2>

        <p param="count" if>
          <ht key="recipe.collection.count" count="&this.size">
            <count summary/>
          </ht>
        </p>
      </header>

      <section param="content-body">
        <a action="new" to="&model" param="new-link">
          <ht key="recipe.actions.new">New Recipe</ht>
        </a>

        <page-nav param="top-page-nav"/>

        <collection param/>

        <page-nav param="bottom-page-nav"/>

      </section>
    </content:>
  </page>
</def>
To remind yourself that this is the tag responsible for listing the recipe records, delete it and refresh your browser. You will still see a template rendered but without the list of recipes. OK, now let’s put back the <collection> tag so that your file still reads like the above code.
Now let’s move back to the  views/recipes/index.dryml template and explicitly call the collection tag. Change your code to read like this:
<index-page>
	<collection:/>
</index-page>
Your Recipes template should still look exactly like the one in Step 1.
You are now calling the <collection> tag. Notice the trailing colon (:). This colon is here because you are calling a parameter tag. You can see above that the <collection> tag was parameterized in application.dryml by adding the param attribute to the declaration. You might be wondering where the <collection> tag is defined. 
Actually, it is a member of the Rapid library of tags that we have mentioned. As we go through these tutorials, we will point out where tags, and in particular parameters tags come from. Here is a list of tag situations you will encounter:
HTML tags which are often parameterized
Rapid library tags which are often parameterized
Rapid parameter tags, not defined in your app
User-defined tags which are often parameterized
Rapid auto-generated tags which are not usually parameterized
As we go forward, you will gradually learn how the auto-generated tags are built up out of Rapid library tags.
OK, let’s learn a little more about the <collection> tag. The <collection> tag does the following:
Repeats the body (stuff between the tags) of the tag inside a <ul> list with one item for each object in the collection of records.
If there is no content for the body, it renders a <card> inside the <li> tag nested within the <ul> tags.
The following code corresponds to "no body":
<collection:/>
and this code corresponds to an empty or blank body:
<collection:></collection:>
You have already seen what the former will do, namely list your records in a bolded hyperlinked format, which it derives from the <card> tag. Now try the latter. You will get the blank repeated as many times as there are recipe records, that is, nothing.

Figure 120: page view of using a blank "<collection:></collection:>" tag
Now try the following code.
<collection:>Hello!</collection:>
Since there is a body, the ‘Hello!’ will be repeated and the <card> will no longer be called.


There are three records in our Recipes table so ‘Hello!’ is repeated three times. If you examine your page a little more in detail by hovering your mouse over the ‘Hello’s’, you will see that each is linked to different records and has a different route associated with it.
Now let’s get some content displayed. We are going to use Rapid’s <a> tag, which is similar to the HTML <a> tag but has been redefined. The <a> tag is extended in Rapid to automatically provide a hyperlink to the route to show a particular record of the model. Let’s try this out with the following code.
<collection:><a/></collection:>


If you mouse over or click on one of the links you will discover a route like this
http://localhost:3000/recipes/2-omelette
The <a> link has created this route, which is the route for a show action.
Let’s do a comparison with the <card> tag that Hobo would call if you were not overriding it. Here is the <card> tag definition.
<def tag="card" for="Recipe">
  <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a></h4>
    </header:>
    <body: param>
      <ht key="category.collection.count" count="&this.categories.size">
         <count:categories param/>
      </ht>
    </body:>
  </card>
</def>
The <card> tag uses an <h4> heading tag which bolds and applies a larger font according to Hobo’s CSS files. It also uses the <a> tag with a body provided by the <name> tag, which renders the field that Hobo figures out automatically to be the most likely field you want to display. The <name> tag will pick out field names such as title, for example, which is the name of the field in our Recipe model.
If you wish to explicitly display a different field other than the one that Hobo provides by default, you can use the Rapid <view> tag. The syntax for this tag is different than you have encountered so far. Right now we are just going to give you a simplified description of the syntax and postpone a more detailed discussion for a later chapter:
<index-page>
	<collection:><view:title/></collection:>
</index-page>

Note: You will observe the trailing colon (:) with the <view> tag. This is an entirely different use of colon (:) than you have seen with parameter tags. Here the colon (:) is telling Hobo to figure out what model you are referring to and display the field from that particular model. This called implicit context, Hobo’s ability to know at all times what model you are working with in a particular view. In a later chapter you will learn how to change the implicit context. 
If you refresh your browser, you will note that the recipes displayed are not clickable. That is because of the way that the <collection> tag works. Remember that when you add a body to the tag, it no longer uses the <card> tag so you are only asking Hobo to display the title field, not create a hyperlink. That is easily remedied by doing the following.
<index-page>
	<collection:><a><view:title/></a></collection:>
</index-page>
Refresh your browser and see what you’ve got now:


This looks pretty close to the default version of the <collection> tag. With the following use of the <h4> HTML tag, you can almost bring back the default appearance. 
<index-page>
	<collection:><h4><a><view:title/></a></h4></collection:>
</index-page>
The only difference is the background provided to the record that you see above in Step 1 and the lack of the category count. The background is Hobo’s default CSS formatting which in this case is associated with the <card> tag and since you are not using it, the formatting does not appear. Understanding how Hobo utilizes CSS files is covered in a later Chapter.

	
4.	Display the associated record collection. Now that you see how to display collections of records, let’s go a bit deeper. Our Recipe model has a many-to-many relationship with the Category Model. It would be nice to see this relationship without having to click through to an individual recipe.
You can do this in several different ways. First we will do it in views/recipes/index.dryml template. Then we will try it in a <card> definition in application.dryml. Try out the following code.
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<view:categories/>
</collection:>
</index-page>


What we did here with the <view> tag was to tell Hobo to change its implicit context to the Categories model. The colon(:) is what did the trick and, of course, all the machinery inside Hobo which keeps it informed about the relationship between models that we set up.
Now we are going to do this slightly differently by using another Rapid library tag called <repeat>.
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<repeat:categories><a/></repeat>
</collection:>
</index-page>
The repeat tag with the colon (:) tells Hobo to loop through the records in the implicit context and to display what is in the body of the tag, namely <a/>. Try it and you will see the categories as hyperlinks but all run together. Fortunately, <repeat> has a join attribute to put in some additional character punctuation. Try this.
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<repeat:categories join=", "><a/></repeat>
	</collection:>
</index-page>
Now you get this:


If you don’t want to have your categories linked you could do this,
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<repeat:categories join=", "><name/></repeat>
</collection:>
</index-page>
or you could do this.
<index-page>
	<collection:><h4><a><view:title/></a></h4>
	<repeat:categories join=", "><view:name/></repeat>
</collection:>
</index-page>

Note: The <name/> tag and the name attribute in <view:name/> are not the same. In the former, Hobo looks at the Category model to find a candidate field to output from the <name> tag. We made it easy for Hobo since there is a field called name, which it picks, and displays. In the second example, we explicitly tell Hobo to display the name field of the categories model.  
Now we are going to try the same thing within a tag definition so put your template, views/recipes/index.dryml back to the following:
<index-page/>
Now go into application.dryml and find the recipe <card> definition. It should be there from Tutorial 1. If it is not there copy it from views\taglibs\auto\rapid\cards.dryml. 
Edit it to look like the below. Not the added code in italics and bold. We have added the same code we put in the template above. Since the code is now in the <card> tag definition, we should get all the formatting set up pre-defined in Hobo.
<def tag="card" for="Recipe">
  <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a></h4>
    </header:>
    <body: param>
      <ht key="category.collection.count" count="&this.categories.size">
         <count:categories param/>
      </ht>
		 <br/><view:categories/>
    </body:>
  </card>
</def>
Refresh your browser.


Now you have succeeded in editing the recipe <card> tag to drill down to assigned categories for your recipes.
5.	Use the <if> and <else> tags. We are going to show you one more version way of displaying the recipe records and the categories assigned to them. Notice that when there are no categories assigned, the <view> tag puts out the text, ‘none’. Let’s try to make this look a little nicer.
The <if> tag checks for null records in a record collection and outputs the body of the tag when the record exists. You use the <else> tag for the case when the record does not exist. Try this.
<def tag="card" for="Recipe">
  <card class="recipe" param="default" merge>
    <header: param>
      <h4 param="heading"><a><name/></a></h4>
    </header:>
    <body: param>
      
	  <if:categories><view/></if>
	  <else>There are no assigned categories yet.</else>

    </body:>
  </card>
</def>


In the examples above, we used the trailing colon (:) syntax to tell Hobo what model context we wanted in the <view> or <repeat> tags. In this example, we take care of changing the context with the <if> tag so there is no need to do it again. In fact, if we introduced this redundancy, as in the code below, we would get an error:
<!--THIS CODE PRODUCES AN ERROR-->
<if:categories><view:categories/></if>
<else>There are no assigned categories yet.</else>
Tutorial 13 – Listing Data in Table Form

You will learn how to display your data in a sortable, searchable table. The search will actually extend beyond the table entries to all the fields of each record. The sort and search code is an advanced topic that is provided here for completeness.
Tutorial Application: four_table
Topics
Display model data in table form.
Use the replace attribute to change the content of a parameter tag.
Display associated record counts in the table
Add search and sort to the table.
Steps
1.	Display model in table form. In the following code, we use another built in feature of Hobo’s parameter tags, the ability to replace what the parameter does with new tag code. The code below should be entered into your views/recipes/index.dryml file. Delete or comment out the <index-page> tag from Tutorial 12. 
<index-page >
	<collection: replace>
		<div>
	      <table-plus fields="title,country"/>
	    </div>
	  </collection:>
</index-page>
Refresh your browser to see your new table:


The fields attribute of the <table-plus> tag lets you specify a list of fields that will become the columns of a table. 
So essentially one line of code sets up a pretty good table for you in Hobo.
2.	Make your data hyperlinked. You might have noticed that the country names are clickable but the titles are not. Hobo provides a way to do this using the this keyword. This refers to the object currently in scope.
 Note: The  this keyword actually has a far deeper meaning that will be explored in more depth later. For now we will just outline how to use it.
Make the following change to your code and refresh your browser.
<index-page >
	<collection: replace>
		<div>
	      <table-plus fields="this, country"/>
	    </div>
	  </collection:>
</index-page>
Now your recipes are hyperlinked to the show route that displays individual recipe records.
3.	Show associated record counts. It would be nice to display how many associated category records there are. Again, since Hobo knows all about the relationships between records, you know it can figure this out. 
However, if you are familiar with database programming, you know queries have to be done to compute this value. The Hobo framework does not require you to do this extra work. You already know what you want--so you should be able to declare it. Here is how you do it:
<index-page >
	<collection: replace>
		<div>
			<table-plus fields="this, categories.count, country"/>
	    </div>
	  </collection:>
</index-page>


That was pretty straightforward. Before we refresh our browser again, let’s also display the actual categories in addition to the count. 
Again, with other frameworks this would be a bit more complicated, but Hobo makes this easy. In the previous tutorial, you learned a few ways to display the categories associated with an individual recipe, the simplest of which was the <view> tag. 
Here it is even easier--just add categories to the fields attribute:
<index-page >
	<collection: replace>
		<div>
			<table-plus fields="this, categories.count, categories, country"/>
	    </div>
	  </collection:>
</index-page>


4. Add search and sort capability to the table. Until now we have worked with controllers relatively little. If you think about it a bit, you will quickly realize that to add search and sort, we will have to make a change in the recipe controller. You can understand this by realizing that we want our application to respond to a click with two specific actions: one is a sort and the other is a search.
Go to your controllers/recipes_controller.rb file.
Note: This is actually an advanced topic since we are adding some Ruby code. You will learn more about the meaning of all the unfamiliar syntax in subsequent chapters. But for now, let’s polish off this table functionality.

To get the search feature working, we need to update the controller side. Add an index method to app/controllers/recipes_controller.rb like this:

def index
 hobo_index Recipe.apply_scopes(:search => [params[:search],:title,:body], :joins=>:country, :order_by  => parse_sort_param(:title, :country, :count))
end

Note: The “apply scopes” for the search facility can only contain fields within the recipe model—not related models at this time, but the “order  by” can.

Clicking on the Country label twice will trigger sorting in descending alphabetical order:

	
Now search/filter by “French” in the title or body:


Tutorial 14 – Working with the Show Page Tag

In this tutorial you will learn the options for displaying details about single records. In the last two tutorials, we focused on displaying lists of records. Hobo has a specific auto-generated tag for handling the display of individual records and a route and view template associated with it. 
Tutorial Application: four_table
Topics
Edit the <show-page> tag.
Create and work with the show.dryml template.
Work with <field-list>, <fieldname-label> and <view> tags. 
Steps
1.	Copy the <show-page> tag. Go to pages.dryml and copy the <show-page> tag for Recipes to application.dryml. 
<def tag="show-page" for="Recipe">
  <page merge title="#{ht 'recipe.show.title', :default=>['Recipe'] }">

    <body: class="show-page recipe" param/>

    <content: param>
          <header param="content-header">
            <a:country param="parent-link">&laquo; <ht key="recipe.actions.back_to_parent" parent="Country" name="&this">Back to <name/></ht></a:country>
            <h2 param="heading">
              <ht key="recipe.show.heading" name="&this.respond_to?(:name) ? this.name : ''">
                <name/>
              </ht>
            </h2>

            <record-flags fields="" param/>

            <a action="edit" if="&can_edit?" param="edit-link">
              <ht key="recipe.actions.edit" name="&this.respond_to?(:name) ? this.name : ''">
                Edit Recipe
              </ht>
            </a>
          </header>

          <section param="content-body">
            <view:body param="description"/>
            <field-list fields="country" param/>
            <section param="collection-section">
              <h3 param="collection-heading">
                <ht key="category.collection.heading" count="&this.categories.count" >
                  <human-collection-name collection="categories" your/>
                </ht>
              </h3>

              <collection:categories param/>
            </section>
          </section>
    </content:>

  </page>
</def>
We are going to focus in on three display components of this tag, noted in bold italics above, to help you understand how to change the display of individual records.  (Add the ‘<field-list fields="country" param/>’ if it is not present.)
Click on the Recipes tab and then click on an individual recipe.


Now comment out the three lines above in bold italics using <!-- ... -->, and confirm that you have removed the display of the individual recipe record.
2.	Create the show.dryml template. Go to views/recipes and create a new template file called show.dryml. When a user invokes the show action by requesting the display of a single record, this is the first of the three places Hobo looks to determine how to display the record. 
As with the index action, its next two stops are the application.dryml file to look for application wide tag definitions and finally in pages.dryml for the auto-generated tag definitions which are based on model and controller code.
Place the following code in show.dryml to invoke your show page. 
<show-page/>
Refresh your browser and you should see the following:


3.	Use the <field-list> tag. The <field-list> tag allows you to display rows of data in two columns. The first column contains the name of the field and the second column contains the contents of that field. The <field-list> tag has been parameterized in the <show-page> tag so we need to invoke it with a trailing colon (:). 
Remove the comments around the <field-list> tag in application.dryml and try the following in show.dryml.
<show-page>
	<field-list: fields = "body, country"/>
</show-page>
Here you are using the attribute  fields to declare which fields in your model you wish to display.


Hobo can even reach into the associated table and display the categories using <field-list>. Try this.
<show-page>
	<field-list: fields = "body, country, categories"/>
</show-page>
You can remove the collection heading since you no longer need it by observing that the <show-page> tag has a parameterized <h3> tag renamed as the <collection-heading:> parameter tag. You will see the following code in the <show-page> definition.
<h3 param="collection-heading">Categories</h3>
Now go into your show.dryml file and replace the default contents of the tag with nothing. 
<show-page>
	<field-list: fields = "body, country, categories"/>
	<collection-heading:></collection-heading:>
</show-page>

Now you should have the following after refreshing your browser.


4. Changing the <field-list> labels. We can now see that the <field-list> tag does a nice job of formatting the display of the fields of a record. The default display pictured in Step 1 uses a combination of the <view> and <field-list> tags. However the <view> tag does not automatically provide a label like the <field-list> tag. We will cover this further in Step 5. Now let’s learn how to change the labels.
Try the following code to change the body label to ‘Recipe’.
<show-page>
 <collection-heading:></collection-heading:>
   <field-list: fields = "body, country, categories"> 
    <body-label:>Recipe</body-label:>  
   </field-list>
<show-page>


There are a few new things going on here that you have not seen before.
The <body-label:> tag is a parameter tag defined in the Rapid Library. 
The <body-label:> tag is a user customized Rapid library tag derived from the generic <fieldname-label> tag.
The <body-label:> tag is nested within the <field-list> tag.
Let’s go through these points one at a time.
Rapid Parameter Tag. This the tag is used with a trailing colon (:), meaning that <body-label:> is a parameter tag. However, it is not defined anywhere within either your code or the auto-generated code. (You will see user-customized tags again with pseudo tags in the next tutorial.)
If you have done any coding besides this tutorial, you have probably run into the error “You cannot mix parameter and non-parameter tags”.
If there were not a Rapid parameter tag to use here and you tried to use a regular Rapid tag, you would get an error. Try deleting the colon (:) from <body-label:> to confirm this.
User-customized tags. The tag name is dynamic depending on what field in the <field-list> is being addressed. For example, to change the label of the country field, you would use the <country-label> tag.
Tag nesting. The feature that you see here is the ability to nest tags in order to pass data. Here you are passing the content of the tag to the label variable of the <field-list> tag.
Let’s go one step further and re-label the other two fields displayed on our page. You can just nest each <fieldname-label> tag after the other within <field-list> and Hobo will pass the content into the <field-list> tag.
You might be noticing that categories is not a field at all; it is a collection. That is not a problem for Hobo. Hobo can address the label using the <categories-label> just as if it was a field: 
<show-page>
   <collection-heading:></collection-heading:>
	<field-list: fields = "body, country, categories">
		<body-label:>Recipe</body-label:>
		<country-label:>Origin</country-label:>
		<categories-label:>Flavors</categories-label:>
	</field-list>
<show-page>
Refresh your browser and try this out.


5. Using the <view> tag to display a record. There is still another way to work with the fields of an individual record and its associated records using the <view> tag.
Let’s make a tag from the <show-page> tag within application.dryml. Recall that you can use the merge attribute within a template although you can’t use the <extend> tag in a template, only in application.dryml.
Let’s try out the following code in application.dryml. 
<def tag="show-page-new">
	<show-page merge>
		<content-body:>
			<h2>Title:</h2>
			<view:title/><br/>
			<h2>Recipe:</h2>
			<view:body/>
			<h2>Categories:</h2>
			<view:categories/>
			<h2>Country:</h2>
			<view:country/>
		</content-body:>
	</show-page>
</def>
<show-page-new/>
In the above code, we are using the parameter tag <content-body:> defined from a parameterized <section> tag in the <show-page> tag:
<section param="content-body">
By placing new HTML and Rapid library tags within the <content-body:> tags, we are changing the default content defined in the <show-page> tag to the new content and preserving everything else in the <show-page> tag. We are not only preserving the content but also the formatting. Hobo has predefined CSS formatting as you probably have gathered that correspond to the Rapid tags. 
If, for example, we had used the replace attribute in the <content-body:> tag like this…
<content-body: replace>
..we would have removed Hobo’s built-in formatting. 
Remove the last code in show.dryml  and put <show-page-new/> at the top.
Refresh your browser without using the replace attribute and then try it with the attribute to see confirm that the formatting will be removed.


Here is what happens when you add the replace attribute. 





Now take out the replace attribute before proceeding.
6.	Summary. You have now learned to create a new template called show.dryml in the views/recipes directory that is used whenever there is an action to display an individual recipe record. Before you created this file, Hobo was constructing the template on the fly from the auto-generated <show-page> tag in pages.dryml.

Tutorial 15 – New and Edit Pages with The Form Tag	

In this tutorial you will be introduced to the <new-page> and <edit-page> auto-generated tags. Both of these tags utilize the Rapid <form> tag as their basic building block. You will learn how the <form> tag utilizes both the <field-list> and <input> tags. You will also learn about the concept of a “polymorphic” tag, which renders form components based on field type and model structure.
Tutorial Application: four_table
Topics
The <new-page> and <edit-page> tags
The <field-list> tag
The <input-tag>
Steps
1.	Get introduced to the <new-page> and <edit-page> tags. Go into pages.dryml and take a look at the code for both of these tags. Here is the  <new-page> definition:
<def tag="new-page" for="Recipe">
  <page merge title="#{ht 'recipe.new.title', :default=>[' New Recipe'] }">
    <body: class="new-page recipe" param/>

    <content: param>
      <section param="content-header">
        <h2 param="heading">
          <ht key="recipe.new.heading">
            New Recipe
          </ht>
        </h2>
      </section>

      <section param="content-body">
        <form param>
          <submit: label="#{ht 'recipe.actions.create', :default=>['Create Recipe']}"/>
        </form>
      </section>
    </content:>
  </page>
</def>
And here is the <edit-page> definition:
<def tag="edit-page" for="Recipe">
  <page merge title="#{ht 'recipe.edit.title', :default=>['Edit Recipe'] }">

    <body: class="edit-page recipe" param/>

    <content:>
      <section param="content-header">
        <h2 param="heading">
          <ht key="recipe.edit.heading" name="&this.respond_to?(:name) ? this.name : ''">
            Edit Recipe
          </ht>
        </h2>
        <delete-button label="#{ht 'recipe.actions.delete', :default=>['Remove This Recipe']}" param/>
      </section>

      <section param="content-body">
        <form param/>
      </section>
    </content:>

  </page>
</def>

The components that we are going to focus on are shown in bold italics. Let’s also take a look at the <form> tag that both of these tags call.
<def tag="form" for="Recipe">
  <form merge param="default">
    <error-messages param/>	
    <field-list fields="title, body, categories, category_assignments, country" param/>
    <div param="actions">
      <submit label="Save" param/><or-cancel param="cancel"/>
    </div>
  </form>
</def>
In a nutshell, you can see that each of these auto-generated tags call the auto-generated  <form> tag which is defined by merging the Rapid <form> tag in addition to other tags. The specific fields that will be used in the form are declared within the fields attribute of the <field-list> tag that you learned about in Tutorial 14 on the <show-page> tag.
You no doubt are noticing that the <field-list> tag is doing something different here. Instead of displaying a two-column table consisting of field labels in the first column and field data in the second, it is putting the appropriate data entry control in the second column. The data entry control choice depends on the type of field that was defined in the model.
Hobo puts a one-line data entry box for the title field, which is a string field and a larger box for the body field, which is a text field.  Notice that Hobo also creates drop-down combo controls for the country field and for the categories collection. 
Hobo does this from inspecting table relationships.  The recipe model is related to both the country model and the category model. This is a pretty powerful capability for just one tag, especially given that the Category model is related to the Recipe model through a many-to-many relationship through the CategoryAssignment model.


All of this capability results from Hobo’s implementation of tag polymorphism, an ability to do what is necessary from the context of the code. Polymorphism means ‘many forms (not data entry form)’ or ‘many structures’. It is a hallmark feature of the Ruby language.
(There is even more going on in the <field-list> tag but we will wait to discuss it until the next step.)
Before moving on, let’s take care of a detail by using your knowledge of parameter tags. You will note that the <new-page> tag calls the <submit:> parameter tag and that the <edit-page> tag does not. But there is still a submit button on the edit page. The explanation can be found in the definition of the <form> tag. There you will see that the <submit> tag is declared as a parameter tag as is the <or-cancel> tag.
The <new-page> tag calls the <submit:> parameter tag and changes the label from its default value of ‘Save’ to a new value of ‘Create Recipe’. There is no need to call the <or-cancel> tag with its parameterized name, <cancel>, because it is not changed.
On the other hand, the <edit-page> tag just relies on the default for both of these tags so there are no calls to them in the <edit-page> tag definition.
2.	Working with the <field-list> tag. You have already done some work with this tag in the last tutorial.  Experiment with removing a field by editing the tag’s fields attribute. First copy the three tags above into application.dryml
     (As we have mentioned, you probably want to be careful about editing tags this way in a real application. But this is the easiest way for us to acquaint you with how Hobo works.) 
Let’s remove the categories drop-down box as an experiment. Working in application.dryml, edit the <form> definition code. Change 
<field-list fields="title, body, categories, category_assignments, country" param/>
to:
<field-list fields="title, body, category_assignments, country" param/>


Now your categories drop-down box is gone.
You may be wondering why we did not remove the category_assignments attribute also or for that matter why it is there at all. First, try removing category_assignments without removing categories. There is no effect. Try removing both. You get the same result as with removing categories alone. This is just how the <field-list> tag works. On the other hand, the model structure that connects the Recipe model to the Category model through the CategoryAssignments model must, of course, be there for the drop-down box to be there at all. Put back the categories drop-down box to end this step of the tutorial.
3.  Working with the  <field-list> and <input> tags. In the same way that <field-list> calls the <view> tag when it is showing a record’s data, <field-list> calls the <input> tag when it is creating an empty form to enter a record or populating a form for editing a record. This is an illustration of tag polymorphism. That is, <field-list> does many different things depending on the context of its use.
The overall syntax of the <input> tag is the same as the <view> tag. When you wish to create an input control on a form, one at a time, you can invoke the control in the following way.
<input:title>
In the code above you are requesting that an input field be created for the title field of the Recipe model. Hobo knows to use the Recipe model as long as you are in the context of the Recipe model, which in this case is set by working within the Recipe form. Further, as you’ve seen before, Hobo knows just what kind of control you are likely to need.
Below we are going to show you how to construct essentially the same form out of <input> tags that you created with the <field-list> tag in the previous step.
Let’s be a bit more rigorous now in constructing tags from tags. First remove the form definition tag from application.dryml. You will now use the <extend> tag to redefine an auto-generated <form> tag with the same name.
First, let’s create the skeleton of an extend tag so we can watch what happens one step at a time. The following code placed in application.dryml will cause no change because it substitutes this  <form> tag for the original <form> tag.
<extend tag="form" for ="Recipe">
	<old-form merge/>
</extend>
The following code, which might seem to be identical, actually is not. 
<extend tag="form" for ="Recipe">
	<old-form merge>
	</old-form>
</extend>
In the above case, Hobo replaced the default content of the parameterized <form> tag with blank content resulting in a blank form. Go to the ‘Recipes’ tab and pick a recipe. Then click ‘New Recipe’ to see the blank form.
Now let’s get some content into the parameter tag. Copy the following code into application.dryml:
<extend tag="form" for ="Recipe">
	<old-form merge>
		<error-messages param/>
		<p><input:title/><p/>
	    <div param="actions">
	      <submit label="Save" param/><or-cancel param="cancel"/>
	    </div>
	</old-form>
</extend>
Refresh your browser.


We’ve got an entry control but <input> has no built in labeling like <field-list>. We need to add it like we did with the <view> tag.

<extend tag="form" for ="Recipe">
	<old-form merge>
			<error-messages param/>
		<p><b>Title</b></p>
		<p><input:title/><p/><br/><br/>
	    <div param="actions">
	      <submit label="Save" param/><or-cancel param="cancel"/>
	    </div>
	</old-form>
</extend>
Refresh your browser:


Do the same thing for the rest of the fields. (Some of Hobo’s tags have differing built-in breaks, which is why the number of breaks varies some below.)
<extend tag="form" for ="Recipe">
 <old-form merge>
   <error-messages param/>
   <p><b>Title</b></p>
   <p><input:title/></p>

   <p><b>Recipe</b></p>
   <p><input:body/></p>

   <p><b>Categories</b></p>
   <p><input:categories/></p>

   <p><b>Country</b></p>
   <p><input:country/></p>

   <div param="actions">
     <submit label="Save" param/><or-cancel param="cancel"/>
   </div>
 </old-form>
</extend>



Now you have succeeded in reconstructing a form with the <input> tag and a little bit of additional HTML formatting. 
Summary. Hobo provides some great functionality for fine-tuning your application when the default rendering is not quite what you would like. You can experiment with them by going through the documentation on the Hobo web site or learn more about them in later chapters of this book.
Tutorial 16 – The <a> Hyperlink Tag 

In this tutorial you will learn to develop sophisticated data-driven hyperlinks in you Hobo pages. 
Tutorial Application: four_table
Topics
The <a> “hyperlink” tag for calling data-driven pages
Steps
1. Review the <a> tag usage within Hobo’s auto-generated tags. Let’s take a look at the <a> tag usage in the auto-generated tags for the Recipe model.
<!--New Page Link from the Index Page Tag-->
<a action="new" to="&model" param="new-link"/>
This tag results in the ‘New Recipe’ hyperlink with the route ‘http://localhost:3000/recipes/new’.
<!--Edit Page Link from the Show Page Tag-->
<a action="edit" if="&can_edit?" param="edit-link">Edit Recipe</a>
This tag results in the ‘Edit Recipe’ hyperlink with a route like http://localhost:3000/recipes/2-omelette/edit.
2. Construct a link to an index (record listing) page. Let’s work in the home page in the file views/front/index.html. We will place our test code after the “Congratulations . . . “ message. 
<br/><h4>
<a to="&Country" action="index" >List My Countries</a><br/>
</h4>
This code will generate a link to a listing of countries in your database. 

	
Note: The to attribute defines the model to be used in the listing. It is always prefixed by the & character. The action attribute defines the controller action, which in the above case uses Hobo’s built-in index action. As you get more sophisticated, you will learn to define your own controller actions. These can be referred to by the action attribute too.
Of course, if you click on the ‘List My Countries’ link, you will now see a listing of countries.


3.	Construct a link to a new record page. We can construct a link to create new countries in much the same way.
<a to="&Country" action="new" >New Country</a><br/>


Now you’ve got another link to try out.
4.	Construct a link to an edit record page. If you want to create a custom link to an edit page, you have to be sure you are in the right context. Hobo can implicitly figure out which record you wish to edit, but only if you are displaying a particular record.
     In the example from Step 1 above, the ‘edit page’ link occurs in a <show-page> tag definition so Hobo knows what record you want to edit.
Let’s create our own link on the Country <show-page> tag by using the <content-body:> parameter tag that is defined in the auto-generated <show-page> tag for the Country model. Create a new file called show.dryml in your views/countries directory.
You need to use the parameter tag or Hobo will ignore your code. This is just how the <show-page> tag was defined.
<show-page>
	<content-body:>
		<a action="edit" >Edit My Country</a><br/>
	</content-body:>
</show-page>
Go ahead and refresh your browser, click on the ‘Country’ tab and click on a country and you will see your new link to edit it on the bottom left.

Figure 150: Page view of custom <show-page> tag
5.   Construct a link to a specific record. In general, Hobo takes care of linking to specific records for you by setting up the links implicitly in the <index-page>. If you need to link to a specific record, that will require a little Ruby to address a specific record in the database. 



	
CHAPTER 5 – ADVANCED TUTORIALS

Introductory Concepts and Comments
Tutorial 17 – The Agile Project Manager
Tutorial 18 – Using CKEditor (Rich Text) with Hobo
Tutorial 19 – Using FusionCharts with Hobo
Tutorial 20 – Adding User Comments to Models
Tutorial 21 – Replicating the Look and Feel of a Site
Tutorial 22 – Using Hobo Lifecycles for Workflow
Tutorial 23 – Using Hobo Lifecycles for Workflow
Tutorial 24 – Creating an Administration Sub-Site
Tutorial 25 – Using Hobo Database Index Generation

Introductory Concepts and Comments

This set of tutorials builds on the expertise you have developed so far with the Beginning Tutorials and Intermediate Tutorials. 
You should be able to flex your muscles a bit, at rich text editing, charting,, or even completely change the look and feel of a site.
The “Agile Project Manager” implements a large range of Hobo features into a fairly substantial and useful application.  Try out enhancing and modifying it to fit your needs.
At the end of the Advanced Tutorials you will have the expertise to build, customize, and have your data-rich  application ready to go into production.  Enjoy!
Tutorial 17 – The Agile Project Manager

Note: We have simplified this example somewhat by substituting the more traditional term “requirement”  for  what many agile development texts refer to “story”.  One can extend this tutorial by linked one or many “requirements” for each user “story”. 

Tutorial Application:  projects
Overview
This tutorial is adapted from the classic “Agility” tutorial created by Tom Locke.  It retains much of Tom’s text and style. We have also highlighted quotes from Tom at critical points in the tutorial.  
Here is a quick summary of our goals for this application:
1. The application “Projects” maintains a set of projects, requirements, and related tasks for a team of people. 
2. Users access the application with a browser. The browser provides the capability to create, edit, delete and list projects, tasks, and task assignments.
3. All data entry fields have rollover hints to aid user data entry. Validation rules attached to the fields to prevent invalid entries. 
4. Each project can have any number of associated tasks, and each task can have one or more team members assigned to it. 
5. Each task has one status at any given time. A drop-down list of status codes will be displayed on a task creation page. Only one of these status codes can be selected and saved for this task.
6. There is a signup and login capability permitting each team member to create his/her own login name and password. The system administrator is determined by a simple rule--the first to log in to the application becomes the system administrator. 
7. There will be a simple role facility that will allow an Administrator to assign roles to users. Both the Administrator and Coordinator roles can create and update projects, requirements, and tasks and assign team members to a task.  Analysts, Developers, and Testers can change the status of a Requirement.
8. The task assignment page will have a drop-down list of all existing team members.  Only members of this list can have tasks assigned to them.
9. A project page will display a list of all tasks assigned to the project.
10. A task page will display a list of team members assigned to the task.


Getting Started

Create the application like you have for the other tutorials:

   > hobo new projects --setup

Now look again about what we want this app to do:
Track multiple projects
Each project has a collection of requirements (“requirements”) which are described at a high-level requirements using the language of the user
Each requirement is just a brief chunk of text
A requirement can be assigned a current status and a set of outstanding tasks
Tasks can be assigned to users
Each user will have a simple view of the tasks they are assigned to
So:
Project (with a name) has many requirements
Requirement (with a title, description and status) belongs to a project AND has many tasks
Task (with a description) belongs to a requirement AND has many users (through task-assignments)
User has many tasks (through task-assignments)
 Now we need to create the models outlined above using the Hobo generator:
> hobo g resource project name:string
> hobo g resource requirement title:string   body:text status:string
> hobo g resource task name:string

Remember that the hobo:resource generator builds the entire MVC (Model/Controller/View) infrastructure needed for any model requiring a web-font end.  The “task assignments” model is simply the table required to support many-to-many relationships behind the scenes.  So a view or controller is not needed, so we only need the hobo model generator:
> hobo g model task_assignment

Note: We are using the convention of naming an association table with the combination of a model name with a descriptive intermediate name, with terms separated by an underscore:
		task + assignment   becomes:   task_assignment

The field declarations have been created by the generators in each model file, but not the associations. 
To create the associations, edit each model file as outlined below and declare the association just below the “fields do ... end” declaration in each model, as follows:




Figure 152: Adding "belongs_to :project" and "has_many :tasks" to the Requirement model

Note that we have chosen to specify the index name associated with the belongs_to declaration in the Requirement model.  We did this in case we might want to port this app to Oracle at some point, and Oracle has this irritating limitation of 30 characters for table, column, and index names.  If we had not specified the index name, Rails would chose a default name, which is often longer than 30 characters.

Figure 153: Adding the “belongs_to” and “has_many” declarations to the Task model



Figure 154: Adding the two "belongs_to" definitions to the TaskAssignment model




Figure 155: Adding the "has_many" declarations to the User model
Now Hobo will create a single migration for all of these changes:
> hobo g migration

Load the migration file in your text editor to see what was generated:



Figure 156: First Hobo migration for Projects 


Figure 157: View of indexes created by the migration

In the figure above you can see the indexes that were created in an Oracle environment.  Notice that in addition to our custom indexes, all of the tables have a unique identifier column called “ID” that is also indexed.  All of these indexes start with the “SYS_” prefix.
Note: A change starting with Hobo 1.0 requires the developer to declare child models for the automatic Hobo Rapid display of child element counts as shown in the rest of this tutorial.

The code to add is bolded and italicized below:
class Project < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end
  
  has_many :requirements, :dependent=>:destroy
  
  children :requirements

[...]

class Requirement < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    title  :string
    body   :text
    status :string
    timestamps
  end

  belongs_to :project, :index=>'requirement_project_index'
  has_many :tasks, :dependent=>:destroy
  
  children :tasks

[...]

class Task < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end
  
  belongs_to :requirement, :index=>'requirement_task_index'
  has_many :task_assignments, :dependent=>:destroy
  has_many :users, :through=>:task_assignments

  children :task_assignments
  children :users

[...]

After you run the migration fire up the app:
> rails server

Here is what you app should look like now:

Figure 158: The default Home page for the Projects application

Make sure you create a first user, which will by default have administrator rights.  Then remember to stay in as an administrator (e.g., the user who signed up first), and spend a few minutes populating the app with projects, requirements and tasks.
Now enter a few projects like this:

Figure 159: The Projects index page

Enter a couple of requirements for one of your projects:
			


Figure 161: Index view for Requirements

And enter some tasks for one of the requirements:

Figure 162: New Task page

Figure 163: Index view for Tasks

Using the “Application Summary” page. A handy new feature starting with Hobo 0.9.0 is the Application Summary page.  If you are an administrator you can access this page by entering the following URL in your browser:
http://localhost:3000/dev/summary
This summary provides you quick access to information on:

Application Name	
Application Location	
Rails Version
Change Control (e.g., Git)
Bundled Gems
Plugins
Environments
Models/Tables
Model Associations
	
The following are screen shots of the Projects application so far.  Notice that the development environment we have been using is Oracle.
Note: The Application Summary is refreshed each time `a hobo g migration is executed.


Figure 164: Part 1 of the Application Summary page



Figure 165: Part 2 of the Application Summary page


Figure 166: Part 3 of the Application Summary page



Figure 167: Part 4 of the Application Summary page
Removing actions

By default Hobo has given us a full set of restful actions for every single model/controller pair. But many of these page flows (“routes”) are not optimal for our application.
For example, why would we want an index page listing every task in the database? We only really want to see tasks listed against related requirements and users. We need to disable the routes we don’t want.
There’s an interesting change of approach here that often crops up with Hobo development. Normally you’d expect to have to build everything yourself. With Hobo, you often are given everything you want and more besides. Your job is to take away the parts that you don’t want

Here’s how we would remove, for example, the index action from TasksController. 
In app/controllers/tasks_controller.rb, change
auto_actions :all

To
auto_actions :all, :except => :index

Next, refresh the browser and you’ll notice that “Tasks” has been removed from the main nav-bar. 

Figure 168:  Effect of removing the "index" action from the Tasks controller

Note: Hobo’s page generators adapt to changes in the actions that you make available.

Here’s another similar trick. Browse to one of your projects that do not have related requirements. You’ll see the page text says “No requirements to display”:


Figure 169: View of "No Requirements to display" message

There is an “Edit Project” link, but no obvious way to add a requirement related to this project. Hobo has support for this--but we need to switch it on. 
Add the following declaration to the requirements controller:
auto_actions_for :project, [:new, :create]


Figure 170: The "New Requirement" link now appears

Hobo’s page generators will respond to the existence of these routes and add a “New Requirement” link to the project page, and an appropriate “New Requirement” page:

Figure 171: View of the "New Requirement" page

Create a requirement and you’ll see the requirement has the same issue with an associated task – there is no obvious way to create one. Again, we can add the auto_actions_for declaration to the tasks controller, but this time we’ll only ask for a create action, and not a new action:
auto_actions_for :requirement, :create

Hobo’s page generator can support the lack of a ‘New Task’ page – it gives you an in-line form on the requirement page!

Figure 172: View of the in-line "Add a Task" form

Now we can continue to configure the available actions for all of the controllers. So far we’ve seen the “black-list” style where you list what you don’t want:
auto_actions :all, :except => :index

There’s also “white-list” style where you list what you do want, e.g.:
auto_actions :index, :show

There’s also a handy shortcut to get just the read-only routes (i.e., the ones that don’t modify the database):
auto_actions :read_only

The opposite is handy for things that are manipulated by AJAX, but never viewed directly:
auto_actions :write_only # short for -- :create, :update, :destroy


Now edit each of the controllers as listed below:
class ProjectsController < ApplicationController

  hobo_model_controller

  auto_actions :all

end

class TasksController < ApplicationController

  hobo_model_controller

  auto_actions :write_only,:edit

  # Add the following to put an in-place editor within the Requirement page
  auto_actions_for :requirement, :create

end
  
class RequirementsController < ApplicationController

  hobo_model_controller

  # add this to remove the Requirement tab from the main navigation bar 
  auto_actions :all, :except=> :index
 
 # add this line to get a New Requirement link for the Project page
  auto_actions_for :project, [:new, :create]

end

Notice the Task listing within a Requirement, and the “Add a Task” in-page editor:

Figure 173: Requirement page after modifying controller definitions

Permissions

So far we’ve done two major things with our app: 
Created models and specified associations
Modified controllers to specify which actions are available

There’s one more thing we typically do when creating a new Hobo app, before we even touch the view layer. We modify permissions in the model layer.
Adding Roles

Let’s do a simple addition to the User model.  Here we have taken the simple route, and created a new field called “role” along with the list of acceptable values using the Ruby enum_string method:
 
Figure 174: Defining available roles using “enum_string”

Run a hobo g migration to add this field to the database.
Modify the create permission to allow an Administrator to create a new user:

Figure 175: Modifying the "create_permitted" method to the User model

Modify your Users Controller as follows:

Figure 176: Users Controller with "auto actions :all:

Run the server again and then refresh your browser: 

Figure 177: The Users tab is now active

Now we can edit a user and add a role:

Figure 178: The Edit User page with the new Role field

I have selected the “Analyst” option.  So I have 
1.  A Hobo system permission as an Administrator
2.  An Application role as Analyst.
Now let’s see how to use this information.
Customizing the Permissions by Role

Here is what we would like to implement:
Only an administrator can delete projects, requirements, or tasks
Only an administrator or coordinator can create and edit projects, requirements, tasks or task assignments

Change your permissions in project.rb as follows:


Notice that to create a project, the active user must be an administrator OR:
The user must be signed up (not a guest)
The signed up user must have the role “Coordinator”

Also notice that we have entered “false” in the destroy_permitted? Definition. In this case, no user can erase a project.  Deleting projects would have to be done behind the scenes in the database, or the permissions changed to clean up unwanted projects.
Now enter the same permissions (except for the destroy_permitted? permission) for requirements, tasks, and task assignments.
Here is the code for project.rb listed in the figure above:

class Project < ActiveRecord::Base

  hobo_model # Don't put anything above this

  fields do
    name :string
    timestamps
  end

  has_many :requirements, :dependent=> :destroy
 
 # --- Permissions --- #

  def create_permitted?
  	# Make sure the user is 1) Signed up and a Coordinator or 2) is an                                                                                                 
  	# Adminstrator
   (acting_user.signed_up? &&  acting_user.role=="Coordinator") || acting_user.administrator?
  end

  def update_permitted?
   	# Make sure the user is 1) Signed up and a Coordinator or 2) is an      
   	# Adminstrator
   (acting_user.signed_up? &&  acting_user.role=="Coordinator") || acting_user.administrator?
  end

  def destroy_permitted?
    false
  end

  def view_permitted?(field)
    true
  end

end
Permissions for data integrity

The permissions system is not just for providing operations to some users but not to others. It is also used to prevent operations that don’t make sense for anyone.  For example, notice default UI allows requirements to be moved from one project to another. This may or may not be a sensible operation for anyone to be doing.  So, if you want to stop this from happening, change the “update_permitted?” method in requirement.rb:
	
 

Refresh the browser and you’ll see that menu was removed from the form automatically.
Now make a similar change to prevent tasks being moved from one requirement to another in task.rb:
def update_permitted?
    ((acting_user.signed_up? && acting_user.role == "coordinator") or   acting_user.administrator?) && !requirement_changed?
end
Associations

Although we have modeled the assignment of tasks to users, at the moment there is no way for the user to set these assignments. We’ll add that to the task edit page. Create a task and browse to the edit page. Notice that only the description is editable. 
Hobo does provide support for “multi-model” forms, but it is not active by default. To specify that a particular association should be accessible to updates from the form, you need to declare :accessible => true on the association.
In task.rb, edit the has_many :users association as follows:
has_many :users, :through => :task_assignments, :accessible => true

Note: Without that declaration, the permission system was reporting that this association was not editable. Now that the association is “accessible”, the permission system will check for create and destroy permissions on the join model TaskAssignment. As long as the current user has those permissions, the task edit page will now include a nice JavaScript powered control for assigning users in the edit-task page. Notice you can continue to assign users to a task and not leave the page:


Figure 181: Assigning multiple Users to a Task in the Edit Task page

Renaming Fields and Field Help

Hobo has a great facility that makes it easy to modify the display of a field name and the  field help that is displayed in the edit form.  As of Hobo 1.3, this functionality has been merged into the Hobo internationalization module: i18n.   
For this tutorial, we will rename the Project name field and also specify some help text for the field that will appear on the Project edit form.  To do this, we need add the following to the config/locales/app.en.yml file:
en:
  activerecord:
    attributes:
      project:
        name: Project Name
    attribute_help:
      project:
        name: Enter a name for the project. Make it short and descriptive

Refresh your browser and enter a new project:
 
Figure 182: The New Project page using “ProjectHints”
Customizing views	

It’s pretty surprising how far you can get without even touching the view layer. That’s the way we like to work with Hobo -- get the models and controllers right and the view will probably get close to what you want. From there you can override just those parts of the view that you need to.

We do that using the DRYML template language, which is part of Hobo. DRYML is tag based – it allows you to define and use your own tags right alongside the regular HTML tags. Tags are like helpers, but a lot more powerful. DRYML is quite different to other tag-based template languages, thanks to features like the implicit context and nestable parameters. DRYML is also an extension of ERB so you can still use the ERB syntax if you are familiar with Rails.

DRYML is probably the single best part of Hobo. It’s very good at high-level re-use because it allows you to make very focused changes if a given piece of pre-packaged HTML is not quite what you want.

Changing the Front Page

The first thing we are going to do is to change the front page.  Let’s change the title of the app and the default message: 

Figure 183: The default application name and welcome message

To change the application name, edit /config/application.rb:

Figure 184: Changing the application name in "config/application.rb"

Changing the app-name value for the app-name tag here will change it anywhere that tag is used throughout the application.
Now let’s change the rest of the page…
Bring up  /app/views/front/index.dryml in your editor:


This is what it looks like before you change it.  Now change it to the following:
<page title="Home">
  <body: class="front-page"/>
  <content:>
    <header class="content-header">
      <h1>"Powered by Hobo"</h1>
      <section class="welcome-message">
        <h3>Here is what you can do:</h3>
        <ul>
          <li>Create and maintain any number of Projects</li>
          <li>Associate Requirements to each Project</li>
          <li>Assign Tasks and assign people to complete each Task</li>
        </ul>
      </section>
    </header>
  </content:>
</page>

Now refresh your browser:

Figure 186: Home page modified by changing "/front/index.dryml"


Add Assigned Users to the Tasks

Currently the only way to see who’s assigned to a task is to click the task’s edit link. It would be better to add a list of the assigned users to each task when we’re looking at a requirement.
DRYML has a feature called “polymorphic” tags. These are tags that are defined differently for different types of objects. Rapid makes use of this feature with a system of “cards”. The tasks that are displayed on the requirement page are rendered by the <card> tag.

You can define custom cards for particular models. Furthermore, if you call <base-card> you can define your card by tweaking the default, rather than starting from scratch. This is what DRYML is all about. It’s like a smart-bomb, capable of taking out little bits of unwanted HTML with pin-point strikes and no collateral damage.
The file app/views/taglibs/application.dryml is a place to put tag definitions that will be available throughout the site. Add this definition to that file:
<extend tag="card" for="Task">
  <old-card merge>
    <append-body:>
      <div class="users">
        Assigned users: <repeat:users join=", "><a/></repeat><else>None</else>
      </div>
    </append-body:>
  </old-card>
</extend>


Figure 187: Extending the card tag for Task in "application.dryml"

Now refresh the requirement page. You’ll see that in the cards for each task there is now a list of assigned users. The users are clickable - they link to each user’s home page (which doesn’t have much on it at the moment).

Figure 188: Viewing assigned users on a the Task card

The <extend> tag is used to extend any tag that’s already defined. The body of <extend> is our new definition. It’s very common to want to base the new definition on the old one, for example, we often want to insert a bit of extra content as we’ve done here. 
We can do that by calling the “old” definition, which is available as <old-card>. We’ve passed the <append-body:> parameter to <old-card>, which is used to append content to the body of the card. 
Some points to note:
The <repeat> tag provides a join attribute that we use to insert the commas. The link is created with a simple empty <a/>. It links to the ‘current context‘, which, in this case, is the user. The :users in <repeat:users> switches the context. It selects the users association of the task.
DRYML has a multi-purpose <else> tag. When used with repeat, it provides a default for the case when the collection is empty.
Add a Task Summary to the User’s Home Page

Now that each task provides links to the assigned users, the user’s page is not looking great. Rapid has rendered cards for the task-assignments but there’s no meaningful content in them. What we’d like to see there is a list of all the tasks the user has been assigned to. Having them grouped by requirement would be helpful too.
To achieve this we want to create a custom template for users show page. If you look in app/views/users you’ll see that it’s empty. When a page template is missing, Hobo tries to fall back on a defined tag. For a ‘show’ page, that tag is <show-page>. The Rapid library provides a definition of <show-page>, so that’s what we’re seeing at the moment. 
As soon as we create app/views/users/show.dryml, that file will take over from the generic <show-page> tag. Try creating that file and just throw “Hello!” in there for now. You should see that the user’s show page now displays just “Hello!” and has lost all of the page styling.
If you now edit show.dryml to read ”<show-page/>” you’ll see we’re back where we started. The <show-page> tag is just being called explicitly instead of by convention. 
Rapid has generated a custom definition of <show-page for="User">. You can find this in app/views/taglibs/auto/rapid/pages.dryml. 



Don’t edit this file! Your changes will be overwritten. Instead, use this file as a reference so you can see what the page provides, and what parameters there are (the param attributes). 


Here is the top of the file:


Now find the “show-page” tag for User:

Figure 191: The auto-generated "show-page" tag for User in "pages.dryml”

Now let’s get the content we’re after - the user’s assigned tasks, grouped by requirement. It’s only five lines of markup to put in a file \views\users\show.dryml.

<show-page>
  <content-body:>
    <h3><Your/> Assigned Tasks</h3>
    <repeat with="&@user.tasks.group_by(&:requirement)">
      <h4>Requirement: <a with="&this_key"/></h4>
      <collection/>
    </repeat>
  </content-body:>
</show-page>


This will override the definition in pages.dryml and display a page similar to the following:


Figure 192: View of the enhanced User "show-page"

The <Your> tag is a handy little gadget. It outputs “Your” if the context is the current user, otherwise it outputs the user’s name. You’ll see “Your Assigned Tasks” when looking at yourself, and “Fred’s Assigned Tasks” when looking at Fred.
We’re using <repeat> again, but this time we’re setting the context to the result of a Ruby expression (with="&...expr..."). The expression: 
@user.tasks.group_by(&:requirement) 
	
gives us the grouped tasks. Inside the “repeat this” (the implicit context) will be an array of tasks, and this_key will be the requirement. 
So <a with="&this_key"> gives us a link to the requirement. <collection> is used to render a collection of anything in a <ul> list. By default it renders <card> tags. To change this, just provide a body to the <collection> tag.  Now click on the Users tab to see a summary of tasks for all users:

Figure 193: The Users tab showing all assignments

Now you can get the big picture of all user assignments.
This is a lot to take in all at once.  The main idea here is to give you an overview of what’s possible. See The DRYML Guide for more in-depth information:
http://cookbook.hobocentral.net/manual/dryml-guide
Improve the Project Page with a Searchable, Sortable table

The project page is currently workable, but we can easily improve it a lot. Hobo Rapid provides a tag called  <table-plus> which:
Renders a table with support for sorting by clicking on the headings
Provides a built-in search bar for filtering the rows displayed
Searching and sorting are done server-side so we need to modify the controller as well as the view for this enhancement.
As with the user’s show-page, to get started put a simple call to <show-page/> in app/views/projects/show.dryml
To see what this page is doing, take a look at
 <def tag="show-page" for="Project">

 in pages.dryml. (app/views/taglibs/auto/rapid). 
Notice this tag:
<collection:requirements param/>

That’s the part we want to replace with the table. Note that when a param attribute doesn’t give a name, the name defaults to the same name as the tag.
Here’s how we would replace that <collection> with a simple list of links:
<show-page>
  <collection: replace>
    <div>
      <repeat:requirements join=", "><a/></repeat>
    </div>
  </collection:>
</show-page>

You should now see that in place of the requirement cards, we now get a simple comma-separated list of links to the requirements. Not what we want of course, but it illustrates the concept of replacing a parameter. Here’s how we get the “table-plus”:

<show-page>
  <collection: replace>
    <table-plus:requirements fields="this, status">
      <empty-message:>No requirements match your criteria</empty-message:>
    </table-plus>
  </collection:>
</show-page>

The fields attribute to <table-plus> lets you specify a list of fields that will become the columns in the table. We could have specified fields="title, status" which would have given us the same content in the table, but by saying this, the first column contains links to the requirements, rather than just the title as text.
We could also add a column showing the number of tasks in a requirement. Change to fields="this, tasks.count, status and see that a column is added with a readable title “Tasks Count”.


To get the search feature working, we need to update the controller side. Add a show method to app/controllers/projects_controller.rb like this:
def show
  @project = find_instance
  @reqlist = @project.requirements.where(["title like ?", "%#{params[:search]}%"]).order(parse_sort_param(:title, :status).join(' '))
end

What we are doing is creating two instance variables that will hold the values in memory between the controller and view.
@project = Holds the information for the project that has just been clicked
@reqlist = A variable name we chose to hold the list of projects returned by the apply_scopes method. 
If there are no values in the search params, all requirements for that project are returned.  The first time the projects page is loaded params will be null. 
    Then get the <table-plus> to use @requirements:	
<table-plus with="&@reqlist" fields="this, tasks.count, status">




Now enter a word in the Search box and see how the requirement list is filtered:


Figure 196: Using a search within the Requirements listing



Other Enhancements
We’re now going to work through some more easy but very valuable enhancements to the application. We will add:
A menu for requirement statuses. We’ll do this first with a hard-wired set of options, and then add the ability to manage the set of available statuses.
Filtering of requirements by status on the project page
Drag and drop re-ordering of tasks for easy prioritization.
Rich text formatting of requirements. This is implemented by changing one symbol in the source code and adding the CKEditor plugin.

Requirement Status Menu

We’re going to do this in two stages.  First using a fixed menu that will require a source-code change if you ever need to alter the available statuses. We’ll then remove that restriction by adding a RequirementStatus model. We’ll also see the migration generator in action again.
The fixed menu is very simple. Locate the declaration of the status field in requirement.rb (it’s in the fields do ... end block), and change it to this:
status enum_string(:proposed, :accepted, :rejected, :reviewing, :developing, :completed) # etc.. 

Now the Edit Requirement page looks like this, with a select list:

Figure 197: The Edit Requirement form with selectable status codes

The menu is working in the edit requirement page now. It would be nice though if we had an “AJAX-ified” editor right on the requirement page. Edit the file
  app/views/requirements/show.dryml 
to be:
<show-page>
  <field-list: tag="editor"/>
</show-page>

Now the page has an in-place editor that does not require a submit button update.  

Figure 198: Creating an AJAX status update for Requirements

Simply select the new status, and a save is automatically executed via an AJAX call.
How did Hobo do that? <show-page> uses a tag called <field-list> to render a table of fields. DRYML’s parameter mechanism allows the caller to customize the parameters that are passed to <field-list>. 
On our requirement page the field-list contains only the status field. By default <field-list> uses the <view> tag to render read-only views of the fields, but that can be changed by passing a tag name to the tag attribute. We’re passing the name “editor” which is a DRYML tag for creating AJAX-style in-place editors. 
Create a Configurable Status List

In order to support management of the statuses available, we’ll create a Requirement Status model:

> hobo g resource requirement_status name:string

Whenever you create a new model and controller with Hobo, get into the habit of thinking about permissions and controller actions. 
In this case, we probably want only administrators to be able to manage the permissions. As for actions, we probably only want the write actions, and the index page:
auto_actions :write_only, :new, :index

Next, remove the status field from the fields do ... end block in the Requirement model and add the following association declaration:
belongs_to :status, :class_name => "RequirementStatus",
 :index => 'requirement_status_index'

Now run the migration generator
> hobo g migration

You’ll see that the migration generator considers this change to be ambiguous and will prompt you for an action. 

Note: Whenever there are columns removed and columns added, the migration generator can’t tell whether you’re actually removing one column and adding another, or if you are renaming the old column. It’s also pretty fussy about what it makes you type. We really don’t want to play fast and loose with precious data.

So, for the case at hand, to confirm that you want to drop the ‘status’ column, you have to type in full: “drop status”.

Once you’ve done that you’ll see that the generated migration includes the creation of the new foreign key and the removal of the old status column.
That’s it. The page to manage the requirement statuses should appear in the main navigation.
We’ve decided to revise our list while entering them using the New Requirement Status page:


	
Now that we’ve got more structured statuses, let’s do something with them…
Reordering Tasks

We’re now going to add the ability to re-order a requirement’s tasks by drag-and-drop. There’s support for this built into Hobo, so there’s not much to do. First we need the acts_as_list plugin:
> rails plugin install git://github.com/rails/acts_as_list.git

Now two changes to our models:	
Task needs:
acts_as_list :scope => :requirement

Requirement needs a modification to the has_many :tasks declaration:
has_many :tasks, :dependent => :destroy, :order => :position

The migration generator knows about the acts_as_list plugin, so you can just run it and you’ll get the new position column on Task which is needed to keep track of ordering for you.
> hobo g migration

Now refresh the application…
You’ll notice a slight glitch – the tasks position has been added to the new-task and edit-task forms. Fix this by customizing the Task form.
In application.dryml add:
<extend tag="form" for="Task">
  <old-form merge>
    <field-list: fields="name, users"/>
  </old-form>
</extend>

On the task edit page you might also have noticed that Hobo Rapid didn’t manage to figure out a destination for the cancel link. You can fix that by editing tasks/edit.dryml to be:
<edit-page>
  <form:>
    <cancel: with="&this.requirement"/>
  </form:>
</edit-page>

This is a good demonstration of DRYML’s nested parameter feature. The <edit-page> makes its form available as a parameter, and the form provides a <cancel:> parameter. 
We can drill down from the edit-page to the form and then to the cancel link to pass in a custom attribute. You can do this to any depth.
Adding a “Due Date” to Tasks

Let’s first add a good library of date and time validations:
Add the following line to the end of the Gemfile file in your application root directory:
gem “validates_timeliness”

Then run the following command in your console:

> bundle install


Now update your Task model with a due date, and add this validation for that date field:
validates_date :due_date, :on_or_after => Date.today
 

Figure 199: Task model with "due_date" and a validation for the date

In application.dryml add the new “due_date” field:
<extend tag="form" for="Task">
  <old-form merge>
    <field-list: fields="name, due_date, users"/>
  </old-form>
</extend>


Figure 200: Error message from trying to enter a date earlier than today


Tutorial 18 – Using CKEditor (Rich Text) with Hobo

By Tola Awofolu

Tutorial Application:  projects

Overview

CKEditor is the new rich text editor that replaces the popular FCKeditor used by many web developers for years.

To use CKEditor (3.x):

Download CKEditor from the download website:  http://www.ckeditor.com

Extract the downloaded  zip file, (ckeditor_3.5.zip or ckeditor_3.5.tar.gz at the time of this writing)  to a new directory, public/javascripts/ckeditor in your Hobo application from the website:


Figure 201: CKEditor source folder listing


Add the following file, load_ckeditor.js, to the public/javascripts directory of your Hobo application:

HoboCKEditor = { 
  newEditor : function(elm, buttons) {
    if (elm.name != '') {
      oInstance = CKEDITOR.replace( elm.name , 
      { toolbar : HoboCKEditor.standardToolbarConfig || buttons }
      );
      oInstance.setData( elm.value );
      oInstance.resetDirty();
    }
    return oInstance;
},
makeEditor : function(elm) {
    if (!elm.disabled && !elm.readOnly){
      HoboCKEditor.newEditor(elm);
    }
  },

standardToolbarConfig:  [ ['DocProps','-','Preview','-','Templates'],
                    ['Cut','Copy','Paste','PasteText','PasteWord','-','Print','SpellCheck'],
                    ['Undo','Redo','-','Find','Replace','-','SelectAll','RemoveFormat'],
                    [],
                    '/',
                    ['Bold','Italic','Underline','StrikeThrough','-','Subscript','Superscript'],
                    ['OrderedList','UnorderedList','-','Outdent','Indent','Blockquote'],
                    ['JustifyLeft','JustifyCenter','JustifyRight','JustifyFull'],
                    ['Link','Unlink'],
                    ['Image','Rule','SpecialChar','PageBreak'],
                    '/',
                    ['Style','FontFormat','FontName','FontSize'],
                    ['TextColor','BGColor'],
                    ['FitWindow','ShowBlocks','-','About'] ]
     
  }

Hobo.makeHtmlEditor = HoboCKEditor.makeEditor


 
Note: The code listed above has line wrapping because of the width of the paper.  Please remove and hard return characters in your code.

Notice that the “standardToolbarConfig” portion of this JavaScript customizes the CKEditor toolbar options.  Read the CKEditor documentation for more options you may wish to add.

This code also replaces the normal text box with the rich-text editor, as long as the text box is an HTML “textarea” tag that includes this HTML attribute in the tag definition.
 
Here’s an example of HTML markup that is created by Hobo:

	<textarea id= “contact[notes]” class= “contact large”/>

This HTML markup is automatically generated by Hobo for fields defined with the :html symbol in the model, so, open your app/models/requirement.rb file and change the ‘body’ field to :html:


Figure 202: Using the ":html" field option to trigger rich-text editing

Add the following lines of code to app/views/taglibs/application.dryml:

<extend tag="page"> 
  <old-page merge> 
    <after-scripts:> 
      <javascript name="ckeditor/ckeditor"/>        
      <javascript name="load_ckeditor"/>  
    </after-scripts:> 
  </old-page>
</extend>




Now access the Edit page for any requirement you have defined and the body field should look as follows:


Figure 203: Sample Hobo form using CKEditor
Tutorial 19 – Using FusionCharts with Hobo

By Marcelo Giorgi

Overview
Presenting data in a visual informative way is a powerful too. A widely-used charting and graphing library that includes lots of special effects is FusionCharts from InfoSoft (http://www.fusioncharts.com/).  
FusionCharts offers a wide range of flash components for rendering data-driven charts, graphs, and maps. The way to feed those flash components with our data is to create an XML file (with a specific format and semantics understood by FusionCharts) and then setting the URL for that file so that the Flash component (running on the client browser) can reach it.

In this tutorial we will continue with the four_table project you completed earlier so we can leverage the existing models and just focus on the chart functionality.

We’ll be adding two charts to the project:

Recipes By Country (which counts the number of recipes for each country)
Recipes by Category (which counts the number of recipes in each category)

Configuring FusionCharts for our Hobo application

The first thing we need to do is download the trial version of  FusionCharts Version 3. Go to the URL  http://www.fusioncharts.com/Download.asp and submit the form as shown below:


Figure 204: Registration form to request FusionCharts


Figure 205: Download page for FusionCharts
.

Click on the ‘Download FusionCharts v3 (Evaluation)’ link, save and unzip the file into a safe location, such as, c:\FusionChartsDistribution. 

Next:

1. Create a new folder under the hobo “public” folder called FusionCharts.  Copy all the swf files contained in the folder c:\FusionChartsDistribution\Charts to folder you created:  \four_table\public\FusionCharts 
	

Figure 206: Target location for the FusionCharts SWF files

2. Next, copy the file c:\FusionChartsDistribution\JSClass\FusionCharts.debug.js to \four_table\public\javascripts

3. Finally, we are ready to reference the JavaScript file (copied in Step 2) in our application.dryml file, as follows:



Figure 207: Adding the required <extend tag=’page’> definition in application.dryml

As you can see from the code of application.dryml,we extend the ‘page’ view so that we always include the JavaScript file FusionCharts.debug.js. We could include this JavaScript at a page level, but for the purposes of this tutorial seemed more practical to do it this way.

Adding sample data

Before implementing the chart functionality, create some sample data to use:

Figure 208: Screen shot of sample recipe data for the tutorial

It is probably better to first use the data presented here to make sure your charts will look the same as the tutorial. 

Recipes By Country

In order to implement a “Recipes By Country” chart we need to complete two steps: 
1. Programmatically save the data to an XML file
2. Configure the Flash Component to retrieve the generated data.
1. Save the data to an XML file

For our first chart we need to modify the RecipesController.rb in order to save the data (XML file) needed by the FusionCharts Flash component. We will activate the chart within the recipes/index.dryml file view as the data needed will be derived from the collection Recipes.

To get this to work, we will need to add a filter method to the controller, and a method to render XML. Take a look at the completed program below:


Figure 209: Enhancements to RecipesController to provide data to FusionCharts

As you can see (modifications are highlighted in bold italics below), we add a new filter to store the XML file only when we receive a request for the index page.



class RecipesController < ApplicationController

  hobo_model_controller
  before_filter :save_fusion_chart_data, :only => [:index]
  auto_actions :index, :show, :new, :edit, :create, :update, :destroy
...


Now we must define the ruby method save_fusion_chart_data for this controller. For now ignore the “private” method that encloses the code:

Let’s go through this code:



In this line we define an instance variable (@recipes_count_by_countries) that resolves the query of how many recipes there are for each country. 



In this line we define the local path (from the Server point of view) where the XML data file will be stored. As you can see, we are pointing to the public directory of the Hobo application, and that’s necessary because the file must be available so that the FusionCharts Flash component (on the client side) can load it.



This line uses the Rails “render_to_string” method using the template with the semantics needed by FusionCharts that is included in the “chart_data_generator_for_count_by_country” . This will be discussed below.



The final line calls the save_xml_file method passing the filename and the string stored in the variable xml_string (which represent an XML file)
 
Now, it’s time to review the implementation of the Rails’ “partial”1 that generates the XML string.  Add the code below to the specified file.
app/views/recipes/_chart_data_generator_for_count_by_country.builder
xml.instruct!
xml.chart :caption => 'Recipies Count by Country' do
  @recipes_count_by_countries.each do |recipe|
    xml.set(:label => recipe.country.name, :value => recipe['counter'])
  end
end

Rails “partials” that end with the extension “.builder” instruct rails to use “Builder”, which is the XML generator.  The API documentation can be found at:

http://api.rubyonrails.org/classes/Builder/XmlMarkup.html

This code defines a chart XML element (line #2), and then for each instance of the collection @recipes_count_by_countries it adds (within XML chart element) a set of XML elements that contain both the name of the Country and a counter for the number of recipes for the related country. 

The following is a sample file generated by that Builder code:

<?xml version="1.0" encoding="UTF-8"?>
<chart caption="Recipes Count by Country">
  <set label="American" value="3"/>
  <set label="Uruguay" value="2"/>
  <set label="Mexico" value="3"/>
  <set label="Italy" value="5"/>
  <set label="France" value="1"/>
</chart>


2. Configure the Flash Component to retrieve the generated data

Now that we have the data needed by our FusionCharts Flash Component, we need to instruct our FusionCharts Flash Component, by means of the JavaScript API available (thanks to the included file FusionCharts.debug.js), to load it.

See the figure below that includes the code from  recipes/index.dryml that demonstrates how we can accomplish that:


Figure 210: Content of recipes/index.dryml used to render FusionCharts

We define a div element (with id equal to recipes_count_by_countries), at line #8, intended to be the placeholder of the chart. 
Next, we make use of the FusionCharts JavaScript API o by creating a FusionCharts object at line #11.
The first parameter for the constructor is the particular Chart type that we are going to use. In this particular case, we will be using a Bar chart.
The second parameter is used to identify this Chart by name if you are going to use advanced features of the JavaScript API.
The third and forth parameters indicate the dimensions (width and height respectively) of the chart.
Finally, in line #13, we instruct FusionCharts to render the chart within the DOM element with id equal to recipes_count_by_countries.

And that’s it!!! Just go to the browser and request the URL: http://localhost:3000/recipes, and you’ll see, at the bottom of the view, a chart similar to the following:


Figure 211: Screen shot of rendered FusionCharts bar chart

Recipes By Category

Now let’s try a different type of Chart. A typical choice would be a pie chart. The good news is that it’s pretty much the same effort as the previous chart, because it uses the same type of XML data as input. For that reason, I’ll be focusing on the differences for this new chart.

1. Save the data to an XML file

We are going to use the same mechanism presented earlier in this tutorial to store the XML file. In fact, we’ll be modifying the method save_fusion_chart_data of recipes_controller.rb, this way:

1   private
2   def save_fusion_chart_data
3     @recipes_count_by_countries = Recipe.find(:all, :select => 'country_id, count(*) as counter', :group => 'country_id')
4     filename = "#{RAILS_ROOT}/public/recipes_count_by_countries.xml"
5     xml_string = render_to_string(:partial => 'chart_data_generator_for_count_by_country')
6     save_xml_file(filename, xml_string)
7     @recipes_count_by_categories = CategoryAssignment.select('category_id, count(*) as counter').group('category_id')
8     filename = "#{RAILS_ROOT}/public/recipes_count_by_categories.xml"
9     xml_string = render_to_string(:partial => 'chart_data_generator_for_count_by_categories')
10    save_xml_file(filename, xml_string)
11   end
12   def save_xml_file(filename, data)
13     FileUtils.rm(filename, :force => true)
14    f = File.new(filename, 'w')
15    f.write(data)
16    f.close
17   end

Again, statements marked with bold italics represent the modifications to the previous code. As you can see, these new lines just implement the same functionality as before, but using a different collection as input, this time we are using recipes_count_by_categories. 

Next, as we did for the previous chart, we define an XML builder as shown below:
recipes/_chart_data_generator_for_count_by_categories.builder
1 xml.instruct!
2 xml.chart :caption => 'Recipies Count by Category' do
3   @recipes_count_by_categories.each do |category_assignment|
4     xml.set(:label => category_assignment.category.name, :value => category_assignment['counter'])
5   end
6 end

You can tell that the only significant difference (apart from the caption description), is the way we invoke the model description. This is different in both cases because the queries are different.

After adding this we’ll be generating both XML data files each time a request to Recipes index arrives.

2. Configure the Flash Component to retrieve the generated data

The only thing missing now to render this second chart is to add a placeholder for the flash and invoke the proper JavaScript to do the job for us. Below we show the last piece of the puzzle:


Figure 212: The recipe/index.dryml file to render a FusionCharts pie chart and bar chart


And then, we’re done!! Here is the final result:


Figure 213: Screen shot of the rendered FusionCharts bar and pie charts

Have fun with FusionCharts!! And explore the different options here:

http://www.fusioncharts.com/OnlineDocs.asp
 



Tutorial 20 – Adding User Comments to Models

By Tiago Franco

Tutorial Application:  comments_recipe
Almost every application on the web allows users to post comments and provide feedback to almost every item (books, blog posts, other users, etc). This recipe will show you how to support user comments on Hobo.
Sometimes we want users to post comments to more than one table object. For example, suppose that we are developing a social network where users can enroll in basketball games and search for courts to play. We also want to allow users to post comments to games (e.g., users that didn’t win sometimes like to blame the referee) or provide feedback about the court (e.g., if it was suitable or not). In this recipe we will be adding comments to both games and courts. Because we are focused on the comments, we will ignore the attributes of games and courts.
First, create a Hobo application named “comments-recipe”:
> hobo new comments-recipe --setup
Now, edit the file config/application.rb and add the following line inside the c Class Application < Rails::Application..end block:

Figure 214: Editing the application name for the Comments Recipe

We will now add a model class to support the management of basketball games. This can be done with the following command:
> hobo g resource game name:string
Don’t forget to generate and run the migration. This can be done with:
> hobo g migration --migrate --default-name create_games

> rake db:migrate

Let’s run the application to perform a sanity check. We expect to see an image similar to the figure below.  


Figure 215: Home page for the Comments Recipe

Notice the games entry on the menu. If it is there, it means that the games controller is working fine.
To add comments support to the application, we need follow similar steps. First, we need to create the model with:
> hobo g resource comment
We will add the body attribute to hold the text of the user’s comment. Edit the file app/models/comment.rb and add the line number 6 as shown by the following figure:




Additionally, add line 10 and 11 from the same figure. Line 10 is used to keep track of the user that created the comment, while line 11 records the game that is being commented.
Some applications allow users to edit or delete their comments. But they never let a user change comments made by someone else. So we need to update the permissions of our comment model. Just edit the app/models/comment.rb and make sure the permissions are like the ones shown on the figure below:




Now, we only want users to create, edit or browse comments if a game is being shown (i.e. in game/show view). So we need to update line 5 of app/controllers/comments_controller.rb from:

auto_actions :all
To:
auto_actions :destroy
The result is shown on the figure below:



Line 7 also needs to be added, to allow comments to be created from the game/show view. Without this line the user won’t be able to comment a game when it is being displayed. Add the line to app/controllers/comments_controller.rb.
We now need to deal with the game/comment relation on the other end. Edit the file app/models/game.rb (and add lines 10, 12):




We’re just two steps away from testing our new feature: create and run the migration. 
But we already know how to do that. We need to execute the following commands in the command line:

> hobo g migration --migrate --default-name create_comments

> rake db:migrate

And we should be ready for a test drive. Create a user account (if you haven’t already done it), create a game and add two comments. The result should be something similar to:




Easy isn’t it? So let’s not waste time and start working on the courts!
Let’s create a model to store the courts on our database.
> hobo g resource court name:string 
Because we are not interested in the details of the courts, let’s just create and run the migration:
> hobo g migration --migrate --default-name create_courts
> rake db:migrate
Et voila! As we can see in the figure below the application can now store courts.

Figure 221: Comments' Recipe with support for courts

Now we need to update the existing infrastructure to allow users to comment the courts. Since we already have a comment model, let’s just make a few updates so that it can also be related with a court.

First, we need to update the existing comment model. Add the contents of line 12 on figure below to the file app/models/comment.rb. This will allow a comment to be related with a court.

Figure 222: Adding courts to comments

Then update the court model, file app/models/court.rb, to deal with the other end of the one-to-many relationship. Update the file with the contents of line 10 and line 12:




We now need to update the CommentsController to allow the creation of comments in the court/show page. Add line 8 as seen in the figure below to the file app/controllers/comments_controller.rb.


Figure 224: Modifying auto_actions for the comments_controller (allow court)


Finally, create and run the migrations using the following commands:

> hobo g migration --migrate --default-name add_comments_to_courts

> rake db:migrate

Now, create a court and insert a new comment. It seems that the application is asking to add a game to the comment. By default Hobo auto-generates forms to fill every attribute on the model. We need to tell the framework not to show the game list-box on the new comment form. 

This can be performed by adding line 14 below comment.rb (app/models).


Figure 225: Hiding court and game in the comment's form


Now you will be able to see something like the following:


Figure 226: View of the in-line "Add a Comment" form


In this recipe we have learned how to support comments to the application models. The example was performed with games and courts, but can easily be mapped to any Hobo based application in the wild.

Tutorial 21 – Replicating the Look and Feel of a Site

By Tom Locke

Introduction
Say we want a new Hobo app to have the same look-and-feel of an existing site. The really big win is if we can have this look and feel happen to our new app almost ‘automatically’. We want to be able to develop at “Hobo speed”, and have the look and feel “just happen”. This is not trivial to set up, but once it is, the payback in terms of development agility will be more than worth it. That is the topic of this chapter.

We’ll use the example of the standard web design used throughout all agencies within the U.S. Department of Agriculture. The authors have done substantial work with NIFA, The Cooperative State Research, Education, and Extension Service, so we will use their website (www.nifa.usda.gov) as an example:
 

Figure 228: Screen shot of the nifa.usda.gov home page

Note that, for now at least, this recipe will document how to create a close approximation to this theme. In particular, we’re going to skip some of the details that cannot be implemented without resorting to images. This is just to keep the recipe getting too long and complicated.

This will be as much a guide to general web-development best practices as it will be a lesson in Hobo and DRYML. The mantra when working with themes in Hobo is something already familiar to skilled web developers:

Separate content from presentation
The vast majority of common mistakes that are made in styling a web-app come under this heading. If this one idea can be understood and applied, you’re well on the way to:

Having the look-and-feel “just happen” as your site changes and evolves
Being able to change the theme in the future, without having to modify the app

Since CSS has been widely adopted, most web developers are familiar with this principle. So this is probably just a recap, but as a reminder about how this works:

“Content” describes what is on the page, but not what it will look like. In a Hobo app content comes from tag definitions, page templates and the application’s data of course.
“Presentation” describes how the page should look. That is, it describes fonts, colors, margins, borders, images and so on. In a Hobo app the presentation is handled essentially the same way as with any app, with CSS stylesheets and image assets.

Having said that, we need to inject a note of pragmatism:
Humans being visual animals, information can never truly be separated from the way it is displayed. The line is sometimes blurred and there are often judgment calls to be made.
The technologies we’ve got to work with, in particular cross-browser support for CSS, are far from perfect. Sometimes we have to compromise.

There’s probably an entire PhD thesis lurking in that first point, but let’s move on!
The current site
We’ll start with a look at the elements of the existing site that we’ll need to replicate. The main ones are:

A banner image:
 


A photo image that fits below the banner image:

Figure 230: The NIFA photo image

The main navigation bar:
 


A couple of styles of navigation panels:



 










And more navigation in the page footer:

 

One of the important things to notice at this stage, is that this is not just a “theme” in the Hobo sense of the word. Hobo themes are purely about presentation, whereas the “look and feel” of this site is a mixture of content elements and presentation.


That means we’re going to be creating three things to capture this look-and-feel:

Tag Definitions
A CSS stylesheet
Some image assets.

The current markup

The existing site makes extensive use of HTML tables for layout, and the various images in the page are present in the markup as <img> tags. In other words, the existing markup is very presentational.

So rather than create tag definitions out of the existing markup, we’ll be recreating the site using clean, semantic markup and CSS.

The other advantage of re-creating the markup is that it will be easier to follow Hobo conventions. There’s no particular need to do this, but it makes it a great deal easier to jump from one Hobo app to the next.

Building the new app
Let’s do this properly and actually follow along in a blank Hobo app. At the end of the recipe we’ll see how we could package this look-and-feel up and re-use it another app. To follow along, you should use Firefox and the Firebug extension you can find at http://getfirebug.com.



> hobo nifa-demo
> cd nifa-demo
> hobo g migration

If you fire up the server, you’ll see the default Hobo app of course:


Figure 234: The NIFA Demo default home page

First thing to do is change the heading “Nifa” to “NIFA” in \views\taglibs\applicationl.dryml since it is an acronym for the National Institute of Food and Agriculture:


Figure 235: Using the "app-name" tag to change the default application name

Now we can start to make it look like the page we’re after. We’ll take it step by step.
Main background and width
With the Firebug add-on for Firefox I can tell that the NIFA background color is #A8ACB7:

Figure 236: Using Firebug to locate the background color

Now switching to the Hobo NIFA Demo application, Firebug tells us (click the inspect button, then click on the background) that the CSS rule that sets the current background comes from clean.css and looks like:


Figure 237: Using Firebug to find the images used by Hobo for the default background

Anything we add to application.css (it is empty by default) will override clean.css. So I’m going to add this rule to  public/stylesheets/application.css:

html, body { background:#A8ACB7 }


Figure 238: Adding the new background color to "application.css"
Again, using Firebug on the NIFA Demo app (by clicking on the <body> tag in the HTML window) I can see that the width is set on the body tag:

body { ... width: 960px; ... }

Back in NIFA, I can right click the banner image and chose “View Image”, and Firefox tells me its width is 766 pixels. So in application.css I add

body { width: 766px; }

Note we’ve not changed any markup yet - that’s how we like it.
Account navigation
These are the log-in and sign-up links in the top right. They are not on the NIFA site, but if the app needed them, the place they are in now would be fine, so we’ll leave them where they are.
Search
The page header has a search-field that we don’t want. To get rid of this we’ll customize the <page> tag. We need to do this in application.dryml:


Figure 239: First pass at modifying "application.dryml"

<extend tag="page">
  <old-page merge without-live-search>
  </old-page>
</extend>

So now we have made a change to the markup, but that makes perfect sense, because here we wanted to change what’s on the page not what stuff looks like.

The Banner
Again, using Firefox’s “View Image”, it turns out that the existing banner is in fact two images. 

This one:


And this one:


To add these images without changing the markup, we need to use CSS’s background-image feature. One major limitation of CSS is that you can only have one background image per element. That won’t be a problem, but to understand our approach, first take a look at a simplified view of the page markup that we’re working with:

<html>
  <head>...</head>
  <body>
    <div class="page-header">
      <h1 class="app-name">NIFA Demo</h1>
    </div>
    ...
  </body>
</html>

Notice that this image:


Is essentially a graphical version of that <h1> tag, so we’ll use CSS to make that same <h1> be rendered as an image. The existing text will be hidden, by moving it way out of the way with a text-indent rule. First we need to save that image into our public/images folder. 

The CSS to add to application.css is:
div.page-header { padding: 0; }

div.page-header h1.app-name {
    text-indent: -10000px;
    background: url(..\images\banner_nifa.gif) no-repeat;
    padding: 0; margin: 0;
    height: 62px;

}


Figure 241: How to reference the banner gif in "application.css"

OK that was a bit of a leap. Why padding: 0px for the page-header, for example? The fact of the matter is that working with CSS is all about trial and error. Using Firebug to figure out what rules are currently in effect, flipping back and forth between the stylesheet in your editor and the browser. Try experimenting by taking some of those rules out and you’ll see why each is needed.
Now for the photo part of the banner. Again, save it to public/images, then add some extra properties to the div.page-header selector, so it ends up like:

div.page-header {
    padding: 0; 
    background: url(..\images\banner_photo.jpg) no-repeat 0px 62px;
    height: 106px;
}



Figure 242: View of the NIFA Demo login page

Taking shape now, except the main navigation panel (“Home” tag) is hovering on top of the photos:

Figure 243: The Navigation Panel before refactoring

Navigation
The existing navigation bar is created entirely with images. It’s quite common to do this, as it gives total control over fonts, borders, and other visual effects such as color gradients. The downside is that you have to fire up your image editor every time there’s a change to the navigation.
This doesn’t sit very well with our goal to be able to make changes quickly and easily. So for this recipe we’re going to go implement the navigation bar without resorting to images. We’ll lose the bevel effect, but some might think the end result is actually better - cleaner, clearer and more professional looking. 

Our app only has a home page right now, so first let’s define a fake navigation bar to work with. In application.dryml:

<def tag="main-nav">
  <navigation class="main-nav">
    <nav-item href="">Home</nav-item>
    <nav-item href="">About Us</nav-item>
    <nav-item href="">Grants</nav-item>
    <nav-item href="">Forms</nav-item>
    <nav-item href="">Newsroom</nav-item>
    <nav-item href="">Help</nav-item>
    <nav-item href="">Contact Us</nav-item>
  </navigation>  
</def>


Figure 244: View of our first pass at the main navigation menu

Use Firebug’s “Inspect” button to find the navigation bar. You’ll see that it’s rendered as a <ul> list, which is generally considered good practice; it is a list of links after all. There are several things wrong with the appearance of the navigation at this point:
It’s in the wrong place - we want to move it down and to the right.
Needs to be shorter, and the spacing of the items needs fixing
The font needs to be smaller, and not bold
The background color needs to change, as do the colors when you mouse-over a link
Now this is not a CSS tutorial, so we’re not going to explain every last detail, but we’ll build it up in a few steps which will help to illustrate what does what. First update the rules for div.page-header in application.css so they look like:

div.page-header {
    padding: 0; 
    background: white url(..\images\banner_photo.jpg) no-repeat 0px 62px;
    height: 138px;
}

And add:

div.page-header .main-nav {
    position: absolute; bottom: 0; right: 0; 
}


Figure 245: Still need more to fix the top navigation menu...

The nav-bar still looks wrong.  We’ll now fix the sizing and placement. Update the new rule (div.page-header .main-nav) and add new ones, and colors.  The entire application.css looks  like this so far:

html, body { background:#A8ACB6 }
body { width: 766px; }
 
div.page-header {
    padding: 0;
    background: white url(../images/banner_photo.jpg) no-repeat 0px 62px;
    height: 138px;
}
 
div.page-header h1.app-name {
    text-indent: -10000px;
    background: url(../images/banner_nifa.gif) no-repeat;
    padding: 0; margin: 0;
    height: 55px;
}
 
div.page-header .main-nav { 
    position: relative; 
	top: 63px; 
    height: 21px; 
	width: 100%; 
	line-height: 21px; 
	padding: 0;  
    text-align: right;  
    background: #313367;  
} 
 
div.page-header .main-nav li { 
    margin: 0; 
	padding: 0 0 0 4px; 
    display:inline; 
	float:none; 
    border-left: 1px dotted #eee; 
	background: #313367; 
    color: silver; 	
} 
 
div.page-header .navigation.main-nav li a { 
    padding: 3px 8px; 
	margin: 0; 
    font-weight: normal; 
	display:inline; 
	font-size: 12px; 
    background: #313367;
    color: silver; 	
} 

div.page-header .navigation.main-nav li.current a {
    background: #313367;
    color: white; 	
}
 
div.page-header .navigation.main-nav li a:hover { 
	 background: #A9BACF;
	  color: black;
	
}


Note that we had to make the last two selectors a bit more specific, in order to ensure that they take precedence over rules in the “Clean” theme.
The page header should be done at this point:


Figure 246: The fixed NIFA man navigation bar

The sidebars
The existing site has both left and right sidebars. We’ll add those now. The first step is to add the three content sections to the <page> tag in application.dryml. We’ve already extended <page>, so modify the DRYML you already have to look like:

<extend tag="page">
  <old-page merge without-live-search>
    <content: replace>
      <section-group class="page-content">
        <aside param="aside1"/>
        <section param="content"/>
        <aside param="aside2"/>
      </section-group>
    </content:>
  </old-page>
</extend>

We’ve replaced the existing <content:> with a <section-group> that contains our two <aside> tags and the main <section>.

To try this out, we’ll insert some dummy content in app/views/front/index.dryml. Edit that file as follows:

<page title="Home">
  <body: class="front-page"/>
  <aside1:>Aside 1</aside1:>
  <content:>Main content</content:>
  <aside2:>Aside 2</aside2:>
</page>

You should see something like:


Figure 247: View of the default three-column formatting

Obviously we’ve got a bunch of styling to do. First though, let’s add the content for the left sidebar. This is the “search and browse” panel, which is on every page of the site, so let’s define it as a tag in application.dryml:

<def tag="search-and-browse" attrs="current-subject"> 
  <div class="search-and-browse"> 
    <div param="search"> 
      <h3>Search NIFA</h3> 
      <form action=""> 
        <input type="text" class="search-field"/> 
        <submit label="Go"/> 
      </form> 
      <p class="help"><a href="">Search Help</a></p> 
    </div> 
    <div param="browse-by-audience"> 
      <h3>Browse by Audience</h3> 
      <select-menu first-option="Information for..." options="&[]"/>   
    </div> 
    <div param="browse-by-subject"> 
      <h3>Browse by Subject</h3> 
      <navigation current="&current_subject"> 
        <nav-item href="/">Agricultural &amp; Food Biosecurity</nav-item> 
        <nav-item href="/">Agricultural Systems</nav-item> 
        <nav-item href="/">Animals &amp; Animal Products</nav-item> 
        <nav-item href="/">Biotechnology &amp; Geneomics</nav-item> 
        <nav-item href="/">Economy &amp; Commerce</nav-item> 
        <nav-item href="/">Education</nav-item> 
        <nav-item href="/">Families, Youth &amp; Communities</nav-item> 
      </navigation> 
    </div> 
  </div>
</def>

A few points to note about that markup:
We’ve tried to make the markup as “semantic” as possible – it describes what the content is, not what it looks like.
We’ve added a few params, so that individual pages can customize the search-and-browse panel. Each param also gives us a CSS class of the same name, so we can target those in our stylesheet.
We’ve used <navigation> for the browse-by-subject links. This gives us the ability to highlight the current page as the user browses.

Because the search-and-browse panel appears on every page, lets call it from our master page tag (<extend tag="page">). Change:
<aside param="aside1"/>
To:
<aside param="aside1"><search-and-browse/></aside>

Then remove the <aside1:>Aside 1</aside1:> parameter from front/index.dryml.


Figure 248: View of the left panel contact without styling

Now we need to style this panel. After a good deal of experimentation, we get to the following CSS:

div.page-content, div.page-content .aside { background: white; }

.aside1 { width: 173px; padding: 10px;}

.search-and-browse {
    background: #A9BACF;
    border: 1px solid #313367;
    font-size: 11px;
    margin: 4px;
}

.search-and-browse h3 {
    background: #313367; color: white;
    margin: 0; padding: 3px 5px;
    font-weight: normal; font-size: 13px; 
}

.search-and-browse a { background: none; color: #000483;}

.search-and-browse .navigation { list-style-type: circle; }
.search-and-browse .navigation li { padding: 3px 0; font-size: 11px; line-height: 14px;}
.search-and-browse .navigation li a { border:none;}

.search-and-browse .search form { margin: 0 3px 3px 3px;}
.search-and-browse .search p { margin: 3px;}
.search-and-browse .search-field { width: 120px;}
.search-and-browse .submit-button { padding: 2px;}

.search-and-browse .browse-by-audience select { margin: 5px 3px; width: 92%;}
With that added to application.css you should see:


Figure 249: View of the left panel content with correct styling

OK - let’s switch to the right-hand sidebar.
If you click around the site you’ll see the right sidebar is always used for navigation panels, like this one:



You’ll also notice it’s missing from some pages, which is as easy as:

<page without-aside2/>

It seems like a good idea to define a tag that creates one of these panels, say:

<nav-panel>
  <heading:>Quick Links</heading:>
  <items:>
    <nav-item href="/">A-Z Index</nav-item>
    <nav-item href="/">Local Extension Office</nav-item>
    <nav-item href="/">Jobs and Opportunities</nav-item>
  </items:>
</nav-panel>

We’ve re-used the <nav-item> tag as it gives us an <li> and an <a> which is just what we need here.
Now add the definition of <nav-panel> to your application.dryml:

<def tag="nav-panel">
  <div class="nav-panel" param="default">
    <h3 param="heading"></h3>
    <div param="body">
      <ul param="items"/>
    </div>
  </div>
</def>

Notice that we defined two parameters for the body of the panel. Callers can either provide the <items:> parameter, in which case the <ul> wrapper is provided, or, in the situation where the body will not be a single <ul>, they can provide the <body:> parameter.
OK let’s throw one of these things into our page. Here’s what front/index.dryml needs to look like:

<page title="Home">
  <body: class="front-page"/>
  <content:>Main content</content:>
  <aside2:>

    <nav-panel>
      <heading:>Grants</heading:>
      <items:>
        <nav-item href="/">National Research Initiative</nav-item>
        <nav-item href="/">Small Business Innovation Research</nav-item>
        <nav-item href="/">More...</nav-item>
      </items:>
    </nav-panel>

    <nav-panel>
      <heading:>Quick Links</heading:>
      <items:>
        <nav-item href="/">A-Z Index</nav-item>
        <nav-item href="/">Local Extension Office</nav-item>
        <nav-item href="/">Jobs and Opportunities</nav-item>
      </items:>
    </nav-panel>

  </aside2:>
</page>

And here’s the associated CSS – add this to the end of your application.css:

.aside2 { margin: 0; padding: 12px 10px; width: 182px;}
.nav-panel {border: 1px solid #C9C9C9; margin-bottom: 10px;}
.nav-panel h3 {background:#A9BACF; color: #313131; font-size: 13px; padding: 3px 8px; margin: 0;}
.nav-panel .body {background: #DAE4ED; color: #00059A; padding: 5px;}
.nav-panel .body a {color: #00059A; background: none;}
.nav-panel ul {list-style-type: circle;}
.nav-panel ul li { margin: 5px 0 5px 20px;}


Figure 250: View of the right panel content with styling


Main content
The main content varies a lot from page to page, so let’s just make sure that the margins are OK, and leave it at that. First we need some content to work with, so in front/index.dryml, replace:

<content:>Main content</content:>
With:
<content:>
  <h2>National Institute of Food and Agriculture</h2>
  <p>Main content goes here...</p>
</content:>

On refreshing the browser it seems there’s nothing else to do. This looks fine:

Figure 251: View of the main content panel

The footer
The footer is the same throughout the site. Let’s define it as a tag and add it to our main <page> tag. Here’s the definition for application.dryml:

<def tag="footer-nav">
     <ul>
      	<nav-item href="/">NIFA</nav-item>
      	<nav-item href="/">USDA.gov</nav-item>
      	<nav-item href="/">Site Map</nav-item>
      	<nav-item href="/">Policies and Links</nav-item>
      	<nav-item href="/">Grants.gov</nav-item>
		<nav-item href="/">CRIS</nav-item>
		<nav-item href="/">REEIS</nav-item>
		<nav-item href="/">Leadership Management Dashboard</nav-item>
		<nav-item href="/">eXension</nav-item>
      	<nav-item href="/">RSS</nav-item>
    </ul>
/def>

And add this parameter to the <extend tag="page">:

<footer: param><footer-nav/></footer:>

Note: Since Hobo already includes a page-footer div out-of-the-box, we don’t need to create this div in DRYML.  If we did, we would end up with a duplicate and this would distort the footer. 


And finally, the CSS. To get the corner graphic that we’ve used here, you need to right-click and “Save Image As” on the bottom left corner in the existing site:

.page-footer {
    background: white url(../images/footer_corner_left.gif) no-repeat bottom left;
    overflow: hidden; height: 100%;
    border-top: 1px solid #B8B8B8;
    font-size: 12px; line-height: 10px;
    padding: 5px 0px 10px 40px;
}

.page-footer ul { list-style-type: none; }
.page-footer ul li { float: left; border-right: 1px solid #2A049A; margin: 0; padding: 0 5px;}
.page-footer ul li a {border:none; color: #2A049A;}

There’s one CSS trick in there that is work a mention. In the .page-footer section, we’ve specified:

overflow: hidden; height: 100%;

This is the famous “self clearing” trick. Because all the content in the footer is floated, without this trick the footer looses its height.


Figure 252: NIFA Demo with final footer styling

That pretty much brings us to the end of the work of reproducing the look and feel. We should now be able to build out our application, and it will look right “automatically”. In practice you always run into small problems here and there and need to dive back into CSS to tweak things, but the bulk of the job is done.
The next question is - how could we make several apps look like this without repeating all this code?  That is the subject of our next tutorial. 
Tutorial 22 - Creating a “Look and Feel” Plugin for Hobo

By Tom Locke
In this tutorial we will start with the results of Tutorial 21.  To re-use this work across many apps, we’ll use the standard Rails technique - create a plugin. 

The plugin will contain:

A DRYML taglib with all of our tag definitions
A Public directory, containing our images and stylesheets

Somehow the idea of “creating a plugin” seems like a big deal, but it’s there’s really nothing to it. Pretty much all we’re going to do is move a few files into different places.

Here is the content of a batch file to create the folders and move the files:


Figure 253: Batch file with commands to create the plugin folders and content

Or, as individual commands:

> md vendor\plugins\nifa
> cd vendor\plugins\nifa
> md taglibs
> md public
> md public\nifa
> md public\nifa\stylesheets
> md public\nifa\images
> cd ..\..\..
> copy app\views\taglibs\application.dryml  vendor\plugins\nifa\taglibs\nifa.dryml
> copy public\stylesheets\application.css vendor\plugins\nifa\public\stylesheets\nifa.css
> copy public\images\* vendor\plugins\nifa\public\nifa\images
(That last command will also copy rails.png into the plugin, which you probably want to delete).
We’ve copied the whole of application.dryml into our plugin, because nearly everything in there belongs in the plugin, but it does need some editing:
At the top, remove all of the includes, the <set-theme> and the definition of <app-name>
We need to make sure our stylesheet gets included, so add the following parameter to the call to <old-page>

<append-stylesheets:>
   <stylesheet name="\nifa\stylesheets\nifa.css"/>
 </append-stylesheets:>

The new nifa.dryml will be:

# nifa.drynl

<append-stylesheets:>
   <stylesheet name="\nifa\stylesheets\nifa.css"/>
 </append-stylesheets:>


# Add this remove the live search and add sidebars

<extend tag="page">
  <old-page merge without-live-search>
   
  # need this to acces the nifa.css stylesheet 
   <append-stylesheets:>
      <stylesheet name="\nifa\stylesheets\nifa.css"/>
    </append-stylesheets:>
   #    
    <content: replace>
      <section-group class="page-content">
        <aside param="aside1"><search-and-browse/></aside>
         <section param="content"/>
        <aside param="aside2"/>
      </section-group>
    </content:>
    <footer: param><footer-nav/></footer:>
  </old-page>
</extend>

# Replace the default navigation bar
<def tag="main-nav">
  <navigation class="main-nav">
    <nav-item href="">Home</nav-item>
    <nav-item href="">About Us</nav-item>
    <nav-item href="">Grants</nav-item>
    <nav-item href="">Forms</nav-item>
    <nav-item href="">Newsroom</nav-item>
    <nav-item href="">Help</nav-item>
    <nav-item href="">Contact Us</nav-item>
  </navigation>  
</def>

# new tag 
<def tag="search-and-browse" attrs="current-subject"> 
  <div class="search-and-browse"> 
    <div param="search"> 
      <h3>Search CSREES</h3> 
      <form action=""> 
        <input type="text" class="search-field"/> 
        <submit label="Go"/> 
      </form> 
      <p class="help"><a href="">Search Help</a></p> 
    </div> 
    <div param="browse-by-audience"> 
      <h3>Browse by Audience</h3> 
      <select-menu first-option="Information for..." options="&[]"/>   
    </div> 
    <div param="browse-by-subject"> 
      <h3>Browse by Subject</h3> 
      <navigation current="&current_subject"> 
        <nav-item href="/">Agricultural &amp; Food Biosecurity</nav-item> 
        <nav-item href="/">Agricultural Systems</nav-item> 
        <nav-item href="/">Animals &amp; Animal Products</nav-item> 
        <nav-item href="/">Biotechnology &amp; Geneomics</nav-item> 
        <nav-item href="/">Economy &amp; Commerce</nav-item> 
        <nav-item href="/">Education</nav-item> 
        <nav-item href="/">Families, Youth &amp; Communities</nav-item> 
      </navigation> 
    </div> 
  </div>
</def>

# Parameterized panel
<def tag="nav-panel">
  <div class="nav-panel" param="default">
    <h3 param="heading"></h3>
    <div param="body">
      <ul param="items"/>
    </div>
  </div>
</def>

# Footer parameterized tag
<def tag="footer-nav">
   <ul>
       <nav-item href="/">NIFA</nav-item>
      	<nav-item href="/">USDA.gov</nav-item>
      	<nav-item href="/">Site Map</nav-item>
      	<nav-item href="/">Policies</nav-item>
      	<nav-item href="/">Grants.gov</nav-item>
		<nav-item href="/">CRIS</nav-item>
		<nav-item href="/">REEIS</nav-item>
		<nav-item href="/">Leadership Management Dashboard</nav-item>
		<nav-item href="/">eXension</nav-item>
      	<nav-item href="/">RSS</nav-item>
    </ul>
</def>

Using the plugin

To try out the plugin, create a new blank Hobo app. There are then three steps to install and setup the plugin:
Step 1.   Copy vendor\plugins\nifa from nifa-demo  into vendor\plugins in the new app.

Step 2.  To install the taglib add:

<include src="nifa" plugin="nifa"/>

to application.dryml. It must be added after the <set-theme> tag.

Step 3. To install the public assets:

> copy vendor\plugins\nifa\public\* public

That should be it. Your new app will now look like the NIFA website, and the tags we defined, such as <nav-panel> will be available in every template.




Tutorial 23 – Using Hobo Lifecycles for Workflow

By Venka Ashtakala

Now that we have our “Four Table” application working the way we want, let’s add an approval process so that new recipes need to be approved by a user before they are published to the web.  

To do this we can take advantage of ‘Hobo Lifecycles‘, which is the Hobo answer to creating a workflow.  The workflow that we will define for this application is that a Recipe can exist in one of 2 states: “Not Published” and “Published” and that there will be two transitions: “Publish” and “Not Publish” which will move the Recipe from one state to the other. 

The “Publish” transaction will move the Recipe from the “Not Published” to “Published” state, while the “Not Publish” transaction will do the opposite.   Lastly we’ll make controller and view changes as necessary.

Tutorial Application:  four_table

Topic: HOBO Lifecycles

Steps

1. Setup the lifecycle.  Now that we know the functional requirements for the Recipe workflow we wish to implement we can start modifying our Four Table application.  We are going to add the Hobo Lifecycle definition to our Recipe model.  Let’s open up the /app/model/recipe.rb file and add the lifecycle do...end block:

[…]
belongs_to :country

lifecycle :state_field => :lifecycle_state do

state :not_published, :default => :true
state :published
    
transition :publish, { :not_published => :published }, :available_to => "acting_user if acting_user.signed_up?"
transition :not_publish, { :published => :not_published }, :available_to => "acting_user if acting_user.signed_up?"
    
end

# --- Permissions --- #
[…]


So what did we add exactly?  The lifecycle do..end block defines the lifecycle for a given model.  The :state_field argument specifies that we want the lifecycle to save the current state to a ‘lifecycle_state’ column in the table.  Within the block we have to define our states and transition actions.  

We define our states by using the ‘state’ keyword, which takes the state name and options as arguments.  So in this manner we have defined two states:

 :not_published
 :published

The :default => :true argument to the :not_published state, means that when the state is not defined, such as when the recipe is created, its initial state will be :not_published.  

After the state declarations, we have defined two transition actions using the ‘transition’ keyword.  The transition keyword requires a name, a hash that specifies the state transition and then options.  The first transition, :publish, specifies that when this action is executed, the Recipe’s state will go from :not_published to :published.  The :available_to argument specifies that this action can only be executed by a user that has signed up, so guests are not allowed to execute this action.  The second transition, :not_publish, changes the state from :published to :not_published, and limits the action to be available only to signed up users.

By adding the lifecycle behaviour to our model, we’ll need to generate and run a hobo g migration since a new ‘lifecycle_state’ column will be added to our recipes table.  At the command line, in your application directory, execute the following:

> hobo g migration

Select ‘m’ when prompted to migrate now, and then specify a name for this migration.	


2. Setup the lifecycle controls in your view.  Now that we have setup the lifecycle for our Recipe model, we need to expose the transition actions to our users.  HOBO makes this very easy by giving us a predefined dryml tag called <transition-buttons/> and we’ll use this tag on our Recipe listing page.

Open up the views/recipes/index.dryml page and change this code:

<table-plus fields="this, categories.count, categories,country"/>

to:

		 <table-plus fields="this, categories.count, categories, country">
	   	<controls:>
     <transition-buttons/>
  </controls:>
</table-plus>

By using the <controls:> parameter tag in table-plus, it allows us to insert an extra column at the end of the table where we can place action buttons or links.  There we use the <transition-buttons/> tag to specify that lifecycle transition buttons should show for any actions that are available for the current user.  

3. Setup the lifecycle actions in the controller.  We need to make a couple of changes to our Recipes controller:
 
The lifecycle actions need to be added to the controller so that the transition-buttons added above work correctly.  To do this, just open up:

/app/controllers/recipes_controller

 and replace the existing auto_actions list with this:

auto_actions :all
	
Specifying :all will also add support for the lifecycle actions.

4. Modify the Recipes Index page. The Recipes index page needs to be modified so that it only shows published recipes when the user is a Guest, and all the Recipes for logged in users.  So we need to do add the following named_scope to the Recipe model:

named_scope :viewable, lambda {|acting_user| {:conditions => “#{acting_user.signed_up??1:0}=1 or lifecycle_state='published'"  }}

…which returns all Recipes for logged in users, and only published recipes to Guest users. 

Note: The lambda block is used so that we can pass in a parameter to a named_scope, which in this case is a reference to the logged in user.

The Recipe controller index action needs to be modified so that when a Guest user is viewing the Recipe listing page, only “published” Recipes will be shown.  To do this, change the following line by inserting in the highlighted text:


Original:

hobo_index Recipe.apply_scopes(:search => [params[:search], :title, :body], :order_by  => parse_sort_param(:title, :country))

To:

hobo_index Recipe.viewable(current_user).apply_scopes(:search => [params[:search], :title, :body], :order_by  => parse_sort_param(:title, :country))

5. Try it out.  Restart your server to see the changes.  Following that, access the Recipe listing page as a Guest and you should see that there aren’t any Recipes showing (this is because all the Recipes are in a state of ‘Not Published’):


Figure 254: Guest view Recipes - All recipes are in state "Not Published"


If you login as a user you should see your recipes showing with ‘Publish’ buttons next to each row:


Figure 255: Recipes ready to Publish.


To publish a Recipe just click on the ‘Publish’ button.  For this example, I’ll publish the Omelet recipe.  After clicking on the button, I’ll get the show page for the Omelet.


Figure 256: Omelet recipe after being placed in the "Published" state


And if I go back to my Recipe listing page I see:


Figure 257: Recipe index with buttons for "Publish" and "Not Publish"

Since my Omelet recipe has been published, the only available action for it is to ‘Not Publish’ it.

If I go to the Recipe listing page as a Guest user, I should now see my Omelet recipe:


Figure 258: Guest user can only see the published Recipe

6. Improve the navigation. So at this point we are able to Publish and Not Publish our recipes, so our workflow is behaving as we expect.  But the navigation can be improved and would be cleaner if after we clicked on a transition button the page would just refresh instead of taking us to the show screen for the recipe.  To do this, we will need to override the default lifecycle actions in the Recipes controller.  

For each transition we define, hobo creates 2 controller actions, 1 for a GET request and 1 for a PUT request.  So, for the Publish transition action, hobo creates a publish action for GET requests, and a do_publish action for PUT  requests.  The publish action would be used if we wanted to show a form before executing the transition action, i.e.  if we wanted to collect comments from the user before he/she Publishes or Not Publishes, we could show a form with a comments box and a Publish/Not Publish submit button.  But in this example, we just want to configure the application so that after a Recipe is Published or Not Published, the browser should redirect back to the Recipe listing page.  To do this we’ll add the following 2 actions to our Recipe controller just after the index action:

  def do_publish
    do_transition_action :publish do
      redirect_to recipes_path
    end
  end

  def do_not_publish
    do_transition_action :not_publish do
      redirect_to recipes_path
    end
  end

These actions override the default hobo actions so that we can specify the page redirect after the transition has been executed.  Once you have added these actions, if you access the Recipe index page and click on a Publish or Not Publish button, you’ll just see the page get refreshed.  

So now you have a working Publish/Not Publish workflow for Recipes in the Four Tables application.

Note:  This example is a basic implementation of Hobo lifecycles, but, it does serve as a good introduction to its various features.  It is possible to implement workflows with numerous states and transitions, and the ability to implement more fine-grained security for each transition using the :available_to argument.  Consult the full Hobo Lifecycles overview at http://cookbook.hobocentral.net 
Tutorial 24 – Creating an Administration Sub-Site

By Bryan Larsen
This tutorial will show how you can create an administrative sub-site for a Hobo.   This will allow the administrator to create, update and destroy any database row without writing any view code. 
 
Generator steps 
Let’s add an admin sub-site to the project we created in the “Agile Project Manager” tutorial.  
\projects> hobo g admin_subsite --make-front-site 
\projects> hobo g front_controller admin::front --add-routes 


Figure 259: Generator console output for creating an admin sub-site

Model Modifications
We would like to “hide” our code table maintenance the admin sub-site.  Currently we have one code table, requirement_statuses (model = RequirementStatus).

Let’s first change all of the permissions for this model to “true”, as only an administrator will be able to access this sub-site:





Controller Modifications
We need to move the controller for RequirementStatus to the admin folder and modify it to be:

Class Admin::RequirementStatusesController < Admin::AdminSiteController 
      hobo_model_controller RequirementStatus 
      auto_actions :all 
end 


Figure 260: View of the Admin folder contents

At this stage you should be able to run your application.  If you browse to "/admin", you can create, remove, update and destroy any requirement status:


Figure 261: View of the Admin Sub-Site
 
Tutorial 25 – Using Hobo Database Index Generation

By Matt Jones

Defining effective indexes on your data can give massive database performance benefits in any application. To further this goal, Hobo’s migration generator attempts to provide useful indices without any additional code, and provides shorthand for defining indices.

The :index Option

Throughout the index generator API, the :index parameter is used to switch indexing on/off and specify an explicit name for an index. The convention is:

:index => true will switch on indexing for a field not indexed by default; the name used is the default name generated by Rails.
:index => false will switch off automatic indexing for a field.
:index => ‘name’ will specify a name for the generated index. Note that some databases require that index names be unique across the entire database, not just the individual table.

Note: Oracle’s 30-character limit for entity names causes problems with the default naming scheme that Rails uses for indices. The Oracle driver for ActiveRecord attempts to mitigate this by shortening overlong index names in add_index; unfortunately, this will break the generated down migrations (which rely on the original index names). The best short-term solution is to pass a manual index name parameter wherever possible.

Automatic Indexing
The belongs_to associations will automatically declare an index on their foreign key field; polymorphic belongs_to will declare a multi-field index on [association_type, foreign_key]. 

Example:

class SomeModel < ActiveRecord::Base
  
 hobo_model

  belongs_to :other_model
  belongs_to :another_model, :index => ‘some_random_name’
  belongs_to :fooable, :polymorphic => true
end

Will generate the following in an up migration:

add_index :some_models, :other_model_id
add_index :some_models, :another_model_id, :name => ‘some_random_name’
add_index :some_models, [:fooable_type, :fooable_id]

Lifecycle state fields will also be automatically indexed, as will the inheritance_column of an STI parent class.

Indexing in the ‘fields do’ block
Within the standard fields block, indexes can be declared as part of a field, just like the :required or :unique options. Fields that also have the :unique option will automatically declare a unique index.

Example:

class SomeModel < ActiveRecord::Base
  fields do
    name :string, :index => true
    unique_field :string, :unique, :index => ‘foo’
  end
end

Will generate the following in an up migration:

add_index :some_models, :name
add_index :some_models, :unique_field, :name => ‘foo’, :unique => true

Indexing in the model
More complicated indexes may need to be declared outside the fields block. For instance, specific slow-running SQL queries may benefit from a multi-field index. The index method provides a simple interface for specifying any type of index on the model.

Example:

class SomeModel < ActiveRecord::Base
  fields do
    last_name :string
    first_name :string
  end
  index [:last_name, :first_name]
end

Will generate the following in an up migration:

add_index :some_models, [:last_name, :first_name]

When declaring a multi-field index, the order is relevant - consult your database’s manual for more detail (for example, section 7.4.3 of the MySQL 5.0 Reference).

The index method currently supports two options:

:name - use to specify the name of the index. If not given, the Rails default will be used.
:unique - passing :unique => true will specify the creation of a unique index.

CHAPTER 6 – DEPLOYING YOUR APPLICATIONS

Introductory Comments
Tutorial 26 – Installing and using the Git Version Control System
Tutorial 27 – Rapid Deployment Using Heroku.com


Introductory Concepts and Comments

There isn’t much use in developing an application that you don’t put into production.  This chapter is devoted to helping you put together the tools necessary to use one of the most innovative cloud computing sites today—Heroku.com
Once you configure your computer to work with the source code configuration management software called “Git” and create your subscription with Heroku, you will be able to publish a new app in a manner of minutes.
Of course, if you are an experienced Rails developer you can publish any Hobo app on your existing infrastructure.  If you haven’t tried Heroku yet, I encourage you to do so.  This is the wave of the future.





Tutorial 26 – Installing and Using Git 

Git has become the standard distributed version control system for Ruby and Rails applications, in part due the success of the social coding site, http://github.com.  

On Github you will find thousands of public and private projects aided by the extremely useful Web 2.0 user interface designed with distributed coding in mind.  Hobo’s code base is located there.  You can access the source, view the change history, and view the branching and merging of code as members of the open source community participate:


Figure 262: Hobo source code on github.com

It is also where the Hobo gems are stored:

Figure 263: Hobo gems are also available on github.com

Barquin International also uses Github as the central hub for developing several large-scale Hobo projects that involve participants from several countries.
In this tutorial we will focus on the Windows user, as git is much easier for Mac OS X and Linux users. You only need to learn a few commands for basic usage.  There are many outstanding resources for more in-depth understanding, including the excellent https://peepcode.com/products/git-internals-pdf by Scott Chacon.
There is an excellent tutorial for Mac users:
http://help.github.com


Figure 264: Installing Git for Mac OSX

OK.  So let’s get the software we need for Git:

Figure 265: Download the mysysgit installer for Windows

Download and run the git installer for windows:


	

Figure 266: Running the Git Setup Wizard

Select the following options:

Figure 267: Git setup options

Select the “Use OpenSSH” option:

Figure 268: Select the OpenSSH option

Allow the installer to configure running git from the Windows command prompt:

Figure 269: Select to option to run Git from the Windows command prompt

Next select the CR/LF behavior option:

Figure 270: Select Windows style line endings

After the installation is complete, the release notes will be displayed.
Now download the PuTTYgen RSA/DSA secure key generator from this URL:
http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html
Run the downloaded puttygen.exe file to install:

Figure 271: Running the PuTTY Key Generator install

Open up the application and start the process of generating key pairs:

Figure 272: Generate SSH key pairs for use with Git


Saving the files with default names:

Figure 273: The default file names generated by PuTTYGen

Private key = “PrivateKey.ppk”
Public Key = “Publickey”
You will need to rename these and put them in the USERPROFILE environment setting default location that most systems will look.  

Figure 274: Locating your USERPROFILE setting

I was logged in as the user “Administrator” in windows when I tried to use the Heroku gem (see next chapter):

Figure 275: View of "no ssh public key found" error

So Heroku was looking for the file id_rsa.pub (since I was used the RSA option with PuttyGen) in the default folder:

C:\Documents and Settings\Administrator\.ssh


So we can move the keys as follows:

Figure 276: Naming your SSH key pairs

 (The known_hosts file will be created and updated automatically when you connect to Heroku.)

Now you are ready to use Git.  See the next chapter to learn how Git is used to deploy your application to Heroku.com.
Tutorial 27 – Rapid Deployment with Heroku

We have been following with great interest the development of Heroku for almost two years. I recently tracked down my initial “Invitation to Heroku Beta” email invitation:

Figure 277: The original Heroku beta invitation

According to Wikipedia, it has been in development since June of 2007, with an initial investment of about $3 million dollars.  It was one of the first to use the new Amazon Elastic Compute Cloud (EC2) as its infrastructure. http://aws.amazon.com/ec2/
For more details on this innovative architecture, see:
http://heroku.com/how/architecture
For information for pricing and options:
http://heroku.com/pricing#blossom-1

Figure 278: Using the free "Blossom" database hosting option on Heroku.com

For this tutorial, we are going to use the free “Blossom” version for apps under 5MB in size. In addition to choosing more storage capacity, you can add “Dynos” (processing power) to suit your needs, and choose your replication and backup options. The database backend provided by Heroku is PostgresSQL, a rock-solid choice in the open source world. 
Of course you can always host your database elsewhere and use Heroku for your Hobo or Rails front end.  The nice thing about Heroku is the database migration and setup is transparent, so you can develop your app using SQLite and then deploy your app to Heroku’s PostgresSQL back-end transparently.
For this tutorial we will use the “four_table” application will built in the earlier tutorials and deploy it to Heroku.
Step 1: Install and Configure git

If you haven’t done so already, please follow the instructions in Chapter 23 – Installing and Using git.

Step 2: Create an Account at Heroku.com

Go to http://heroku.com/signup:


Figure 279: Sign Up for a Heroku account


Enter the email address you wish to use for communication with Heroku.  Heroku will send a confirmation email with a link to access your account.



Figure 280: Heroku notification that "Confirmation email sent"


Going to you email to access the confirmation link you will need:


Figure 281: Locating your "Invitation to Heroku" email


When you click the confirmation link, you should see a screen similar to the following:


Figure 282: The "Welcome to Heroku" signup page

And then this when you finish:


Figure 283: The "Account Created" message at Heroku.com

The instructions that are displayed on the “Welcome to Heroku!” splash screen are tailored for the Mac or Linux user.  We’ll provide the Windows equivalents below.
Step 3: Install the Heroku Gem

Go to you command prompt and type the following command:

C:\Sites\tutorials>gem install heroku


Figure 284: Installing the Heroku Ruby gem


Note: The other four gems that are installed along with the Heroku gem.

Step 4: Use git to package your application

Initialize git for your app:

\four_table> git init

Tell git to add all the files in all folders to the project:

\four_table> git add .

Tell git to commit these additions and enter an optional message that helps for version control:
 
\four_table> git commit –m “My first Commit”

Step 5: Use the “heroku create” command to Initialize your application

Change your directory to c:\tutorials\my-first-app and then execute the command while in the root directory of the app.

\four_table> heroku create four_table



Figure 285: Console output from the "heroku create" command

Note: The first time you try to create using the heroku gem you will be prompted to enter your user name and password that you provided heroku while creating an account:


Looking at the output you can see that we could not create the application “four_table”, as Heroku does not allow an underscore in a name.  We need to change the name of our app and try again:

\four_table> heroku create four-table

And then: 

\four_table> git push heroku master


Figure 286: Using heroku git push
	

OK. So our app launched, but then crashed.  What we forgot to do is to inform Heroku to add the Hobo gem to our application.  We can do this by adding an instruction:


Figure 287: Telling Heroku where to find your application's gems


Create a text file with the name .gems in the application’s root folder.  Add the following text:

hobo –source gems.github.com


Now we need to use GIT again to add these changes and push them to Heroku:

\four_table> git add .
\four_table> git commit –m “Added .gems definition file”
\four_table> git push heroku master


Figure 288: Adding your “.gems” config file to your git repository


Note that the additional gems that Hobo uses (dependencies) were automatically installed as well.

Step 6: Migrate your database schema to Heroku

Your UI is up and running, but your database has not been migrated until you do this:
 
\four_table> heroku rake db:migrate




Figure 289: Migrating your database schema to Heroku.com


Step 7: Test your application

Log into Heroku.com to see the application URL:



Figure 290: Testing your Heroku app
http://four-table.heroku.com


Figure 291: Running the "Four Table"  app on Heroku.com

Note: You can set up your application to use an existing domain name instead of heroku.com.See the information located on this link:

http://docs.heroku.com/custom-domains

Step 8: Use the Taps gem to push data to your app on Heroku

The data we created in earlier tutorials has not yet been loaded to Heroku. However, we can easily do this with Heroku by installing the “taps” gem:

\four_table> gem install taps


Figure 292: Installing the Taps gem to upload data to Heroku.com

Note that several other dependencies are also installed along with Taps.

Now you can use the following single command to upload your existing (local) data to your version on Heroku:

\four_table> heroku db:push


Figure 293: Using "heroku db:push" to push data to your app on Heroku.com


The log indicates that six tables with a total of 23 records were sent. Let’s look at the live app to see:


Figure 294: The "Four Table" app on Heroku.com with data
 

Now let’s add a recipe for “Crab Cakes”:


Figure 295: Add a recipe on Heroku.com

Step 9: Pull changed data from Heroku

I can use the “pull” option to backup my change on Heroku to my local database:

\four_table> heroku db:pull


Figure 296: Pull changed data from Heroku.com to your local app

Pretty slick!  I now have 24 records on the local version--including my precious recipe for crab cakes.




















SECTION 3: HOBO UNDER THE HOOD
CHAPTER 7 – HOBO GENERATORS

Changes from Hobo 1.0 to Hobo 1.3 for Rails 3

Commands

hobo g migration
hobo g migration
ruby script/generate hobo_model_resource
hobo g resource
ruby script/generate hobo_model
hobo g model


Generator names

hobo_migration
migration
hobo_model_resource
resource
hobo_model
model

The Hobo generators have been rewritten from scratch to match the new  Rails 3 generator standards.

The Hobo generators have also been reorganized to fit to the new setup_wizard, and to be more DRY. indeed they often invoke each other from the inside when needed. 

Hobo Generators

The following command in any hobo application directory will show all the generators available:

> hobo g --help
(or) 
> rails g --help


Under the 'Hobo' group we find the hobo generators:

Hobo:
  hobo:admin_subsite
  hobo:assets
  hobo:controller
  hobo:front_controller
  hobo:i18n
  hobo:migration
  hobo:model
  hobo:rapid
  hobo:resource
  hobo:routes
  hobo:setup_wizard
  hobo:subsite
  hobo:subsite_taglib
  hobo:test_framework
  hobo:user_controller
  hobo:user_mailer
  hobo:user_model
  hobo:user_resource

You can have more help about any generator (e.g., the “hobo:resource” generator) by doing:

> hobo g resource --help
(which is the same as)
> rails g hobo:resource --help

Note: If you use the hobo command you can omit the 'hobo:' namespace prepended to hobo generators. 

The following options are common options for all the generators:

Runtime options:
  -q, [--quiet]    # Supress status output
  -f, [--force]    # Overwrite files that already exist
  -s, [--skip]     # Skip files that already exist
  -p, [--pretend]  # Run but do not make any changes

Note: The -p or --pretend option that can be passed to all generators. It will run the generator without actually produce any change, so it is very useful to see what a generator would do without eventually messing up your app.


hobo:setup_wizard

This is the generator that the hobo command invokes after creating the rails infrastructure. It calls others generators in the background, in order to customize the new application.
You can eventually invoke it manually (when you choose the --skip-setup options of the hobo command) or re-invoke it in order to overwrite any file of the original installation, but its common use is to be called internally by the hobo command.

In its default mode (interactive/wizard mode) the developer will be asked for any feature he possibly wants in his new application.

Here are the static options as they come from the --help option:

Options:

[--migration-migrate]                            # Generate migration and migrate
                                                 # Default: true
[--fixture-replacement=FIXTURE_REPLACEMENT]      # Use a specific fixture replacement
[--fixtures]                                     # Add the fixture option to the test
 						    # framework – default: true                                               
[--wizard]                                       # Ask instead using options
                                                 # Default: true
[--update]                                       # Run bundle update to install the missing gems
-i, [--invite-only]                                  # Add features for an invite only website
[--git-repo]                                     # Create the git repository with the 
[--front-controller-name=FRONT_CONTROLLER_NAME]  # Front Controller Name: Default: front                                             
[--gitignore-auto-generated-files]               # Add the auto-generated files to .gitignore
                                                 # Default: true
[--default-locale=DEFAULT_LOCALE]                # Sets the default locale
[--admin-subsite-name=ADMIN_SUBSITE_NAME]        # Admin Subsite Name
                                                 # Default: admin
[--user-resource-name=USER_RESOURCE_NAME]        # User Resource Name
                                                 # Default: user
-t, [--test-framework=TEST_FRAMEWORK]            # Use a specific test framework
                                                 # Default: test_unit
--locales=one two three]                         # Choose the locales
                                                 # Default: en
[--private-site]                                 # Make the site unaccessible to non-members
[--activation-email]                             # Send an email to activate the account
[--migration-generate]                           # Generate migration only
[--main-title]                                   # Shows the main title
                                                 # Default: true

Here they are in the order they get invokved by the setup_wizard:

--main-title 

This shows the main title 

hobo:assets  

No option / prompt: this generator copies a few asset files.

hobo:test_framework generator

--test-framework=TEST_FRAMEWORK  interactively set by: "Do you want to customize the test_framework?" and "Choose your preferred test framework: <availble frameworks>"

This gives you the opportunity to change the test framework, so the next generators invoked will use it for generating tests.

--fixtures 
 
Interactively set by "Do you want the test framework to generate the fixtures?"
 
This allows you to choose fixtures generation.

--fixture-replacement=FIXTURE_REPLACEMENT 
 
Interactively set by: "Type your preferred fixture replacement or <enter> for no replacement:"

You can use the fixture replacement that you prefer.

Site options:

--invite-only 

|interactively set by: "Do you want to add the features for an invite only website?"

It will pass this option to the next invoked generators in order to create an admin site and the resources used to invite a new user.

--private-site  

Interactively set by: "Do you want to prevent all access to the site to non-members? (Choose 'y' only if ALL your site will be private, choose 'n' if at least one controller will be public)" 

If 'n' the wizard will print the instruction to do the same with single controllers 

hobo:rapid generator

No option / prompt: this generator copies files

hobo:user_resource generator

--user-resource-name  

interactively set by: "Choose a name for the user resource [<enter>=user|<custom_name>]:"
 
You can choose a different name for the user model

--activation-emal
 
Interactively set by: "Do you want to send an activation email to activate the user?"
 
The user will receive an activation email containing an activation link.

hobo:front_controller generator

--front-controller-name 

Internally set by: "Choose a name for the front controller [<enter>=front|<custom_name>]:" 

You can change the front controller name

hobo:admin_subsite generator

--admin-subsite-name 

 interactively set by: "Choose a name for the admin subsite [<enter>=admin|<custom_name>]:" 

You can change the admin site name and it will be passed to the next invoked generators.

hobo:migration generator

The following option are interactively set by: "Initial Migration: [s]kip, [g]enerate migration file only, generate and [m]igrate [s|g|m]:"

--migration-migrate 

Generate and migrate.

--migration-generate
 
Generate only

      hobo:i18n generator

--locales  

Interactively set by: "Type the locales (space separated) you want to add to your application or <enter> for 'en':"

Copies the locale files for the supported locales

--default-locale 

I\\nteractively set by: "Do you want to set a default locale? Type the locale or <enter> to skip:" set the config.i18n.default_locale in the config/application.rb file  

Git repository options

--git-repo 

Interactively set by: "Do you want to initialize a git repository now?" 

This will initialize a git repository committing the new generated app

--gitignore-auto-generated-files 

Interactively set by: "Do you want git to ignore the auto-generated files?\n(Choose 'n' only if you are planning to deploy on a read-only File System like Heroku)"
 
This will add the auto-generated files to .gitignore. In read-only file systems like Heroku, this feature would be counter-productive, so in that case is better committing also the auto generated files.

NOTE: You use any of the generators used by the Setup  Wizard in order to override/restore any modified/generated file

hobo:admin_subsite

> hobo g admin_subsite [NAME=admin] [options]

Options:
  -i, [--invite-only]                            # Add features for an invite only website
      [--make-front-site]                        # Rename application.dryml to front_site.dryml
  -t, [--test-framework=NAME]                    # Test framework to be invoked
                                                 # Default: test_unit
      [--user-resource-name=USER_RESOURCE_NAME]  # User Resource Name
                                                 # Default: user

This generator is used internally by the setup_wizard, when the --invite-only option is true. 


hobo:assets

> hobo g assets

Used by the setup_wizard, this generator copies asset files


hobo:controller

> hobo g controller NAME

Options:
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit


hobo:front_controller

> hobo g front_controller [NAME=front] [options]

Options:
  -i, [--invite-only]                            # Add features for an invite only website
      [--add-routes]                             # Modify config/routes.rb to support the front controller
                                                 # Default: true
  -t, [--test-framework=NAME]                    # Test framework to be invoked
                                                 # Default: test_unit
   -d, [--delete-index]                             # Delete public/index.html
                                                    # Default: true
      [--user-resource-name=USER_RESOURCE_NAME]     # User Resource Name
                                                    # Default: user

Used by the hobo:setup_wizard generator


hobo:i18n

> hobo g i18n [en it ...]

Used by the hobo:setup_wizard generator, it creates the locale files for i18n. You can use it to add any supported language at any point in the development lifecycle.


hobo:migration

$ hobo g migration [NAME] [options]

Options:
  -g, [--generate]      # Don't prompt for action - generate the migration
  -m, [--migrate]       # Don't prompt for action - generate and migrate
  -n, [--default-name]  # Don't prompt for a migration name - just pick one
  -d, [--drop]          # Don't prompt with 'drop or rename' - just drop everything

Used by the setup_wizard generator and by the user when needed. It is actually part of hobo_fields, so it can be used outside of hobo.


hobo:model

$ hobo g model NAME [field:type field:type] [options]

Options:
  [--timestamps]  # Indicates when to generate timestamps

Creates a new hobo model and all the related files. It actually invokes the ActiveRecord generator and injects the code needed to hobo.


hobo:rapid

> hobo g rapid

Used by the setup_wizard, this generator just copy a few assets in order to make Rapid work


hobo:resource

> hobo g resource NAME [field:type field:type] [options]

Options:
  [--timestamps]  # Indicates when to generate timestamps

Use this generator io reate resource (model + controller + files) of called NAME, adding fields as needed. The value for NAME must be singular.


hobo:routes

> hobo g routes  

This generator prepares the automatic routes for your application. It is automatically used internally, so you should not use it manually. You can customize the path where it will create the routes in config/application.rb setting the config.hobo.routes_path


hobo:subsite

> hobo g subsite [options]

Options:
  -i, [--invite-only]                            # Add features for an invite only website
      [--user-resource-name=USER_RESOURCE_NAME]  # User Resource Name
                                                 # Default: user
  -t, [--test-framework=NAME]                    # Test framework to be invoked
                                                 # Default: test_unit
      [--make-front-site]                        # Rename application.dryml to front_site.dryml

You can use this generator to create a new custom subsite.




hobo:subsite_taglib

> hobo g subsite_taglib NAME [options]

Options:
  -i, [--invite-only]                            # Add features for an invite only website
      [--user-resource-name=USER_RESOURCE_NAME]  # User Resource Name
                                                 # Default: user

Used internally when a subsite is generated in order to generate the subsite tag library.


hobo:test_framework

$ hobo g test_framework NAME [options]

Options:
      [--fixture-replacement=FIXTURE_REPLACEMENT]  # Use a specific fixture replacement
      [--update]                                   # Run bundler update to install missing       gems
      [--fixtures]                                 # Add the fixture option to the test framework
                                                   # Default: true
  -t, [--test-framework=TEST_FRAMEWORK]            # Use a specific test framework
                                                   # Default: test_unit

Used internally by the setup_wizard (see the "invoke hobo:test_framework generator" step above)


The following generators are for the user resource, and are:

hobo:user_controller

> hobo g user_controller [NAME=users] [options]

Options:
  -i, [--invite-only]          # Add features for an invite only website
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

Used internally by the setup_wizard for the user resource.


hobo:user_mailer

$ hobo g user_mailer [NAME=user] [options]

Options:
  -i, [--invite-only]          # Add features for an invite only website
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit
      [--activation-email]     # Send an email to activate the account

Used internally by the setup_wizard for the user resource


hobo:user_model

$ hobo g user_model [NAME=user] [options]

Options:
  -i, [--invite-only]                            # Add features for an invite only website
      [--activation-email]                       # Send an email to activate the account
      [--timestamps]                             # Indicates when to generate timestamps
      [--admin-subsite-name=ADMIN_SUBSITE_NAME]  # Admin Subsite Name
                                                 # Default: admin

Used internally by the setup_wizard for the user resource.
hobo:user_resource

$ hobo g user_resource [NAME=user] [options]

Options:
  -i, [--invite-only]       # Add features for an invite only website
      [--activation-email]  # Send an email to activate the account

Used internally by the setup_wizard for the user resource

Automatically Generated DRYML Tags 

Rapid generates a set of four complex tags for each model in In pages.dryml:

 <index-page>
 <new-page>
 <show-page> 
 <edit-page> 

These auto-generated tags are invoked by the corresponding controller action (index, new, show or edit) to render view templates corresponding to each action.  

The other three fundamental actions--create, update and destroy--do not have their own Hobo page. They appear as links within the four auto-generated tags, some invoked within the Rapid <a> tag (similar to the HTML <a> hyperlink tag), or the <submit> or <delete-button> tag. The four tags that are used to render templates plus the three that appear as links or buttons total to the seven actions we repeatedly cite.

Tag definitions for the four basic tags begin like this:

<def tag="index-page" for="Contact">
   ... 
There is a lot going on in the tag definitions in pages.dryml that you might not fully understand yet. This includes calls to HTML tags with parameterization syntax (you see params declarations), unfamiliar tags like <collection> and so forth. 
The figure below summarizes some important information about the four basic tags:
Tag Name
Controller Action
Main Data Tags
Actions Linked
<index-page>
index (list )
<collection> 
new
<new-page>
new
<form>
create
<show-page>
show
<name>,
<field-list> <collection> ( for associated models)
edit
<edit-page>
edit
<form> 
update

Figure 297: Hobo Rapid action related tags

The content of the four table columns is explained below:

Tag Name:  This tag name is what is the text used to invoke the tag within a Hobo template or application.dryml (see below).
Controller Action:  indicates the action that calls the particular tag, which is rendered as a Hobo view template.
Main Data Tags:  Indicates the most used sub-tags responsible for data input and output. Other sub-tags handle formatting tasks.
Actions Linked:  indicates which actions have tags which link to other actions. 
Note: Linked actions do not appear explicitly as a tag but as attributes of the <a> tag or implicitly within the <submit> or <delete-button> tag.

Each of the four pages tags calls tags in the forms.dryml and cards.dryml file libraries. The <show-page> and <edit-page> tag explicitly call <form> tags within forms.dryml. The <index-page> and <edit-page> tags call the <card> tags to display lists or individual records but DO NOT do so explicitly. 

Note: <index-page> and <show-page> call <card> tags implicitly through the <collection>, <field-list> and <name> tags. This does not mean, for example that <field-list> only uses <card> tags. It uses its polymorphic capability to know what type of page tag it is being called from to determine what to do.

Application.dryml file. Like the pages.dryml file, this is also a repository for tag definitions. A tag definition placed here with the same name as a tag definition in pages.dryml, forms.dryml or cards.dryml auto-generated libraries will override the definition in these libraries. Additional definitions may also be placed in this library file and will be available to all view templates within the application.

A typical use for this file is to copy a tag definition from an auto-generated  library and then make edits to it in application.dryml.

Note: Application.dryml (as of Hobo 0.8.9) is the only library that permits tag definitions that are extensions of other tags that you first learned about in the tutorials. It is anticipated that Hobo 1.0 will allow extensions in other dryml files.
View templates. View templates are stored within view directories carrying the plural of the model name. Hobo view templates have the .dryml extension in contrast to the .erb  or .rhtml (older) extension of Rails templates. You can of course use these template types since Hobo is a Rails application, but you probably will not need to.
View layouts. Rails has a layout file to handle markup that is common to many templates such as header and footer information. Since it is so easy to use DRYML tags, you will probably find it unnecessary to use layouts.
Template Processing Order. The diagram below outlines the precedence logic for Hobo rendering of templates. One very important issue to keep straight is the difference between tag definitions and tag usage. 



Figure 298: Hobo precedence logic for action tags

In pages.dryml or application.dryml, there are only tag definitions. Hobo takes these definitions and creates tags on the fly from which it renders templates. You never actually see the tags anywhere in the application.  If you have coded your own template (e.g., show.dryml) you may have both tag definitions and tag usage within that template file. Remember tag definitions begin with the <def> tag and tag usage invokes the tag by name, e.g., <index-page> in the above example. 


CHAPTER 8 – THE HOBO PERMISSIONS SYSTEM

The Hobo Permission System (aka “permissions”) is an extension to Rails Active Record that allows you to define which actions on your models are permitted by which users. 

Hobo’s controllers and DRYML tag libraries use this information to automatically customize their behavior according to your definitions.

Introduction

One of the core pieces of the Hobo puzzle is the permission system. The permission system itself lives in the model layer - it is a set of extensions to Active Record models. It’s not a particularly complex set of extensions but the overall effect in Hobo is very powerful. This comes not so much from the permission system itself, but from how it is used. Hobo’s controllers use the permission system to decide if a given request is allowed or not. In the view layer, the Rapid tag library uses the permission system to decide what to render for the currently logged in user.

To understand how it all fits together, it’s helpful to be clear about this distinction: 

The permission system is a model level feature, but it is used in both the controller and view layers. 

This guide will be mostly about how it all works in the model layer, but we’ll also talk a little about how the controllers and tags use the permissions.

At its heart, the permission system is fairly simple, it just provides methods on each model that allow the following four questions to be asked:

Is a given user allowed to:

Create this record?
Update the database with the current changes to this record? (Thanks to Active Record’s ability to track changes)
Destroy the current record?
View the current record, or an individual attribute?.

There is also a fifth permission, which is more of a pseudo permission. Can this user:

Edit a specified attribute of the record

We call this pseudo permission because it is not a request to actually do something with the record. It is more like asking: if, at some point in the future, the user tries to update this attribute, will that be allowed? Clearly edit permission is closely related to update permission, but it’s not quite the same. In fact, you often don’t need to declare edit permissions because Hobo can figure them out from your update permission. We’ll cover this in more detail later, but for now just be aware that edit permission is a bit of an odd-one-out.

Defining permissions

In a typical Hobo app, the place where the permission system is most prominent in your own code is your permission declarations. These are methods, which you define on your models, known as “permission methods”. These methods are where you tell the permission system who is allowed to do what. The permission methods are called by the framework - it is unusual to call them yourself.

The four basic permission methods

When you generate a new Hobo model, you get stubs for the following methods.

def create_permitted?
def update_permitted?
def destroy_permitted?
def view_permitted?(attribute)

The methods must return true or false to indicate whether or not the operation is allowed. We’ll see some examples in a moment but we first need to look at what information the methods have access to.

acting_user

The user performing the action is available via acting_user method. This method will always return a user object, even if no one is logged in to the app, because Hobo has a special Guest class to represent a user that is not logged in. Two useful methods that are available on all Hobo user objects are:

guest? – returns true if the user is a guest, i.e. no-one is logged in.
signed_up? – returns true if the user is a not a guest.

So for example, to specify that you must be logged in to create a record:

def create_permitted?   
  acting_user.signed_up? 
end

It’s also common to compare the acting_user with associations on your model, for example, say your model has an owner:

belongs_to :owner, :class_name => "User"

You can assert that only the owner can make changes like this:

def update_permitted?   
  owner == acting_user 
end

There is a downside to that method – the owner association will be fetched from the database. That’s not really necessary, as the foreign key that we need has already been loaded. Fortunately Hobo adds a comparison method for every belongs_to that avoids this trip to the database:

def update_permitted?   
  owner_is? acting_user 
end

Change tracking

When deciding if an update is permitted (i.e., in the update_permitted? method), it will often be important to know what exactly has changed. In a previous version of Hobo we had to jump through a lot of hoops to make this information available. No longer – Active Record now tracks all changes made to an object. For example, say you wish to find out about changes to an attribute status. The following methods (among others) are available:

status_changed? - returns true if the attribute has been changed
status_was - returns the old value of the attribute

Note that these methods are only available on attributes, not on associations. However, as a convenience Hobo models add *_changed? for all belongs_to associations.
For example, the following definition means that only signed up users can make changes, and the status attribute cannot be changed by anyone:

def update_permitted?   
  acting_user.signed_up? && !status_changed? 
end

As a stylistic point, sometimes it can be clearer to use early returns, rather than to build up a large and complex boolean expression. This approach is also a bit easier to apply comments to. For example:

def update_permitted?   # Must be signed up:   
  return false unless acting_user.signed_up?      
  !status_changed? 
end

Change tracking helpers

Making assertions about changes to many attributes can quickly get tedious:

def update_permitted?   
  !(address1_changed? || 
  address2_changed? || 
  city_changed? || 
  zipcode_changed?) 
end

The permission system provides four helpers to make code like this more concise and clearer. Each of these methods are passed one or more attribute names:

only_changed? – are the attributes passed the only ones that have changed?
none_changed? – have none of the attributes passed been changed?
any_changed? – have any of the attributes passed been changed?
all_changed? – have all of the attributes passed been changed?

So, for example, the previous update_permitted? could be simplified to:

def update_permitted?   
  none_changed? :address1, :address2, :city, :zipcode 
end

Ruby tip: if you want to pass an array, use Ruby’s ‘splat’ operator:

READ_ONLY_ATTRS = %w(address1 address2 city zipcode)  

def update_permitted?   
  none_changed? *READ_ONLY_ATTRS 
end

Note that you can include the names of belongs_to associations in your attribute list.

Examples

Let’s go through a few examples. Here’s a definition that says you cannot create records faking the owner to be someone else, and state must be ‘new’:

def create_permitted?   
  return false unless owner_is? acting_user      
  state == "new" 
end

Note that by asserting owner_is? acting_user you are implicitly asserting that the acting_user is signed up, because owner can never be a reference to a guest user.

A common requirement for update permission is to restrict the list of fields that can be changed according to the type of user. For example, maybe an administrator can change anything, but a non-admin can only change a given set of fields:

def update_permitted?   
  return true if acting_user.administrator?      
  only_changed? :name, :description 
end

Note that we’re assuming there is an administrator? method on the user object. Such a method is not built into Hobo, but Hobo’s default user generator does add this to your model. We’ll discuss this in more detail later on.

A typical destroy permission might be that administrators can delete anything, but non-administrators can only delete the record if they own it:

def destroy_permitted?   
  acting_user.administrator? || owner_is?(acting_user) 
end

View permission and never_show

As you may have noticed when we introduced the permissions above, the view_permitted method differs from the other three basic permissions in that it takes a single parameter:

def view_permitted?(attribute)   
  ... 
end

The method is required to do double duty. If the permission system needs to determine if the acting_user is allowed to view this record as a whole, attribute will be nil. Otherwise attribute will be the name of an attribute for which view permission is requested. So when defining this method, remember that attribute may be nil.

There is also a convenient shorthand for denying view permission for a particular attribute or attributes:

class MyModel   
  ...   
  never_show :foo, :baa   
  ... 
end
View and edit permission will always be denied for those attributes.

Edit Permission

Edit permission is used by the view layer to determine whether or not to render a particular form field. That means it is not like the other permission methods, in that it’s not actually a request to view or change a record. Instead it’s more like a preview of update permission.

Asking for edit permission is a bit like asking: will update permission be granted if a change is made to this attribute? A common response to that question might be: it depends what you’re changing the attribute to. And therein lies the difference between update permission and edit permission. With update permission, we are dealing with a known quantity – we have a set of concrete changes to the object that may or may not be permitted. With edit permission, the value that the attribute will become is not known (because the user hasn’t submitted the form yet).

Despite that difference edit permission and update permission are obviously very closely related. Because saving you work is what Hobo is all about, the permission system contains a mechanism for deriving edit permission based on your update_permitted? method. For that reason, the edit_permitted? method:

def edit_permitted?(attribute)   
  ... 
end

This method often does not need to be implemented.

Protected, read-only, and non-viewable attributes

Rails provides a few ways to prevent attributes from being updated during ‘mass assignment’:

attr_protected
attr_accessible
attr_readonly

(You can look these up in the regular Rails API reference if you’re not familiar with them).

Before the edit_permitted? method is even called, Hobo checks these declarations. If changes to any attribute is prevented by these declarations, they will automatically be recognized as not editable.

Similarly, if a virtual attribute is read-only in the Ruby sense (it has no setter method), that tells Hobo it is not editable. And finally, fields that are not viewable are implicitly not editable either.

Tip: if a particular attribute can never be edited by any user, it’s simplest to just declare it as attr_protected or attr_readonly (read-only attributes can be set on creation, but not changed later). If the ability to change the attribute either depends on the state of the record, or varies from user to user, attr_protected and the rest are not flexible enough – define permission methods instead.

We’ll now take a look at how edit_permitted? is provided automatically, and then cover the details of defining edit permission yourself.

Deriving edit permission

To figure out edit permission for a particular attribute, based on your definition of update_permitted?, Hobo calls your update_permitted? method, but with a special trick in place.

If your update_permitted? attempts to access the attribute under test, Hobo intercepts that access and says to itself: “Aha! the permission method tried to access the attribute, which means permission to update depends on the value of that attribute”. Given that we don’t know what value the attribute will have after the edit, we had better be conservative. The result is false - no you cannot edit that attribute.

If, on the other hand, the permission method returns true without ever accessing that attribute, the conclusion is: update permission is granted regardless of the value the attribute. No matter what change is made to the attribute, update permission will be granted, and therefore edit permission can be granted.

Neat eh? It’s not perfect but it sure is useful. Remember you can always define edit_permitted? if things don’t work out. Also note that if edit permission is incorrect, this does not result in a security hole in your application. An edit control may be rendered when it really should not have been, but on submission of the form, the change to the database is policed by update_permitted?, not edit_permitted?.

In case you’re interested, here’s how Hobo intercepts those accesses to the attribute under test. A few singleton methods are added to the record (i.e., methods are defined on the record’s metaclass). These give special behavior to this one instance. In effect these methods make one of the models attributes ‘undefined’. Any access to an undefined attribute raises Hobo::UndefinedAccessError, which is caught by the permission system, and edit permission is denied. 

Say a test is being made for edit permission on the name attribute, the following methods will be added:
name - raises Hobo::UndefinedAccessError
name_change - raises Hobo::UndefinedAccessError
name_was - returns the actual current value (because this will be the old value after the edit)
name_changed? - returns true
changed? - returns true
changed - returns the list of attributes that have changed, including name
changes - raises Hobo::UndefinedAccessError

After the edit check those singleton methods are removed again.

Defining edit permission

If the mechanism described above is not adequate for some reason, you can always define edit permission yourself. If the derived edit permission is not correct for just one field, it’s possible to define edit permission manually for just that one field, and still have the automatic edit permission for the other fields in your model.

To define edit permission for a single attribute (and keep the automatically derived edit permission for the others), define foo_edit_permitted? (where foo is the name of your attribute). For example, if the attribute is name:

def name_edit_permitted?   
  acting_user.administrator? 
end

To completely replace the derived edit permission with your own definition, just implement edit_permitted? yourself:

def edit_permitted?(attribute)   
  ... 
end

The attribute parameter will either be the name of an attribute, or nil. In the case that it is nil, Hobo is testing to see if the current user has edit permission “in general” for this record. For example, this would be use to determine whether or not to render an edit link.


Permissions and associations	

So far we’ve focused on policing changes to basic data fields, but Hobo supports multi-model forms, so we also need to place restrictions on associated records. We need to specify permissions regarding:

Changes to the target of a belongs_to association.
Adding and removing items to a has_many association.
Changes to the fields of any related record

If we think in terms of the underlying database, it’s clear that every change ultimately comes down to things that we have already covered - creating, updating and deleting rows. So the permission system is able to covers these cases with a simple rule:

If you make a change to a record via one of the user_* methods, (e.g., user_create), and
as a result of that change, related records are created, updated or destroyed, then
the acting_user is propagated to those records, and
any permissions defined on those records are enforced.

All we have to do then, is think of everything in terms of the records that are being created, modified or deleted, and it should be clear how which permissions apply. For example:

Change the target of a belongs_to required update permission on the owner record.
Adding a new record to a has_many association requires create permission for that new record.
Adding and removing items to a has_many :through requires create or destroy permission on the join model.

So there really is no special support for associations in the permission system, other than the rule described above for propagating the acting_user.

Testing for changes to belongs_to associations

As discussed, no special support is needed to police belongs_to associations, you can just check for changes to the foreign key. For example:

belongs_to :user  

def update_permitted?   
  acting_user.administrator || !user_id_changed? 
end

Although that works fine, it feels a bit low level. We’d much rather say user_changed?, and in fact we can. For every belongs_to association, Hobo adds a *_changed? method, e.g. user_changed?. 

In addition to this, the attribute change helpers – only_changed?, none_changed?, any_changed? and all_changed? – all accept belongs_to association names along with regular field names.

The Permission API

It is common in Hobo applications, especially small ones, that although you define permissions on your models, you never actually call the permissions API yourself. The model controller will use the API to determine if POST and PUT requests are allowed, and the Rapid tags in the view layer will use the permissions API to determine what to render.

When you’re digging a bit deeper though, customizing the controllers and the views, you may need to use the permission API yourself. That’s what we’ll look at in this section.

The standard CRUD operations.

Active Record provides a very simple API for the basic CRUD operations:
.
Create – Model.create or r = Model.new; ...; r.save
Read – Model.find, then access the attributes on the record
Update – record.save and record.update_attributes
Delete – record.destroy

The Hobo permission system adds “user” versions of these methods. For example, user_create is like create, but takes the “acting user” as an argument, and performs a permission check before the actual create. The full set of class (model) methods are:

Model.user_find(user, ...)
A regular find, followed by record.user_view(user)
Model.user_new(user, attributes)
A regular new, then set_creator(user), then record.user_view(user). If a block is given, the yield is after the set_creator and before the user_view
Model.user_create(user, attributes) (and user_create!)
As with regular create, attributes can be an array of hashes, in which case multiple records are created. Equivalent to user_new followed by record.user_save. The user_create! version raises an exception on validation errors.

The instance (record) methods are:

record.user_save(user) (and user_save!)
A regular save plus a permission check. If new_record? is true, checks for create permission, otherwise for update permission.
record.user_update_attributes(user, attributes) (and user_update_attributes!)
A regular update_attributes plus the permission check. If new_record? is true, checks for create permission, otherwise for update permission.
record.user_view
Performs a view permission check and raises PermissionDeniedError if it fails
record.user_destroy
A regular destroy with a permission check first.

Direct permission tests

The methods mentioned in the previous section perform the appropriate permission tests along with some operation. If you want to perform a permission test directly, the following methods are available:

record.creatable_by?(user)
record.updatable_by?(user)
record.destroyable_by?(user)
record.viewable_by?(user, attribute=nil)
record.editable_by?(user, attribute=nil)

There is also:

method_callable_by?(user, method_name)

Which is related to web methods, which we’ll cover later on.
You should always call these methods, rather than calling the ..._permitted? methods directly, as some of them have extra logic in addition to the call to the ..._permitted? method.

For example, editable_by? will check things like attr_protected first, and then call edit_permitted?

Create, update and destroy hooks

In addition to the methods described in this section, the permission system extends the regular create, update and destroy methods. If acting_user is set, each of these will perform a permission check prior to the actual operation. This is illustrated in the very simple implementation of, for example user save:

def user_save(user)   
  with_acting_user(user) { save } 
end

(with_acting_user just sets acting_user for the duration of the block, then restores it to it’s previous value)

Permission for web methods

In order for a web method to be available to a particular user, a permission method must be defined (one permission method per web method). For example, if the web method is send_reminder_email, you would define the permission to call that in:

def send_reminder_email_permitted?   
  ... 
end

As mentioned previously, you can test a method-call permission directly with:

record.method_callable_by?(user, :send_reminder_email)

after_user_new – initialize a record using acting_user

Often we would like to initialize some aspect of our model based on who the acting_user is. A very common example would be to set an “owner” association automatically. Hobo provides the after_user_new callback for this purpose:

belongs_to :owner, :class_name => "User",  
after_user_new { |r| r.owner = acting_user }

Note that after_user_new fires on both user_new and user_create.



The need for an “owner association” is so common that Hobo provides an additional shortcut for it:

belongs_to :owner, :class_name => "User", :creator => true

Other situations can be more complex, and the :creator => true shorthand may not suffice. 

For example, an “event” model might need to be associated with the same “group” as the acting user. In this case we go back to the after_user_new callback:

class Event    
  belongs_to :group,      
  after_user_new { |event| event.group = acting_user.group } 
end

OK, but what does all this have to do with permissions? It is quite common that you need this information to be in place in order to confirm if permission is granted. For example:

def create_permitted?   
  acting_user.group == group 
end

This definition says that a user can only create an event in their own group. When we combine the two…

after_user_new { |event| event.group = acting_user.group }  

def create_permitted?   
  acting_user.group == group 
end

…a neat thing happens. A signed up user is allowed to create an event, because the callback ensures that the event is in the right group, but if an attempt is made to change the group to a different one, that would fail. 

The edit permission mechanism (described in a previous section) can detect this, so the end result is that (by default) your app will have the “New Event” form, but the form control for choosing the group will be automatically removed. The event will be automatically assigned to the logged in user’s group. I love it when a plan comes together!

Permissions vs. validations

It may have occurred to you that there is some overlap between the permission system and Active Record’s validations. To an extent that’s true: they both provide a way to prevent undesirable changes from making their way into the database. The line between them is fairly clear though:

Validations are appropriate for “normal mistakes”.

A validation “error” is not really an application error, but a normal occurrence which is reported to the user in a helpful manner.

Permissions are appropriate for preventing things that should never happen.

Your user interface should provide no means by which a “permission denied” error can occur. Permission errors should only come from manually editing the browser’s address bar, or from unsolicited form posts.

In Rails code, it’s not uncommon to see validations used for both of these reasons. For example, the UI may provide radio buttons to chose “Male” or “Female”, and the model might state:

validates_inclusion_of :gender, :in => %w(Male Female)

In normal usage, no one will ever see the message that gets generated when this validation fails. Effectively it’s being used as a permission. In a Hobo app it might be better to use the permission system for this example, but the declarative validates_inclusion_of is quite nice, so if you do use it we’ll turn a blind eye.

The administrator? Method
The idea that your user model has a boolean method administrator? is bit of a strong assumption. It fits for many applications, but might be totally inappropriate for many others. 

Although you’ve probably seen this method a lot, it’s important to clarify that it’s not actually part of Hobo. Eh what?

administrator? is only a part of Hobo insofar as:

The user model created by the hobo_user_model generator contains a boolean field administrator
The Guest model created by the hobo generator has a method administrator? which just returns false.
The default permission stubs generated by hobo_model require acting_user.administrator? for create, update and destroy permission.

That’s it. administrator? is a feature of those three generators, but is not a feature of the permission system itself, or any other part of the Hobo internals. The generated code is just a starting point. Two common ways you might want to change that are:

Get rid of the administrator field in the User model, and define a method instead, for example:
.
 def administrator? 
   roles.include?(Role.administrator)
 end

Get rid of that field, and of all calls to administrator? from your models’ permission methods. Those are just stubs that you are expected to replace

At some point we may add an option to the generators so you will only get administrator? if you want it.


View helpers

This is the quick version.  Five permission related view-helpers are provided:

can_create?(object=this)
can_update?(object=this)
can_edit? – arguments are an object, or a symbol indicating a field (assumes this as the object), or both, or no arguments
can_delete?(object=this)
can_call? – arguments are an object and a method name (symbol), or just a method name (assumes this as the object)

CHAPTER 9 - HOBO CONTROLLERS AND ROUTING


This chapter of the Hobo Manual describes Hobo’s Model Controller and automatic routing. In a very simple Hobo app, you hardly need to touch the automatically generated controllers, or even think about routing. As an app gets more interesting though, you’ll quickly need to know how to customize things. The down-side of having almost no code at all in the controllers is that there’s nothing there to tweak. Don’t worry though, Hobo’s controllers have been built with Customization in mind. The things you will tweak commonly are extremely easy, and full Customization is not hard at all.

Introduction

Here’s a typical controller in a Hobo app. In fact this is unchanged from the code generated by the hobo_model_controller generator:

class AdvertsController < ActiveRecord::Base
    hobo_model_controller
    auto_actions :all
 end

The hobo_model_controller declaration just does include Hobo::ModelController, and gives you a chance to indicate which model this controller looks after. E.g., you can do
hobo_model_controller Advert
By default the model to use is inferred from the name of the controller.

Selecting the automatic actions	
Hobo provides working implementations of the full set of standard REST actions that are familiar from Rails:

index
show
new
create
edit
update
destroy

A controller that declares 

	auto_actions :all

Will have all of the above actions.

You can customize this either by listing the actions you want:

	auto_actions :new, :create, :show

Or by listing the actions you don’t want:

	auto_actions :all, :except => [ :index, :destroy ]

The :except option can be set to either a single symbol or an array

There are two more conveniences: :read_only and :write_only.  :read_only is a shorthand for :index and :show, and :write_only is a shorthand for :create, :update and :destroy. 

Either of these shorthands must be the first argument to auto_actions, after which you can still list other actions and the :except option:

	auto_actions :write_only, :show

Owner actions
Hobo’s model controller can also provide three special actions that take into account the relationships between your records. Specifically, these are the “owner” versions of new, index and create. To understand how these compare to the usual actions, consider a recipe model which belongs_to :author, :class_name => "User". The three special actions are:

An index page that only lists the recipes by a specific author
A “New Recipe” page specific to that user (i.e. to create a new recipe by that author)
A create action which is specific to that “New Recipe” page

These are all part of the RecipesController and can be added with the auto_actions_for declaration, like this:

	auto_actions_for :author, [ :index, :new, :create ]

If you only want one, you can omit the brackets:

	auto_actions_for :author, :index

Action names and routes

The action names and routes for these actions are as follows:

index_for_author is routed as /users/:author_id/products for GET requests
new_for_author is routed as /users/:author_id/products/new for GET requests
create_for_author is routed as /users/:author_id/products for POST requests

It’s common for the association name and the class name of the target to be the same (e.g., in an association like belongs_to :category). We’ve deliberately chosen an example where they are different (“author” and “user”) in order to show where the two names are used. The association name (“author”) is used everywhere except in the /users at the beginning of the route.

Instance Variables
As well as setting the default DRYML context, the default actions all make the record, or collection of records, available to the view in an instance variable that follows Rails conventions. E.g. for a ‘product’ model, the product will be available as @product and the collection of products on an index page will be available as @products

Owner actions

For owner actions, the owner record is made available as @<association-name>. For example, . @author in our above example.

Automatic Routes
Hobo’s model router will automatically create standard RESTful routes for each of your models.  The router inspects your controllers: any action that is not defined will not be routed.

The default routes created by Hobo are located in the config/hobo_routes.rb file.  You can override these by placing entries in the config/routes.rb file. 

Adding extra actions
It’s common to want actions beyond the basic REST defaults. In Rails a controller action is simply a public method. That doesn’t change in Hobo. You can define public methods and add routes for them just as you would in a regular Rails app. However, you probably want your new actions to be routed automatically, and even implemented automatically, just like the basic actions. For this to happen you have to tell Hobo about them as explained in this section.

Show actions

Suppose we want a normal view and a “detailed” view of our advert. In REST terms we want a new ‘show’ action called ‘detail’. We can add this like this:


class AdvertsController < ActiveRecord::Base
    hobo_model_controller
    auto_actions :all
    show_action :detail
end

This action will be routed to /adverts/:id/detail. 

Hobo will provide a default implementation. You can override this simply by defining the method yourself:

	show_action :detail def detail   ... end

Or, as a shorthand for the same, give a block to show_action:

	show_action :detail do   ... end

Index actions

In the same way, we might want an alternative listing (index) of our adverts. Perhaps one that gives a tabular view of the adverts:

class AdvertsController < ActiveRecord::Base 
   hobo_model_controller
   auto_actions :all
   index_action :table
end

This gets routed to /adverts/table. As with show_action, if you want your own implementation, you can either define the method as normal, or pass a block to index_action.

Changing action behavior
Sometimes the implementations Hobo provide aren’t what you want. They might be close, or they might be completely out. Not a problem - you can change things as needed.

A cautionary note concerning controller methods

Always start by asking: should this go in the model? It’s a very, very, very common mistake to put code in the controller that belongs in the model. Want to send an email in the create action? 

Don’t! Send it from an after_create callback in the model. Want to check something about the current user before allowing a destroy to proceed? Use Hobo’s Permission System.

Typically, valid reasons to add custom controller code are things like:

Provide a custom flash message
Change the redirect after a create / update / destroy
Extract parameters from params and pass them to the model (e.g. for searching / filtering)
Provide special responses for different formats or requested mime-types

A good test is to ask: is this related to http? No? Then it probably shouldn’t be in the controller. I tend to think of controllers as a way to publish objects via http, so they shouldn’t really be dealing with anything else.

Writing an action from scratch

The simplest way to customize an action is to write it yourself. Say your advert has a boolean field published and you only want published adverts to appear on the index page. Using one of 
Hobo’s automatic scopes, you could write:

class AdvertsController < ActiveRecord::Base
    hobo_model_controller
    auto_actions :all
    def index 
     @adverts = Advert.published.all
   end
 end

In other words you don’t need to do anything different than you would in a normal Rails action. Hobo will look for either @advert (for actions which expect an ID) or @adverts (for index actions) as the initial context for a DRYML page.

(Note: In the above example, we’ve asked for the default index action and then overwrote it. It might have been neater to say ”auto_actions :all, :except => :index” but it really doesn’t matter.)

Customizing Hobo’s implementation

Often you do want the automatic action, but you want to customize it in some way. The way you do this varies slightly for the different kinds of actions, but they all follow the same pattern. We’ll start with show as an example.

The default show provided by Hobo is simply:

def show
   hobo_show
end

All the magic (and in the case of show there really isn’t much) takes place in hobo_show. So immediately we can see that it’s easy to add code before or after the default behavior:

def show
   @foo = "bar"
   hobo_show
   logger.info "Done show!"
end

Note: assigning to instance variables to make data available to the views work exactly as it normally would in Rails.

There is a similar hobo_* method for each of the basic actions: hobo_new, hobo_index, etc.

Switching to the update action, you might think you can do:

def update
   hobo_update
   redirect_to my_special_place # DON'T DO THIS!
end

That will give you an error: actions can only respond by doing a single redirect or render, and hobo_update has already done a redirect. Read on for the simple solution…

The block

The correct place to perform a redirect is in a block passed to hobo_update. All the hobo_* actions take a block and yield to the block just before their response. If your block performed a response, Hobo will leave it at that. So:

def update
  hobo_update do 
    redirect_to my_special_place  # better but still problematic
   end
end

The problem this time is that we almost certainly don’t want to do that redirect if there were validation errors during the update. As with the typical Rails pattern, validation errors are handled by re-rendering the form (along with the error messages). Hobo provides a method valid? for these situations:

def update
   hobo_update do
      redirect_to my_special_place if valid?
   End
end

If the update was valid, the above redirect will happen. If it wasn’t, the block won’t respond so Hobo’s response will kick in and re-render the form. Perfect!

If you want access to the object either in the block or after the call to hobo_update, it’s available either as this or in the conventional Rails instance variable, in this case @advert.

Handling different formats

By default, the response block is only called if an HTML response is required. If you want to handle other response types, declare a block with a single argument. The “format” object from Rails’ respond_to will be passed. The typical usage would be:

def update
   hobo_update do |format|
     format.html { ... }
     format.js   { ... }
   end
end

Passing options
Here’s another example of tweaking one of the automatic actions. The hobo_* methods can all be passed a range of options. Here’s a simple example: changing the page size on an index page:

def index
   hobo_index :per_page => 10
end

That’s pretty much all there is to customizing Hobo’s automatic actions: define the action as a public method in which you call the appropriate hobo_* method, passing it parameters and/or a block.

The remainder of this guide will cover the parameters available to each of the hobo_* methods.
Note that you can also pass these options directly to the index_action and show_action declarations, e.g.:

	index_action :table, :per_page => 10


The default actions

In this section we’ll go through each of the action implementations that Hobo provides.

Hobo_index

hobo_index takes a “finder” as an optional first argument, and then options. A finder is any object that supports the find and / or paginate methods, such as an ActiveRecord model class, a has_many association, or a scope.

Find options

Any of the standard ActiveRecord find options you pass are forwarded to the find method. This is particularly useful with the :include option to avoid the dreaded N+1 query problem.

Pagination

Turn pagination on or off by passing true/false to the :paginate option. If not specified Hobo will guess based on the value of request.format.

It’s normally on, but won’t be for things like XML and CSV. When pagination is on, any other options to hobo_index are forwarded to the paginate method from will-paginate, so you can pass things like :page and :per_page. If you don’t specify :page it defaults to params[:page] or if that’s not given, the first page.

hobo_show

Options to hobo_show are forwarded to the method find_instance which does:

	model.user_find(current_user, params[:id], options)

user_find is a method added to your model by Hobo which combines a normal find with a check for view permission.

As with hobo_index, a typical use would be to pass :include to do eager loading.

hobo_new

hobo_new will either instantiate the model for you using the user_new method from Hobo’s permission system, or will use the first argument (if you provide one) as the new record.

hobo_create

hobo_create will instantiate the model (using user_new), or take the first argument if you provide one.

The attributes hash for this new record are found either from the option :attributes if you passed one, or from the conventional parameter that matches the model name (e.g. params[:advert]).

The update to the new record with these attributes is performed using the user_update_attributes method, in order to respect the model’s permissions.

The response (assuming you didn’t respond in the block) will handle:

redirection if the create was valid (see below for details)
re-rendering the form if not (or sending textual validation errors back to an AJAX caller)
performing Hobo’s part updates as required for AJAX requests

hobo_update

hobo_update has the same behavior as hobo_create except that the record is found rather than created. You can pass the record as the first argument if you want to find it yourself.
The response is also essentially the same as hobo_create, with some extra smarts to support the in-place-editor from Script.aculo.us.

hobo_destroy

The record to destroy is found using the find_instance method, unless you provide it as the first argument.

The actual destroy is performed with:

	this.user_destroy(current_user)

…which performs a permission check first.

The response is either a redirect or an AJAX part update as appropriate.

Owner actions

For the “owner” versions of the index, new and create actions, Hobo provides:

hobo_index_for
hobo_new_for
hobo_create_for

These are pretty much the same as the regular hobo_index, hobo_new and hobo_create except they take an additional first argument – the name of the association. For example, the default implementation of, say, index_for_author would be:



def index_for_author
   hobo_index_for :author
end

Flash messages

The hobo_create, hobo_update and hobo_destroy actions all set reasonable flash messages in flash[:notice]. They do this before your block is called so you can simply overwrite this message with your own if need be.

Automatic redirection
The hobo_create, hobo_create_for, hobo_update and hobo_destroy actions all perform a redirect on success.

Block Response

If you supply a block to the hobo_* action, no redirection is done so that it may be performed by the block:

def update
   hobo_update do
      redirect_to my_special_place if valid?
   end
end

The :redirect parameter

If you supply a block to the hobo_* action, you must redirect or render all potential formats. But what if you want to supply a redirect for HTML requests, but let Hobo handle AJAX requests? In this case you can supply the :redirect option to hobo_*:

def update
   hobo_update :redirect => my_special_place
end

:redirect is only used for valid HTML requests.

The :redirect: option may be one of:

Symbol: redirects to that action using the current controller and model. (Must be a show action).
Hash or String: redirect\to is used.
Array: object_url is used.

Automatic redirects

If neither a response block nor :redirect are passed to hobo_*, the destination of this redirect is determined by calling the destination_after_submit method. Here’s how it works:

If the parameter ”after_submit” is present, go to that URL (See the <after-submit> tag in Rapid for an easy way to provide this parameter), or
Go to the record’s show page if there is one, or
Go to the show page of the object’s owner if there is one (For example, this might take you to the blog post after editing a comment), or
Go to the index page for this model if there is one, or
Give up trying to be clever and go to the home-page (the root URL, or override by implementing home_page in ApplicationController)

Autocompleters

Hobo makes it easy to build auto-completing text fields in your user interface; the Rapid tag library provides support for them in the view layer, and the controller provides an easy way to add the action that looks up the completions.
The simplest form for creating an auto-completing field is just a single declaration:

class UsersController < ApplicationController
     autocomplete
end

Because Hobo allows you to specify which field of a model is the name (using :name => true  in the model’s field declaration block), you don’t need to tell autocomplete which field to complete on if it is autocompleting the “name” field. To create an autocompleter for a different field, pass the field as a symbol:

	autocomplete :email_address
	
The autocomplete declaration will create an action named according to the field, e.g., complete_email_address routed as, in this case, /users/complete_email_address for GET requests.

Options

The autocomplete behavior can be customized with the following options:
:field – specify a field to complete on. Defaults to the name (first argument) of the autocompleter.
:limit – maximum number of completions. Defaults to 10.
:param – name of the parameter in which to expect the user’s input. Defaults to :query
:query_scope – a named scope used to do the database query. Change this to control things such as handling of multiple words, case sensitivity, etc. For our example this would be email_address_contains. Note that this is one of Hobo’s automatic scopes.

Further Customization

The autocomplete action follows the same pattern for Customization as the regular actions. That is, the implementation given to you is a simple call to the underlying method that does the actual work, and you can call this underlying method directly. To illustrate, say, on a UsersController in which you declare autocomplete :email_address, the generated method looks like:

def complete_email_address
   hobo_completions :email_address, User
end

To gain extra control, you can call hobo_completions yourself by passing a block to autocomplete:

	autocomplete :email_address do   hobo_completions ... end



The parameters to hobo_completions are:

Name of the attribute
A finder, i.e. a model class, association, or a scope.
Options (the same as described above)

Drag and drop reordering
The controller has the server-side support for drag-and-drop reordering of models that declare acts_as_list. 

Say, for example, your Task model uses acts_as_list, then Hobo will add a reorder action routed as /tasks/reorder that looks like:

def reorder
   hobo_reorder
end

This action expects an array of IDs in params[:task_ordering], and will reorder the records in the order that the IDs are given.

The action can be removed in the normal ways (e.g., blacklisting):

	auto_actions :all, :except => :reorder

The action will raise a PermissionDeniedError if the current user does not have permission to change the ordering.

Permission and “not-found” errors
Any permission errors that happen are handled by the permission_denied controller method, which renders the DRYML tag <permission-denied-page> or just a text message if that doesn’t exist.

Not-found errors are handled in a similar way by the not_found method, which tries to render <not-found-page>

Both permission_denied and not_found can be overridden either in an individual controller or site-wide in ApplicationController.

Lifecycles
Hobo’s model controller has extensive support for lifecycles. This is described in the  following  chapter.
CHAPTER 10 – HOBO LIFECYCLES
  
This chapter of the Hobo manual describes Hobo’s “lifecycle” mechanism. This is an extension that lets you define a lifecycle for any Active Record model. Defining a lifecycle is like a finite state machine – a pattern which turns out to be extremely useful for modeling all sorts of processes that crop up in the world that we’re trying to model.

That might make Hobo’s lifecycles sound similar to the well known acts_as_state_machine plugin, and in a way they are, but with Hobo style. The big win comes from the fact that, like many things in Hobo:

There is support for this feature in all three of the MVC layers

This is the secret to making it very quick and easy to get up and running.

Introduction

In the REST style, which is popular with Rails coders, we view our objects a bit like documents: you can post them to a website, get them again later, make changes to them and delete them. Of course, these objects also have behavior, which we often implement by hooking functionality to the create / update / delete events (like using callbacks such as after_create in Active Record). 

In a pinch we may have to fall back to the RPC style, which Hobo has support for with the “Web Method” feature.

This works great for many situations, but some objects are not best thought of as documents that we create and edit. In particular, applications often contain objects that model some kind of process. A good example is friendship in a social app. Here’s a description of how friendship might work:

Any user can invite friendship with another user
The other user can accept or reject (or perhaps ignore) the invite.
The friendship is only active once it’s been accepted
An active friendship can be cancelled by either user.

Not a “create”, “update” or “delete” in sight. Those bold words capture the way we think about the friendship much better. Of course we could implement friendship in a RESTful style, but we’d be doing just that – implementing it, not declaring it.

The life-cycle of the friendship would be hidden in our code, scattered across a bunch of callbacks, permission methods and state variables. Experience has shown this type of code to be tedious to write, extremely error prone and fragile when changing.

Hobo lifecycles is a mechanism for declaring the lifecycle of a model in a natural manner.

REST vs. lifecycles is not an either/or choice. Some models will support both styles. A good example is a content management system with some kind of editorial workflow. An application like that might have an Article model, which can be created, updated and deleted like any other REST resource. The Article might also feature a lifecycle that defines how the article goes from newly authored, through one or more stages of review (possibly being rejected at any stage) before finally becoming accepted, and later published.

An Example

Everyone loves an example, so here is one. We’ll stick with the friendship idea. If you want to try this out, create a blank app and add a model:

>ruby script/generate hobo_model friendship

Here’s the code for the friendship mode (don’t be put off by the MagicMailer, that’s just a made-up class to illustrate a common use of the callback actions – sending emails):


Figure 299: Defining the Friendship model


Usually, the lifecycle can be represented as a graph, just as we would draw a finite state machine:


Let’s work through what we did there.

Because Friendship has a lifecycle declared, a class is created that captures the lifecycle. The class is Friendship::Lifecycle. Each instance of Friendship will have an instance of this class associated with it, available as my_friendship.lifecycle.

The Friendship model will also have a field called state declared. The migration generator will create a database column for state.

The lifecycle has three states:
	
	state :invited, :active, :ignored

There is one ‘creator’ – this is a starting point for the lifecycle:



This declaration specifies that:

The name of the creator is invite. It will be available as a method Friendship::Lifecycle.invite(user, attributes). Calling the method will instantiate the record, setting attributes from the hash that is passed in.


The :params option specifies which attributes can be set by this create step:

	 :params => [ :invitee ]

(Any other key in the attributes hash passed to invite will be ignored.)

The lifecycle state after this create step will be invited:

 :become => :invited,

To have access to this create step, the acting user must be an instance of User (i.e. not a guest):

 :available_to => "User"

After the create step, the invitor association of the Friendship will be set to the acting user:

	:user_becomes => :invitor

After the create step has completed (and the database updated), the block within do..end is executed:



There are five transitions declared: 

accept
reject
ignore
retract
cancel


These become methods on the lifecycle object (not the lifecycle class),  For example:

 my_fiendship.lifecycle.accept!(user, attributes)

 Calling that method will:

Check if the transition is allowed.
If it is, update the record with the passed in attributes. The attributes that can change are declared in a :params option, as we saw with the creator. None of the friendship transitions declare any :params, so no attributes will change, and
change the state field to the new state, then
save the record, as long as validations pass.

Each transition declares:

Which states it goes from and to, e.g., accept goes from invited to active: 
	
transition :accept, { :invited => :active }

Some of the transitions are to a pseudo state: :destroy. To move to this state is to destroy the record.

Who has access to it:
.
 	:available_to => :invitor
  	:available_to => :invitee

In the create step the :available_to option was set to a class name, here it is set to a method (a belongs_to association). 

To be allowed, the acting user must be the same user returned by this method. There are a variety ways that :available_to can be used, which will be discussed in detail later.

A callback (the block). This is called after the transition completes. Notice that in the block for the cancel transition we’re accessing acting_user, which is a reference to the user performing the transition.

Hopefully that worked example has clarified what lifecycles are all about. We’ll move on and look at the details now.

Key concepts

Before getting into the API we’ll recap some of the key concepts very briefly.

As mentioned in the introduction, the lifecycle is essentially a finite state machine. It consists of:

One or more states. Each has a name, and the current state is stored in a simple string field in the record. If you like to think of a finite state machine as a graph, these are the nodes.
Zero or more creators. Each has a name, and they define actions that can start the lifecycle, setting the state to be some start-state.
Zero or more transitions. Each has a name, and they define actions that can change the state. Again, thinking in terms of a graph, these are the arcs between the nodes.

The creators and the transitions are together known as the steps of the lifecycle.

There are a variety of ways to limit which users are allowed to perform which steps, and there are ways to attach custom actions (e.g., send an email) both to steps and to states.

Defining a lifecycle

Any Hobo model can be given a lifecycle like this:



Any model that has such a declaration will gain the following features:

The lifecycle definition becomes a class called Lifecycle which is nested inside the model class (e.g. Friendship::Lifecycle) and is a subclass of Hobo::Lifecycles::Lifecycle. The class has methods for each of the creators.

Every instance of the model will have an instance of this class available from the #lifecycle method. The instance has methods for each of the transitions:

my_friendship.lifecycle.clas # Friendship::Lifecyle
my_friendship.lifecycle.reject!(user)


The lifecyle declaration can take three options:
:state_field - the name of the database field (a string field) to store the current state in. Default ’state’
:key_timestamp_field - the name of the database field (a datetime field) to store a timestamp for transitions that require a key (discussed later). Set to false if you don’t want this field. Default ’key_timestamp’.
:key_timeout - keys will expire after this amount of time. Default 999.years.

Note that both of these fields are declared never_show and attr_protected.

Within the lifecycle do ... end a simple DSL is in effect. Using this we can add states and steps to the lifecycle.
Defining states

To declare states:

lifecycle do
   state :my_state, :my_other_state
end

You can call state many times, or pass several state names to the same call.
Each state can have an action associated with it:

state :active do
   MagicMailer.send [invitee, invitor], "Congratulations, you are now friends"
end

You can provide the :default => true option to have the database default for the state field be this state:

state :invited, :default => true

This will take effect the next time you generate and apply a hobo migration.

Defining creators

A creator is the starting point for a lifecycle. They provide a way for the record to be created (in addition to the regular new and create methods). Each creator becomes a method on the lifecycle class. The definition looks like:

	create name, options do
 		... 
	end

The name is a symbol. It should be a valid ruby name that does not conflict with the class methods already present on the Hobo::Lifecycles::Lifecycle class.

The options are:
:params - an array of attribute names that are parameters of this create step. These attributes can be set when the creator runs.

:become - the state to enter after running this creator. This does not have to be static but can depend on runtime state. Provide one of:
A symbol – the name of the state
A proc – if the proc takes one argument it is called with the record, if it takes none it is instance_eval‘d on the record. Should return the name of the state
A string – evaluated as a Ruby expression with in the context of the record

:if and :unless – a precondition on the creator. Pass either:
A symbol – the name of a method to be called on the record
A string – a Ruby expression, evaluated in the context of the record
A proc – if the proc takes one argument it is called with the record, if it takes none it is instance_eval‘d on the record.

Note that the precondition is evaluated before any changes are made to the record using the parameters to the lifecycle step.

:new_key – generate a new lifecycle key for this record by setting the key_timestamp field to be the current time.

:user_becomes – the name of an attribute (typically a belongs_to relationship) that will set to the acting_user.

:available_to – Specifies who is allowed access to the creator. This check is in addition to the precondition (:if or :unless). There are a variety of ways to provide the :available_to option, discussed later on.


The block given to create provides a callback which will be called after the record has been created. You can give a block with a single argument, in which case it will be passed the record, or with no arguments in which case it will be instance_eval‘d on the record.

Defining transitions

A transition is an arc in the graph of the finite state machine – an operation that takes the lifecycle from one state to another (or, potentially, back to the same state.). Each transition becomes a method on the lifecycle object (with ! appended). The definition looks like:

transition name, { from => to }, options do ... end

(The name is a symbol. It should be a valid Ruby name

The second argument is a hash with a single item:

{ from => to }

(We chose this syntax for the API just because the => is quite nice to indicate a transition)

This transition can only be fired in the state or states given as from, which can be either a symbol or an array of symbols. On completion of this transition, the record will be in the state give as to which can be one of:

A symbol – the name of the state
A proc – if the proc takes one argument it is called with the record, if it takes none it is instance_eval‘d on the record. Should return the name of the state.
A string – evaluated as a Ruby expression with in the context of the record.

The options are:
:params - an array of attribute names that are parameters of this transition. These attributes can be set when the transition runs.

:if and :unless – a precondition on the transition. Pass either:
A symbol – the name of a method to be called on the record
A string – a Ruby expression, evaluated in the context of the record
A proc – if the proc takes one argument it is called with the record, if it takes none it is instance_eval‘d on the record.

:new_key – generate a new lifecycle key for this record by setting the key_timestamp field to be the current time.

:user_becomes – the name of an attribute (typically a belongs_to relationship) that will set to the acting_user.

:available_to – Specifies who is allowed access to the transition. This check is in addition to the precondition (:if or :unless). There are a variety of ways to provide the :available_to option, discussed later on.

The block given to transition provides a callback which will be called after the record has been updated. You can give a block with a single argument, in which case it will be passed the record, or with no arguments in which case it will be instance_eval‘d on the record.


Repeated transition names

It is not required that a transition name is distinct from all the others. For example, a process may have many stages (states) and there may be an option to abort the process at any stage. It is possible to define several transitions called :abort, each starting from a different start state. You could achieve a similar effect by listing all the start states in a single transition, but by defining separate transitions, each one could, for example, be given a different action (block).


The :available_to option

Both create and transition steps can be made accessible to certain users with the :available_to option. If this option is given, the step is considered ‘publishable’, and there will be automatic support for the step in both the controller and view layers.

The rules for the :available_to option are as follows. Firstly, it can be one of these special values:
:all – anyone, including guest users, can trigger the step
:key_holder – (transitions only) anyone can trigger the transition, provided record.lifecycle.provided_key is set to the correct key. Discussed in detail later.

If :available_to is not one of those, it is an indication of some code to run (just like the :if option for example):

A symbol – the name of a method to call
A string – a Ruby expression which is evaluated in the context of the record
A proc – if the proc takes one argument it is called with the record, if it takes none it is instance_eval‘d on the record

The value returned is then used to determine if the acting_user has access or not. The value is expected to be:

A class – access is granted if the acting_user is a kind_of? that class.
A collection – if the value responds to :include?, access is granted if include?(acting_user) is true. 
A record – if the value is neither a class or a collection, access is granted if the value is the acting_user

Some examples:

Say a model has an owner:

belongs_to :owner, :class_name => "User"	

You can just give the name of the relationship (since it is also a method) to restrict the transition to that user:

:available_to => :owner

Or a model might have a list of collaborators associated with it:

has_many :collaborators, :class_name => "User"

Again it’s easy to make the lifecycle step available to them only (since the has_many does respond to :include?):

:available_to => :collaborators

If you were building more sophisticated role based permissions, you could make sure you role object responds to :include? and then say, for example:

:available_to => "Roles.editor"


Validations

Validations have been extended so you can give the name of a lifecycle step to the :on option. 

validates_presence_of :notes, :on => :submit

There is now support for: 

 record.lifecycle.valid_for_foo?

 where foo is a lifecycle transition.

Controller actions and routes

As well as providing the lifecycle mechanism in the model, Hobo also supports the lifecycle in the controller layer, and provides an automatic user interface in the view layer. All of this can be fully customized of course. In this section we’ll look at the controller layer features, including the routes that get generated.

Lifecycle steps that include the :available_to option are considered publishable. It is these that Hobo generates controller actions for. Any step that does not have the :available_to option can be thought of as ‘internal’. 

Of course you can call those create steps and transitions from your own code, but Hobo will never do that for you.

auto_actions

The lifecycle actions are added to your controller by the auto_actions directive. To get them you need to say one of:

auto_actions :all
auto_actions :lifecycle – adds only the lifecycle actions
auto_actions :accept, :do_accept (for example) – as always, you can list the method names explicitly (the method names that relate to lifecycle actions are given below)

You can also remove lifecycle actions with:

auto_actions ... :except => :lifecycle – don’t create any lifecycle actions or routes
auto_actions ... :except => [:do_accept, ...] – don’t create the listed lifecycle actions or routes
Create steps

For each create step that is publishable, the model controller adds two actions. Going back to the friendship example, two actions will be created for the invite step. Both of these actions will pass the current_user to the lifecycle, so access restrictions (the :available_to option) will be enforced, as will any preconditions (:if and :unless).

The “create page” action

FriendshipsController#invite will be routed as /friendships/invite for GET requests.
This action is intended to render a form for the create step. An object that provides metadata about the create step will be available in @creator (an instance of Hobo::Lifecycles::Creator).

If you want to implement this action yourself, you can do so using the creator_page_action method:

def invite
   creator_page_action :invite
end

Following the pattern of all the action methods, you can pass a block in which you can customize the response by setting a flash message, rendering or redirecting. do_creator_action also takes a single option:

:redirect – change where to redirect to on a successful submission. Pass a symbol to redirect to that action (show actions only) or an array of arguments which are passed to object_url. Passing a String or a Hash will pass your arguments straight to redirect_to.

The ‘do create’ action

FriendshipsController#do_invite will be routed as /friendships/invite for POST requests.

This action is where the form should POST to. It will run the create step, passing in parameters from the form. As with normal form submissions (i.e. create and update actions), the result will be an HTTP redirect, or the form will be re-rendered in the case of validation failures.

Again you can implement this action yourself:

def do_invite
   do_creator_action :invite
end

You can give a block to customize the response, or pass the redirect option:

:redirect – change where to redirect to on a successful submission. Pass a symbol to redirect to that action (show actions only) or an array of arguments that are passed to object_url. Passing a String or a Hash will pass your arguments straight to redirect_to.


Transitions

As with create steps, for each publishable transition there are two actions. For both of these actions, if parmas[:key] is present, it will be set as the provided_key on the lifecycle, so transitions that are :available_to => :key_holder will work automatically.

We’ll take the friendship accept transition as an example.

The transition page

FriendshipsController#accept will be routed as /friendships/:id/accept for GET requests.

This action is intended to render a form for the transition. An object that provides metadata about the transition will be available in @transition (an instance of Hobo::Lifecycles::Transition).

You can implement this action yourself using the transition_page_action method

def accept
   transition_page_action :accept
end

As usual, you can customize the response by passing a block. And you can pass the following option:
:key – the key to set as the provided key, for transitions that are: 
:available_to => :key_holder.
 Defaults to params[:key]

The ‘do transition’ action

FriendshipsController#do_accept will be routed as /friendships/:id/accept for POST requests.

This action is where the form should POST to. It will run the transition, passing in parameters from the form. As with normal form submissions (i.e., create and update actions), the result will be an HTTP redirect, or the form will be re-rendered in the case of validation failures.

You can implement this action yourself using the do_transition_action method:

def do_accept
   do_transition_action :accept
end
As usual, you can customize the response by passing a block. And you can pass the following options:
:redirect – change where to redirect to on a successful submission. Pass a symbol to redirect to that action (show actions only) or an array of arguments which are passed to object_url.
:key – the key to set as the provided key, for transitions that are :available_to => :key_holder. Defaults to params[:key]


Keys and secure links

Hobo’s lifecycles also provide support for the “secure link” pattern. By “secure” we mean that on one other than the holder of the link can access the page or feature in question. This is achieved by including some kind of cryptographic key in the URL, which is typically sent in an email address. The two very common examples are:

Password reset – following the link gives the ability to set a new password for a specific account. By using a secure link and emailing it to the account holders email address, only a person with access to that email account can chose the new password.

Email activation – by following the link, the user has effectively proved that they have access to that email account. Many sites use this technique to verify that the email address you have given is one that you do in fact have access to.

In fact the idea of a secure link is more general than that. It can be applied in any situation where you want a particular person to participate in a process, but that person does not have an account on the site. 

For example, in a CMS workflow application, you might want to email a particular person to ask them to verify that the content of an article is technically correct. Perhaps this is a one-off request so you don’t want to trouble them with signing up. Your app could provide a page with “approve”/”reject” buttons, and access to that page could be protected using the secure link pattern. In this way, the person you email the secure link to, and no one else, would be able to accept or reject the article.

Hobo’s lifecycles provide support for the secure-link pattern with the following:

A field added to the database called (by default) ”key_timestamp”. This is a date-time field, and is used to generate a key as follows:

Digest::SHA1.hexdigest{“#{id_of_record}-#{current_state}-#{key_timestamp}”}

Both create and transition steps can be given the option :new_key => true. This causes 
      the key_timestamp to be updated to Time.now.
The :available_to => :key_holder option (transitions only). Setting this means the transition is only allowed if the correct key has been provided, like this:

 record.lifecycle.provided_key = the_key

Hobo’s “model controller” also has (very simple) support for the secure-link pattern. Prior to rendering the form for a transition, or accepting the form submission of a transition, it does (by default):

	record.lifecycle.provided_key = params[:key]

Implementing a lifecycle with a secure-link

Stringing this all together, we would typically implement the secure-link pattern as follows. 

We’re assuming some knowledge of Rails mailers here, so you may need to read up on those.

Create a mailer (script/generate mailer) which will be used to send the secure link.

In your lifecycle definition, two steps will work together:
A create or transition will initiate the process, by generating a new key, emailing the link, and putting the lifecycle in the correct state.
A transition from this state will be declared as :available_to => :key_holder, and will perform the protected action.

Add :new_key => true to the create or transition step that initiates the process.

On this same step, add a callback that uses the mailer to send the key to the appropriate user. The key is available as lifecycle.key. For example, the default Hobo user model has:

Transition :request_pasword_rest, { :active => :active }, :new_key => true do
  UserMailer.deliver_forgot_password(self, lifecycle.key)
end

Add :available_to => :key_holder to the subsequent transition – the one you want to make available only to recipients of the email.
The mailer should include a link in the email, and they key should be part of this link as a query parameter. Hobo creates a named route for each transition page, so there will be a URL helper available. For example, if the transition is on User and is called reset_password, the link in your mailer template should look something like:

<%= user_reset_password_url :host => @host, :id => @user, :key => @key %>

Testing for the active step.

In some rare cases your code might need to know if a lifecycle step is currently in progress or not (e.g. in a callback or a validation). For this you can access either:

record.lifecycle.submit_in_progress.active_step.name

Or, if you are interested in a particular step, it’s easier to call:

record.lifecycle.submit_in_progress?

Where submit can be any lifecycle step.


CHAPTER 11 - HOBO VIEW HINTS AND LOCALES

Note: While Hobo View Hints still operate in version 1.3, we recommend using the new Internationalization (I18n) Locales functionality which will be discussed later in this chapter.

Introduction

One of the main attractions of Hobo is its ability to give you a pretty decent starting point for you app’s UI, entirely automatically based on information extracted from your models and controllers. The more information available to Hobo, the better job it can do, but some such information doesn’t properly belong in either the model or the controller. For example, we might want to declare that a particular field should have a different name in the UI than in the model layer.

This functionality used to be handled in the ViewHints module in Hobo 1.  As of Hobo 1.3, these features have been migrated into the Internationalization module.  For those of you who are upgrading your Hobo 1 applications, a section on migrating ViewHints to Internationalization is available at the end of this chapter.

Internationalization (I18n)

The old view hints renaming has been moved into the locale files. Locales files have been introduced to support Rails Internationalization (i18n) and have their own conventions. They are perfect and already working English to English customizations as well. So Hobo now uses this Rails-standard tool and established conventions to provide model, field name, and field help customization.
For more detail see the Rails Internationalization (I18n) API Guide at 
http://guides.rubyonrails.org/i18n.html

Here is the uncommented default config/locale/app.en.yml file



Note: YAML (.yml) files use a fixed number of spaces (2) to indent levels. Tabs are illegal Quotation marks are optional.

You can rename models and attributes by changing or adding key/values in the specific activerecord.models and activerecord.attributes sections. You can also add any attributes help you might need in the activerecord.attribute_help section (which is a Hobo specific section). For example:


Just be careful: don't mess up the indentation!
Note: The key/values inside the first attributes: group (marked in blue) are used as the default for all of the models

The Hobo-specific translation definitions can be seen in the hobo.en.yml file:


Note: Members of the Hobo community have created versions for Spanish, Italian, German, Russian, etc.  Check out the latest by joining the Hobo Google Users Group.

Child relationships

The ViewHints.children and the ViewHints.inline_booleans methods have been moved in the model from the View Hints, but they are used in the exactly same way they were used before.
Many web applications arrange the information they present in a hierarchy. By declaring a hierarchy using the children declaration, Hobo can give you a much better default user interface.

At present, the children declaration only influences Rapid’s show-page – it governs the display of collections of <card> tags embedded in the show-page. If you declare a single child collection, e.g.:

class User < ActiveRecord::Base
		ields do
			...
		end
    children :recipes 
end
The collection of the user’s recipes will be added to the main content of users/show.

You can declare additional child relationships. The order is significant, with the first in the list being the “primary collection.” For example:

class User < ActiveRecord::Base
		
		fields do
			...
		end
    children :recipes, :questions, :answers
end

With this declaration, the user’s show-page will be given an aside section (sidebar), in which cards for the questions and answers collections are displayed.

Inline Booleans

By default, Rapid will display boolean fields as part of the header if they are true (so an :administrator field will turn into the text 'Administrator' just under the main heading on the show page). 

The inline_booleans view hint can alter this behavior for some or all of the model's boolean fields. Fields specified as inline booleans will be rendered as part of the regular field list.

class User < ActiveRecord::Base
		
		fields do
			...
		end
    inline_booleans :administrator, :moderator
end

As a shortcut…

class User < ActiveRecord::Base
		
		fields do
			...
		end
    inline_booleans true
end

…will apply the option to all boolean fields in the model.

Note: You can always reach the view_hints class by accessing the Model.view_hints method, so for example User.view_hints.children will return the children of the User model. Same thing with parent, parent_defined, sortable? and paginate? which are the survived methods in the view hint class.

Locale (I18n) Friendly Tags

In hobo 1.3.x all the code not compatible by the Ruby i18n standard has been removed. As a result a few Hobo tags have changed internally and accept more attributes, or deprecate others. A few Hobo tags have been deprecated and replaced with relevant i18n-specific tags that are included in the auto-generated taglibs.

Note: Many internal Hobo tags have been transparently internationalized, i.e., the strings they use are automatically translated to the current locale language. We are only documenting here the tags that you might use in application development.

Changed tags
<view/>
The "view" tags for these types are localized (i.e. their values get formatted consistently with the locale)
	⁃	Date
	⁃	Time
	⁃	ActiveSupport::TimeWithZone
	⁃	Numeric
	⁃	boolean

<count/>
A convenience tag used to output a count summary with a correctly localized and pluralized label. Works with any kind of collection such as an `ActiveRecord` association or an array.
Usage
<count:comments/>

Rendered as:
<span class="count">1 Comment</span>

<count:viewings/>

Rendered as -> <span class="count">3 Viewings</span>

The label can be customized using the `label` attribute, e.g.
    <count:comments label="blog post comment"/> 
Rendered as:
    <span class="count">12 blog post comments</span>

You can pass a summary attribute, which will generate a complete localized sentence. It allows two options:
boolean (e.g., `<count summary/>`): it will lookup the tags.count.default key in the locale file.     If the lookup fails, it will fallback to the english default sentences consistent with the count.
String (e.g., `<count summary="offer"/>`): it will lookup the tags.count.offer key in the locale file.
    If the lookup fails, it will fall back to the English default sentences consistent with the count.
Examples
    it:
      tags:
        count:
          default:
            zero: "Non ci sono {{label}}"
            one: "C'è solo 1 {{label}}"
            other: "Ci sono {{count}} {{label}}"
          choice:
            zero: "Non ci sono {{label}} da scegliere"
            one: "Puoi scegliere solo una {{label}}"
            other: "Puoi scegliere tra {{count}} {{label}}"

    with :en locale and boolean summary (internal defaults)
<count:comments summary/> -> <span class="count">There is 1 Comment</span>
<count:viewings summary/> -> <span class="count">There are 3 Viewings</span>
    
   Note: Add the locale English strings to use the following examples)
  
  With :it locale and boolean summary (key "tags.count.default"):
    <count:comments summary/>
    -> count => 0 -> <span class="count">Non ci sono Commenti</span>
    -> count => 1 -> <span class="count">C'è solo 1 Commento</span>
    -> count => 5 -> <span class="count">Ci sono 5 Commenti</span>
    
With :it locale and summary="choice" (key "tags.count.choice"):
    <count:comments summary="choice"/>
    -> count => 0 -> <span class="count">Non ci sono Commenti da scegliere</span>
    -> count => 1 -> <span class="count">Puoi scegliere solo 1 Commento</span>
    -> count => 5 -> <span class="count">Puoi scegliere tra 5 Commenti</span>

Additional Notes
The `prefix` attribute is deprecated: use summary instead.
Use the `lowercase` attribute to force the generated label to be lowercase:

<count:comments lowercase/> -> <span class="count">1 comment</span>

Use the `if-any` attribute to output nothing if the count is zero. This can be followed by an `<else>` tag to handle the empty case:
count:comments if-any/><else>There are no comments</else>

<you/>
Convenience tag to help with the common situation where you need to address the current user as "you", and refer to other users by name
Usage
The context should be a user object. If `this == current_user` the "you" form is rendered, otherwise the form with the user's name:
`<you have/> new mail` -> "you have new mail" or "Jim has new mail"
‘<you are/> now an admin` -> "you are now an admin" or "Jim is now an admin"
`<you do/>n't want to go there` -> "you don't want to go there" or "Jim doesn't want to go there"

The tag is also localized in the namespaces "tags.you.current_user" and "tags.you.other_user".
Each namespace can contain the legacy keys "have", "are", "do" used for the respective attributes, and "nothing" used when no attribute is passed. But you can also use your own keys, providing that you add the keys in the correct namespaces.



Examples
    it:
      tags:
        you:
          current_user:
            nothing: "Tu"
            have: "Hai"
            are: "sei"
            can: "Puoi"
          other_user:
            nothing: "{{name}}"
            have: "{{name}} ha"
            are: "{{name}} è"
            can: "{{name}} può"

 `<you have/> un nuovo messaggio.` -> "Hai un nuovo messaggio." or "Jim ha un nuovo messaggio."
`Adesso <you are/> amministratore.` -> "Adesso sei amministratore." or "Adesso Jim è amministratore."
`<you can/> scrivere.` -> "Puoi scrivere." or "Jim può scrivere."

Note: The symbol :name is added by default as an interpreted variable)

Attributes
  capitalize: the first letter of the resulting sentence will be capitalized
Additional Notes
The "titleize" attribute is deprecated--use "capitalize" instead.
<your/>
Similar to `<you>`, but renders "Your" or "Fred's" or equivalent localized strings
Attributes
capitalize: the first letter of the resulting sentence will be capitalized
count: used in pluralization. If omitted it will be set to 1.
key: used to lookup the translation in the locale file. It allows 3 different options:
1. A single key like 'message': simple translation in 'tags.your.message.current_user'
   			  or 'tags.your.message.other_user'
2. A Composite key like 'any.namespace.message': translation as for the previous case, but it willtranslate also the 'any.namespace.message' and will interpolate the variable <key> (in this case :message)  in the translation
3. When the key is omitted it will be set to "default" and will do the translation with that key.
NEED CLARIFICATION:
     	Pass other meaningful attributes to achieve a dynamic usage
 	- any other attribute passed to the tag will be used as a variable for interpolation
Notes
 - The :name variable is added by default as an interpolable variable
 - If no translation is found an automatic (only english) default is generated:
   the Your/Jim's string, joined to the tag content.
   If you pass an explicit 'default' attribute you will override the automatic default.
Examples
    it:
      tags:
        your:
          message:
            current_user:
              one: "Tuo Messaggio"
              other: "Tuoi Messaggi"
            other_user:
              one: "Messaggio di {{name}}"
              other: "Messaggi di {{name}
          entry:
            current_user:
              one: "Tua {{entry}}"
              other: "Tue {{entry}}"
            other_user: "{{entry}} di {{name}}"

 `<your key="message" count=>"&messages.count"/>`
   -> count => 1 -> "Tuo Messaggio" or "Messaggio di Jim"
   -> count => 5 -> "Tuoi Messaggi" or "Messaggi di Jim"

 `<your key="activerecord.models.entry" count=>"&this.entries.count"/>`
   -> count => 1 -> "Tua Entrata" or "Entrata di Jim"
   -> count => 5 -> "Tue Entrate" or "Entrate di Jim"

 `<your>Posts</your>` -> "your Posts" or "Jim's Posts"

<select-menu/>
A simple wrapper around the `<select>` tag and `options_for_select` helper
Attributes
 - `options` - an array of options suitable to be passed to the Rails `options_for_select` helper.
 - `selected` - the value (from the `options` array) that should be initially selected. Defaults to `this`
 - `first-option` - a string to be used for an extra option in the first position. E.g. "Please choose..."
 - `first-value` - the value to be used with the `first-option`. Typically not used, meaning the option has a blank value.
 - `key` - the key used to lookup in the locale file or 'default' by default. If you pass it hobo will lookup in the namespace "tags.select_menu.#{key}" in order to find `options`, `first_option` and `first_value`. The passed attributes are used as a default in case the lookups fail. (see the documentation of filter-menu tag for a similar example).
<filter-menu/>
A `<select>` menu intended to act as a filter for index pages.
Example
Filtering on state is a common use.   Here's the dryml for Order:
    <filter-menu param-name="state" options="&Order::Lifecycle.states.keys" />

And the controller action:
    def index
      # always validate data given in URL's!!!
      params[:state]=nil unless Order::Lifecycle.states.include?(params[:state]._?.to_sym)
      finder = params[:state] ? Order.send(params[:state]) : Order
      hobo_index finder
    end

See [Filtering stories by status](/tutorials/agility#filtering_stories_by_status) in the [Agility Tutorial](/tutorials/agility) for an example.

Attributes
 - `param-name` - the name of the HTTP parameter to use for the filter
 - `options` - an array of options or an array of arrays (useful for localized apps) for the menu.
   It can be omitted if you provide the options as an array or array of arrays in the locale file.
 - `no-filter` - The text of the first option which indicates no filter is in effect. Defaults to 'All'
<I18n/>
It lookups the options attributes in filter_menu.#{param_name}.options.
The passed options are used as a default in case the lookup fails.
Besides the "tags.filter_menu.default.no_filter" key is used as default of the attribute "no-filter"
(or "All" if no default is found)
I18n Example
  es:
    tags:
      filter_menu:
        period:
          no_filter: Todos Períodos
          options:
          - [ "Hoy", "today" ]
          - [ "Ayer", "yesterday" ]


Code:
   TIME_PERIODS = %w[today yesterday]
  <t-filter-menu param-name="period" options="&TIME_PERIODS" no-filter="All Periods"/>

   with I18n.locale == :es
   <select name="period">
     <option value="">Todos Períodos</option>
     <option value="today">Hoy</option>
     <option value="yesterday">Ayer</option>
   </select>

   with I18n.locale == :en (i.e no locale file)
   <select name="period">
     <option value="">All Periods</option>
     <option value="today">today</option>
     <option value="yesterday">yesterday</option>
   </select>

i18n tags
These are the tag from the i18n_rapid taglib.
<t/>
Simple wrapper around I18n.t.
The tag content is used as the  :default option. It is overridden by an explicit 'default' attribute.
There is a default :count => 1
Attributes
 - key: the key to lookup
 - all the attributes accepted by the wrapped method

<ht/>

This is a helper and a tag. Uses RoR native I18n.translate.
 Adds some conventions for easier hobo translation. 
1. Assumes the first part of the key to be a model name (e.g.: users.index.title -> user)
2. Tries to translate the model by lookup for: (e.g.: user-> activerecord.models.user)
3. Adds a default fallback to the beginning of the fallback chain by replacing the first part of the key with "hobo" and using the translated model name as additional attribute. This allows us to have default translations (e.g.: hobo.index.title: "{{model}} Index")
  Is also used as a tag in the dryml-view files. The syntax is:
<ht key="my.app">My Application</ht>

Will lookup the my.app  key for your locale and replaces the "My Application" content if found.
<ht key="my" app="Program">My Application</ht>

Will look up both the my and app key for your locale, and replaces the "My Application" with the my key contents (interpolated using the app key. 
sample.no.yml file:
      "no":
        my: "Mitt {{app}}"

The output should be: Mitt Program

<model-name-human/>
Wrapper around ActiveModel::Name#human
Attributes
 - model - (optional) should be a model class or a record object (default to this)
 - count - (optional) used to pick the inflected string for the model. It should be an integer.

<human-attribute-name/>
Wrapper around ActiveRecord::Base.human_attribute_name.
Attributes
 - attribute - the attribute to lookup
 - model - (optional) should be a model class or a record object (default to this)
 - count - (optional) should be an integer
<human-collection-name/>
Used to localize and pluralize collection names.
A collection name is a special case of an attribute name. You should store the collection names as attribute names in the locale file.  This tag internally uses human_attribute_name to return them.
With the `your` attribute and in the special case the context is a Hobo::Model::User instance it automatically embeds the `your` tag functionality. (note: :name is added by default as an interpolable variable)
Attributes
 - collection - the attribute/collection key to lookup in the `activerecord.attributes` namespace. (e.g. 'roles')
 - count - used to pick the inflected string for the collection. It should be an integer.
 - your - wraps the collection name in a `Your` tag
Example
  it:
    activerecord:
      attributes:
        post:
          comments:
            one: "Commento"
            other: "Commenti"
        user:
          roles:
            one: "Ruolo"
            other: "Ruoli"
    tags:
      your:
        roles:
          current_user:
            one: "Il tuo Ruolo"
            other: "I tuoi Ruoli"
          other_user:
            one: "Ruolo di {{name}}"
            other: Ruoli di {{name}}"

  # context is a Post instance ('your' is ignored)
  <human-collection-name collection="comments" count="&user.comments.count" your/>
  I18n.locale = :en => "Comment" or "Comments"
  I18n.locale = :it => "Commento" or "Commenti"

  # context is an User instance
  <human-collection-name collection="roles' count="&user.roles.count" your/>

  I18n.locale = :en => "Your Role" or "Jim's Role" or "Your Roles" or "Jim's Roles"
  I18n.locale = :it => "Il tuo Ruolo" or "Il Ruolo di Jim" or "I tuoi Ruoli" or "I Ruoli di Jim"
  (output is the same as <Your key="roles" count=>"&user.roles.count"/> )
  <human-collection-name collection="roles" count="&user.roles.count"/>
  
  I18n.locale = :en => "Role" or "Roles"
  I18n.locale = :it => "Ruolo" or "Ruoli"

Deprecated/Renamed tags
These tags have been deprecated because they were not compliant with i18n or they have been renamed in a more appropriate way.
<collection-name/>
deprecated: use <human-collection-name/>
<preview-with-more/>
renamed: use <collection-preview/> instead

Migrating ViewHints to the Internationalization Module

In the ViewHints module, there are four kinds of hints you can give about your models:

The model name – in case you want this to differ from the actual class name
Field names – in case you want any of these to differ from the database column names
Field help – some simple explanatory text for each field in a model
Child relationships – allows you to arrange your models in a hierarchy appropriate for the user interface.
Inline Booleans – allows you to force Hobo to show boolean fields in the field list on model show pages.

Renaming the model name, field names and specifying field help can be specified in the localization file.  In this section’s examples, the localization file we will be using is the config/locales/app.en.yml

Here is an example of migrating the model name rename, field rename and field help from your ViewHints to the config/locales/app.en.yml file:

Existing ViewHints file:

class AnswerHints < Hobo::ViewHints
 	model_name "Response" 
    field_names :body => "", :recipe => "See recipe"
    field_help  :recipe => "Enter keywords from the name of a recipe"
end

Corresponding config/locales

en:
  activerecord:
  	models:
      answer:
        one: Response
        other: Responses
    attributes:
      answer:
      	body: ""
      	recipe: See recipe
    attribute_help:
      answer:
        recipe: Enter keywords from the name of a recipe


Since different languages handle pluralization in different ways, simply specifying another name for a model is no longer feasible, instead, we have to specify at least the models’s new name for it in a single instance, and, for plural instances.  So above, we have renamed  ‘Answer’ to ‘Response’ when there is only 1 model present, and, ‘Responses’ in all other cases.  

To specify Child relationships, this declaration should be moved from the ViewHints file to the Model.  So:


class UserHints < Hobo::ViewHints
 	children :recipes, :questions, :answers
end
 
would be changed  to:

class User < ActiveRecord::Base
		
		fields do
			...
		end
    children :recipes, :questions, :answers
end


If there are any inline_booleans specified in your ViewHints file, these can be specified in the Model declaration.  So:


class UserHints < Hobo::ViewHints
 	inline_booleans :administrators
end
 
would be changed  to:


class User < ActiveRecord::Base
		
		fields do
			...
		end
    inline_booleans :administrators
end


Tim Griffin ran into an issue with localization that is worth noting here:
1. If you don't explicitly name the enum_string with the "name: =>" parameter or with a call to set_name, the main key in your locale file must include the model name in which the enum_string is defined, as well as the tableized name of the enum_string (lower-case/ pluralized).  
BUT the enum_string's main key can ONLY use the "/" notation.
So, if you do this:
class Document < ActiveRecord::Base
   hobo_model
   Region = HoboFields::Types::EnumString.for(:ab, :bc)

you must use this notation:
en:
  document/regions:
    ab: "Alberta"
    bc: "British Columbia"

and NOT this notation:
en:
  document:
    regions:
      ab: "Alberta"
      bc: "British Columbia"

2. If you DO explicitly name the enum_string with the "name: =>" parameter or with a call to set_name, the keys in your locale file must not include the model name.

If you do this:

class Document < ActiveRecord::Base
    hobo_model
   Region = HoboFields::Types::EnumString.for(:ab, :bc, :name => "Region")

Your locale file's enum_string key must match the tableized version of the name you assigned to the enum_string. (Note the lower-case first letter, and the pluralization.)

en:
   regions:
     ab: "Alberta"
     bc: "British Columbia"

Note: Tim Griffin submitted the following example of Hobo’s new support for specifying a model name to enable different models with the same filter attribute to be properly represented in a locale file under the activerecord.attributes namespace.

The 'model' parameter on the <filter-menu> tag now enables you to include translated filter values for each model that requires a filter menu in your application.

As an example, consider a model representing packages that can be in different states. On the package index page using a <table-plus> tag to show packages, your <filter-menu> tag can show its options using translation keys from a locale file by including the 'model' parameter in the tag call:

<filter-menu model="package" param-name="state"/>

Your locale file will then need to include the keys for the filter menu as an entry under the activerecord namespace. The following example shows the options keys listed under the filter_menu key:
  
activerecord:
    attributes:
      package:
        name: "Package Name"
        id: "ID"
        created_at: "Created"
        updated_at: "Updated"
        state: "Status"      
        lifecycle:
          states:
            draft: "Draft"
            submitted: "Submitted"
            received: "Received"
            in_review: "In Review"
            accepted: "Accepted"
            rejected: "Rejected"
            withdrawn: "Withdrawn" 
        filter_menu:   
          state: 
            no_filter: All
            options:
            - [ "Draft", "draft" ]
            - [ "Submitted", "submitted" ]
            - [ "In Review", "in_review" ]
            - [ "Accepted", "accepted" ]
            - [ "Rejected", "rejected" ]
            - [ "Withdrawn", "withdrawn" ]
            - [ "Archived", "archived" ]
                                          
Prior to the support for the 'model' parameter on the <filter-menu> tag, it was not possible to have more than one model using a filter-menu that had to show translated values from a locale file. 
CHAPTER 12 - HOBO SCOPES

Hobo scopes are an extension of the named scope and dynamic finder functionality introduced in Rails 2.1, 2.2 and 2.3.

Most of these scopes work by calling named_scope the first time they are invoked. They should work at the same speed as a named scope on subsequent invocations2.

However, this does substantially slow down method_missing on your model’s class. If ActiveRecord::Base.method_missing is used often, you may wish to disable this module. 

Simple Scopes
	
_is
_is_not
_contains
_does_not_contain
_starts
_does_not_start
_ends
_does_not_end

Boolean Scopes
not_

Date Scopes
_before
_after
_between

Lifecyle Scopes

Key Scopes

Static Scopes
by_most_recent	
recent
limit
order
include
search

Association Scopes
with_
without_
_is
_is_not

Scoping Associations

Chaining

Let’s set up a few models for our testing:

class Person < ActiveRecord::Base
    hobo_model
     fields do
		 name :string
       born_at :date
       code :integer
       male :Boolean
      timestamps
    end
    lifecycle(:key_timestamp_field => false) do
     state :inactive, :active
    end
    has_many :friendships
    has_many :friends, :through => :friendships
end


class Friendship < ActiveRecord::Base
    hobo_model
    belongs_to :person
    belongs_to :friend, :class_name => "Person"
end

Generate a migration and run it:

>> ActiveRecord::Migration.class_eval(HoboFields::MigrationGenerator.run[0])
>> Person.columns.*.name => ["id", "name", "born_at", "code", "male", "created_at", "updated_at", "state"]

And create a couple of fixtures:

>> bryan = Person.new(:name => "Bryan", :code => 17,      :born_at => Date.new(1973,4,8), :male => true)
>> bryan.state = "active" >> bryan.save! 
>> bethany = Person.new(:name => "Bethany", :code => 42,      :born_at => date.new(1975,5,13), :male => false)
>> bethany.state = "inactive" >> bethany.save!
>> Friendship.new(:person => Bryan, :friend => bethany).save!

Hack the created_at column to get predictable sorting:

>> bethany.created_at = Date.new(2000)
>> bethany.save!

We’re ready to get going.

Simple Scopes
_is

Most Hobo scopes work by appending an appropriate query string to the field name. In this case, the hobo scope function name is the name of your database column, followed by _is. It returns an Array of models.

It works the same as a dynamic finder:

>> Person.find_all_by_name("Bryan").*.name => ["Bryan"]
>> Person.name_is("Bryan").*.name => ["Bryan"]
>> Person.code_is(17).*.name => ["Bryan"]
>> Person.code_is(99).length => 0

_is_not

But the Hobo scope form allows us to supply several variations:

>> Person.name_is_not("Bryan").*.name => ["Bethany"]

_contains

>> Person.name_contains("y").*.name => ["Bryan", "Bethany"]

_does_not_contain

>> Person.name_does_not_contain("B").*.name => []

_starts

>> Person.name_starts("B").*.name => ["Bryan", "Bethany"]

_does_not_start

>> Person.name_does_not_start("B").length => 0

_ends

>> Person.name_ends("y").*.name => ["Bethany"]

_does_not_end

>> Person.name_does_not_end("y").*.name => ["Bryan"]

Boolean scopes

If you use the name of the column by itself, the column is of type boolean, and no function is already defined on the model class with the name, Hobo scopes adds a dynamic finder to return all records with the boolean column set to true:

>> Person.male.*.name => ["Bryan"]

not_

You can also search for boolean records that are not true. This includes all records that are set to 
false or NULL.

>> Person.not_male.*.name => ["Bethany"]

Date scopes
Date scopes work only with columns that have a name ending in ”at”. The ”at” is omitted when using these finders.

_before

>> Person.born_before(Date.new(1974)).*.name => ["Bryan"]

_after

>> Person.born_after(Date.new(1974)).*.name => ["Bethany"]

_between

>> Person.born_between(Date.new(1974), Date.today).*.name => ["Bethany"]

Lifecycle scopes
If you have a lifecycle defined, each state name can be used as a dynamic finder.

>> Person.active.*.name => ["Bryan"]

Key scopes
This isn’t very useful:

>> Person.is(Bryan).*.name => ["Bryan"]

But this is:

>> Person.is_not(Bryan).*.name => ["Bethany"]

Static scopes
These scopes do not contain the column name.

by_most_recent

Sorting on the created_at column:	

>> Person.by_most_recent.*.name => ["Bryan", "Bethany"]

recent

Gives the N most recent items:

>> Person.recent(1).*.name => ["Bryan"]

limit

>> Person.limit(1).*.name => ["Bryan"]


order_by

>> Person.order_by(:code).*.name => ["Bryan", "Bethany"]

include

Adding the include function to your query chain has the same effect as the :include option to the find method.

>> Person.include(:friends).*.name => ["Bryan", "Bethany"]

search

Search for text in the specified column(s).

>> Person.search("B", :name).*.name => ["Bryan", "Bethany"]

Association Scopes

with_

Find the records that contain the specified record in an association

>> Person.with_friendship(Friendship.first).*.name => ["Bryan"]
>> Person.with_friend(Bethany).*.name => ["Bryan"]

You can also specify multiple records with the plural form

>> Person.with_friends(Bethany, nil).*.name => ["Bryan"]

without_

>> Person.without_friend(Bethany).*.name => ["Bethany"
>> Person.without_friends(Bethany, nil).*.name => ["Bethany"]

_is

You can use _is on a :has_one or a :belongs_to relationship:

>> Friendship.person_is(Bryan).*.friend.*.name => ["Bethany"]

_is_not

>> Friendship.person_is_not(Bryan) => []
Scoping Associations

When defining an association, you can add a scope:

>> class Person
	  has_many :active_friends, :class_name => "Person",:through =>          :friendships, :source => :friend, :scope => :active
	 has_many :inactive_friends, :class_name => "Person",:through =>    :friendships, :source => :friend, :scope => :inactive 
  end
 >> bryan.inactive_friends.*.name => ["Bethany"]
 >> bryan.active_friends.*.name => []

Or several scopes:


>> 
  class Person
    has_many :inactive_female_friends,:class_name => "Person",
             :through => :friendships, :source => :friend,
              :scope => [:inactive, :not_male]
    has_many :active_female_friends, :class_name => "Person",
             :through => :friendships, :source => :friend, :scope => [:active, :not_male]
    has_many :inactive_male_friends, class_name => "Person",
              :through => :friendships,:source => :friend,               :scope => [:inactive, :male]
   end
>> bryan.inactive_female_friends.*.name => ["Bethany"]
>> bryan.active_female_friends.*.name => []
>> bryan.inactive_male_friends.*.name => []

You can parameterize the scopes:

>> class Person
      has_many_:y_friends,:class_name => "Person",:through => :friendships,
       :source => :friend, :scope => { :name_contains => 'y' }
    has_many  :z_friends,:class_name => "Person", :through => :friendships, :source => :friend, :scope => { :name_contains => 'z' }
  end 
 >> bryan.y_friends.*.name => ["Bethany"]
 >> bryan.z_friends.*.name => []

Chaining

Like named scopes, Hobo scopes can be chained:

>> bryan.inactive_friends.inactive.*.name => ["Bethany"]
CHAPTER 13 – THE HOBO DRYML GUIDE


What is DRYML?
	
DRYML is a template language for Ruby on Rails that you can use in place of Rails’ built-in ERB templates. It is part of the larger Hobo project, but will eventually be made available as a separate plugin.

DRYML was created in response to the observation that the vast majority of Rails development time seems to be spent in the view-layer. Rails’ models are beautifully declarative, the controllers can be made so pretty easily (witness the many and various “result controller” plugins), but the views, ah the views…

Given that so much of the user interaction we encounter on the web is so similar from one website to another, surely we don’t have to code all this stuff up from low-level primitives over and over again? Please, no! 

Of course what we want is a nice library of ready-to-go user interface components, or widgets, which can be quickly added to our project, and easily tailored to the specifics of our application.

If you’ve been at this game for a while you’re probably frowning about now. Re-use is a very, very thorny problem. It’s one of those things that sounds straight-forward and obvious in principle, but turns out to be horribly difficult in practice. When you come to re-use something, you very often find that your new needs differ from the original ones in a way that wasn’t foreseen or catered for in the design of the component. The more complex the component, the more likely it is that bending the thing to your needs will be harder than starting again from scratch.

So the challenge is not in being able to re-use code, it is:

 Being able to re-use code in ways that were not foreseen. 

The reason we created DRYML was to see if this kind of flexibility could be built into the language itself. DRYML is a tag-based language that makes it trivially easy to give the defined tags a great deal of flexibility.

So DRYML is just a means to an end. The real goal is to create a library of reusable user-interface components that actually succeed in making it very quick and easy to create the view layer of a web application.

That library is also part of Hobo – the Rapid tag library.  You will visit this library later on in the book. Here we will see how DRYML provides the tools and raw materials that make a library like Rapid possible.
Discussing DRYML before Rapid means that many of the examples are not good advice for use of DRYML in a full Hobo app. For example, you might see

<%= h this.name %>

Which in an app that used Rapid would be better written <view:name/> or even just <name/> (that’s a tag by the way, called name, not some metaprogramming trick that lets you use field names as tags). Bear that in mind while you’re reading this chapter. The examples are chosen to illustrate the point at hand, they are not necessarily something you want to paste right into your application.

Simple page templates and ERB

In its most basic usage, DRYML can be indistinguishable from a normal Rails template. That’s because DRYML is (almost) an extension of ERB, so you can still insert Ruby snippets using the <% ... %> notation. For example, a show-page for a blog post might look like this:


<html>
   <head>
     <title>My Blog</title>
   </head>
   <body>
     <h1>My Famous Blog!</h1>
     <h2><%= @post.title %></h2>
          <div class="post-body"> 
      <%= @post.body %>
     </div>
   </body>
 </html>

No ERB inside tags

DRYML’s support for ERB is not quite the same as true ERB templates. The one thing you can’t do is use ERB snippets inside a tag. To have the value of an attribute generated dynamically in ERB, you could do:

<a href="<%= my_url %>">

In DRYML you would do:

<a href="#{my_url}">

In rare cases, you might use an ERB snippet to output one or more entire attributes:

<form <%= my_attributes %>>

We’re jumping ahead here, so just skip this if it doesn’t make sense, but to do the equivalent in DRYML, you would need your attributes to be in a hash (rather than a string), and do:

<form merge-attrs="&my_attributes">

Finally, in a rare case you could even use an ERB snippet to generate the tag name itself:

<<%= my_tag_name %>> ... </<%= my_tag_name %>>

To achieve that in DRYML, you could put the angle brackets in the snippet too:

<%= "<#{my_tag_name}>" %> ... <%= "</#{my_tag_name}>" %>

Where are the layouts?

Going back to the <page> tag at the start of this section, from a “normal Rails” perspective, you might be wondering why the boilerplate stuff like <html>, <head> and <body> are there. What happened to layouts? You don’t tend to use layouts with DRYML, instead you would define your own tag, typically <page>, and call that. Using tags for layouts is much more flexible, and it moves the choice of layout out of the controller and into the view layer, where it should be.

We’ll see how to define a <page> tag in the next section.

Defining simple tags

One of the strengths of DRYML is that defining tags is done right in the template (or in an imported tag library) using the same XML-like syntax. This means that if you’ve got markup you want to re-use, you can simply cut-and-paste it into a tag definition.

Here’s the page from the previous section, defined as a <page> tag simply by wrapping the markup in a <def> tag:

<def tag="page">
   <html>
    <head> 
      <title>My Blog</title>
     </head>
     <body>
       <h1>My Famous Blog!</h1>
       <h2><%= @post.title %></h2>
          <div class="post-body">
         <%= @post.body %>
       </div>
     </body>
   </html>
 </def>

Now we can call that tag just as we would call any other:

<page/>

If you’d like an analogy to “normal” programming, you can think of the <def>...</def> as defining a method called page, and <page/> as a call to that method.

In fact, DRYML is implemented by compiling to Ruby, and that is exactly what is happening.

Parameters

We’ve illustrated the most basic usage of <def>, but our <page> tag is not very useful. Let’s take it a step further to make it into the equivalent of a layout. First of all, we clearly need the body of the page to be different each time we call it.

In DRYML we achieve this by adding parameters to the definition, which is accomplished with the param attribute. Here’s the new definition:

<def tag="page">
   <html>
     <head>
      <title>My Blog</title> 
    </head>
     <body param/>
   </html>
 </def>

Now we can call the <page> tag and provide our own body:

<page>
   <body:>
     <h1>My Famous Blog!</h1> 
    <h2><%= @post.title %></h2> 
     <div class="post-body"> 
      <%= @post.body %>
     </div> 
  </body:>
 </page>

See how easy that was? We just added param to the <body> tag, which means our page tag now has a parameter called body. In the <page> call we provide some content for that parameter. 

It’s very important to read that call to <page> properly. In particular, the <body:> (note the trailing ’:’) is not a call to a tag, it is providing a named parameter to the call to <page>. We call <body:> a parameter tag. In Ruby terms you could think of the call like this:

page(:body => "...my body content...")

Note that is not actually what the compiled Ruby looks like in this case, but it illustrates the important point that <page> is a call to a defined tag, whereas <body:> is providing a parameter to that call.

Changing Parameter Names

To give the parameter a different name, we can provide a value to the param attribute:

<def tag="page">
   <html>
     <head>
       <title>My Blog</title>
     </head> 
    <body param="content"/> 
  </html>
 </def>

We would now call the tag like this:

<page><content:> ...body content goes here... </content:></page>

Multiple Parameters

As you would expect, we can define many parameters in a single tag. For example, here’s a page with a side-bar:

<def tag="page">
   <html> 
    <head>
       <title>My Blog</title>
     </head> 
    <body> 
      <div param="content"/> 
      <div param="aside" /> 
    </body>
   </html>
 </def>

Which we could call like this:

<page>
   <content:> ... main content here ... </content:>
   <aside:>  ... aside content here ... </aside:>
</page>

Note that when you name a parameter, DRYML automatically adds a CSS class of the same name to the output, so the two <div> tags above will be output as <div class="content"> and <div class="aside"> respectively.

Default Parameter Content

In the examples we’ve seen so far, we’ve only put the param attribute on empty tags. That’s not required though. If you declare a non-empty tag as a parameter, the content of that tag becomes the default when the call does not provide that parameter. This means you can easily add a parameter to any part of the template that you think the caller might want to be able to change:

<def tag="page">
  <html>
     <head> 
      <title param>My Blog</title>
     </head> 
    <body param>
   </html>
</def>

We’ve made the page title parameterized. All existing calls to <page/> will continue to work unchanged, but we’ve now got the ability to change the title on a per-page basis:

<page>
   <title:>My VERY EXCITING Blog</title:>
   <body:>
     ... body content
   </body:> 
</page>

This is a very nice feature of DRYML - whenever you’re writing a tag, and you see a part that might be useful to change in some situations, just throw the param attribute at it and you’re done.

Nested param Declarations

You can nest param declarations inside other tags that have param on them. For example, there’s no need to choose between a <page> tag that provides a single content section and one that provides an aside section as well – a single definition can serve both purposes:

<def tag="page">
   <html>
     <head>
       <title>My Blog</title>
     </head>
     <body param>
       <div param="content"/>
       <div param="aside" />
     </body>
  </html>
 </def>

Here the <body> tag is a param, and so are the two <div> tags inside it. The <page> tag can be called either like this:

<page>
   <body:> ... page content goes here ... </body:>
</page>

Or like this:

<page>
   <content:> ... main content here ... </content:> 
   <aside:>  ... aside content here ... </aside:>
</page>

An interesting question is, what happens if you give both a <body:> parameter and say, <content:>. By providing the <body:> parameter, you have replaced everything inside the body section, including those two parameterized <div> tags, so the <body:> you have provided will appear as normal, but the <content:> parameter will be silently ignored.

The Default Parameter

In the situation where a tag will usually be given a single parameter when called, you can give your tag a more compact XML-like syntax by using the special parameter name default:

<def tag="page"> 
  <html>
     <head>
       <title>My Blog</title>
     </head> 
    <body param="default"/> 
  </html
</def>

Now there is no need to give a parameter tag in the call at all - the content directly inside the <page> tag becomes the default parameter:

<page> ... body content goes here -- no need for a parameter tag ... </page>

You might notice that the <page> tag is now indistinguishable from a normal HTML tag. Some find this aspect of DRYML disconcerting at first – how can you tell what is an HTML tag and what it a defined DRYML tag? The answer is – you can’t, and that’s quite deliberate. This allows you to do nice tricks like define your own smart <form> tag or <a> tag (the Rapid library does exactly that). Other tag-based template languages (e.g. Java’s JSP) like to put everything in XML namespaces. The result is very cluttered views that are boring to type and hard to read. From the start we put a very high priority on making DRYML templates compact and elegant. When you’re new to DRYML you might have to do a lot of looking things up, as you would with any new language or API, but things gradually become familiar and then view templates can be read and understood very easily.

The Implicit Context

In addition to the most important goal behind DRYML - creating a template language that would encourage re-use in the view layer, a secondary goal is for templates to be concise, elegant and readable. One aspect of DRYML that helps a lot in this regard is something called the implicit context.

This feature was born of a simple observation that pretty much every page in a web app renders some kind of hierarchy of application objects. Think about a simple page in a blog - say, the permalink page for an individual post. The page as a whole can be considered a rendering of a BlogPost object. Then we have sections of the page that display different “pieces” of the post – the title, the date, the author’s name, the body. Then we have the comments. The list of comments as a whole is also a “piece” of the BlogPost. Within that we have each of the individual comments, and the whole thing starts again: the comment title, date, author… This can carry on even further, for example some blogs are set up so that you can comment on comments.

This structure is incredibly common, perhaps even universal, as it seems to be intrinsically tied to the way we visually parse information. DRYML’s implicit context takes advantage of this fact to make templates extremely concise while remaining readable and clear. The object that you are rendering in any part of the page is known as the context, and every tag has access to this object through the method this. The controller sets up the initial context, and the templates then only have to mention where the context needs to change.

We’ll dive straight into some examples, but first a quick general point about this guide. If you like to use the full Hobo framework, you will probably always use DRYML and the Rapid tag library together. DRYML and Rapid have grown up together, and the design of each is heavily influenced by the other. Having said that, this is the DRYML Guide, not the Rapid Guide. We won’t be using any Rapid tags in this guide, because we want to document DRYML the language properly. That will possibly be a source of confusion if you’re very used to working with Rapid. Just keep in mind that we’re not allowed to use any Rapid tags in this guide and you’ll be fine.

In order to see the implicit context in its best light, we’ll start by defining a <view> tag, that simply renders the current context with HTML escaping. Remember the context is always available as this:

<def tag="view"><%= h this.to_s %></def>

Next we’ll define a tag for making a link to the current context. We’ll assume the object will be recognized by Rails’ polymorphic routing. Let’s call the tag <l> (for link):

<def tag="l"><a href="#{url_for this}" param="default"/></def>

Now let’s use these tags in a page template. We’ll stick with the comfortingly boring blog post example. In order to set the initial context, our controller action would need to do something like this:

def show   @this = @blog_post = BlogPost.find(params[:id]) end

The DRYML template handler looks for the @this instance variable for the initial context. It’s quite nice to also set the more conventionally named instance variable as we’ve done here.
Now we’ll create the page. Let’s assume we’re using a <page> tag along the lines of those defined above. We’ll also assume that the blog post object has these fields: title, published_at, body and belongs_to :author, and that the author has a name field:

<page>
   <content:>
     <h2><view:title/></h2> 
    <div class="details"> 
       Published by <l:author><view:name/></l> on <view:published-at/>.
     </div> 
    <div class="post-body">
       <view:body/>
     </div>
   </content:>
 </page>

When you see a tag like <view:title/>, you don’t get any prizes for guessing what will be displayed. In terms of what actually happens, you can read this as “change the context to be the title attribute of the current context, then call the <view> tag”. You might like to think of that change to the context as this = this.title (although in fact this is not assignable). But really you just think of it as “view the title”. Of what? Of whatever is in context, in this case the blog post.

Be careful with the two different uses of colon in DRYML. A trailing colon as in <foo:> indicates a parameter tag, whereas a colon joining two names as in <view:title/> indicates a change of context.

When the tag ends, the context is set back to what it was. In the case of <view/> which is a self-closing tag familiar from XML, that happens immediately. The <l:author> tag is more interesting. We set the context to be the author, so that the link goes to the right place. Inside the <l:author> that context remains in place so we just need <view:name/> in order to display the author’s name.


with and field attributes

The with attribute is a special DRYML attribute that sets the context to be the result of any Ruby expression before the tag is called. In DRYML any attribute value that starts with ’&’ is interpreted as a Ruby expression. Here’s the same example as above using only the with attribute:

<page>
   <content:>
     <h2><view with="&@blog_post.title"/></h2>
     <div class="details">
       Published by <l with="&@blog_post.author"><view with="&this.name"/></l>
       on <view with="&@blog_post.published-at"/>.
     </div>
     <div class="post-body">
       <view with="&@blog_post.body"/> 
    </div>
   </content:>
 </page>

Note that we could have used &this.title instead of &@blog_post.title.

The field attribute makes things more concise by taking advantage of a common pattern. When changing the context, we very often want to change to some attribute of the current context. field="x" is a shorthand for with="&this.x" (actually it’s not quite the same, using the field version also sets this_parent and this_field, whereas with does not. This is discussed later in more detail).

The same template again, this time using field:

<page>
   <content:> 
    <h2><view field="title"/></h2>
     <div class="details"> 
      Published by <l field="author"><view field="name"/></l>
       on <view field="published-at"/>.
     </div> 
    <div class="post-body"> 
      <view field="body"/>
     </div>
   </content:>
 </page>

If you compare that example to the first one, you should notice that the : syntax is just a shorthand for the field attribute; i.e., <view field="name"> and <view:name> are equivalent.


Field chains

Sometimes you want to drill down through several fields at a time. Both the field attribute and the : shorthand support this. For example:

<view:category.name/> <view field="category.name"/>

this_field and this_parent

When you change the context using field="my-field" (or the <tag:my-field> shorthand), the previous context is available as this_parent, and the name of the field is available as this_field. If you set the context using with="...", these values are not available. That means the following apparently identical tag calls are not quite the same:

<my-tag with="&@post.title"/>  <my-tag with="&@post" field="title"/>

If the tag requires this_parent and this_field, and in Rapid, for example, some do, then it must be called using the second style.

Numeric field indices

If your current context is a collection, you can use the field attribute to change the context to a single item.

<my-tag field="7" />
  <% i=97 %>
<my-tag field="&i" />

The <repeat> tag sets this_field to the current index into the collection.

<repeat:foos>
   <td><%= this_field %></td>
   <td><view /></td>
 </repeat>

Forms

When rendering the Rapid library’s <form> tag, DRYML keeps track of even more metadata in order to add name attributes to form fields automatically. This mechanism does not work if you set the context using with=.

Tag attributes

As we’ve seen, DRYML provides parameters as a mechanism for Customizing the markup that is output by a tag. Sometimes we want to provide other kinds of values to control the behavior of a tag: URLs, filenames or even Ruby values like hashes and arrays. For this situation, DRYML lets you define tag attributes.

As a simple example, say your application has a bunch of help files in public/help, and you have links to them scattered around your views. Here’s a tag you could define:

<def tag="help-link" attrs="file">
   <a class="help" href="#{base_url}/help/#{file}.html" param="default"/> </def>

<def> takes a special attribute attrs. Use this to declare a list (separated by commas) of attributes, much as you would declare arguments to a method in Ruby. Here we’ve defined one attribute, file, and just like arguments in Ruby, file becomes a local variable inside the tag definition. In this definition we construct the href attribute from the base_url helper and file, using Ruby string interpolation syntax (#{....}). Remember that you can use that syntax when providing a value for any attribute in DRYML.

The call to this tag would look like this:

<help-link file="intro">Introductory Help</help-link>

Using regular XML-like attribute syntax – file="intro" – passes “intro” as a string value to the attribute. DRYML also allows you to pass any Ruby value. When the attribute value starts with &, the rest of the attribute is interpreted as a Ruby expression. For example you could use this syntax to pass true and false values:

<help-link file="intro" new-window="&true">Introductory Help</help-link> <help-link file="intro" new-window="&false">Introductory Help</help-link>

And we could add that new-window attribute to the definition like this:

<def tag="help-link" attrs="file, new-window">
   <a class="help" href="#{base_url}/help/#{file}.html"      target="#{new_window ? '_blank' : '_self' }" param="default"/>
 </def>

An important point to notice there is that the markup-friendly dash in the new-window attribute became a Ruby-friendly underscore (new_window) in the local variable inside the tag definition.
Using the &, you can pass any value you like – arrays, hashes, active-record objects…
In the case of boolean values like the one used in the above example, there is a nicer syntax that can be used in the call…

Flag attributes

That new-window attribute shown in the previous section is simple switch - on or off. DRYML lets you omit the value of the attribute, giving a flag-like syntax:

<help-link file="intro" new-window>Introductory Help</help-link> 
<help-link file="intro">Introductory Help</help-link>

Omitting the attribute value is equivalent to giving "&true" as the value. In the second example the attribute is omitted entirely, meaning the value will be nil which evaluates to false in Ruby and so works as expected.

attributes and all_attributes locals

Inside a tag definition two hashes are available in local variables:
attributes contains all the attributes that were not declared in the attrs list of the def but that were provided in the call to the tag.
all_attributes contains every attribute, including the declared ones.

Merging Attributes

In a tag definition, you can use the merge-attrs attribute to take any ‘extra’ attributes that the caller passed in, and add them to a tag of your choosing inside your definition. Let’s backtrack a bit and see why you might want to do that.

Here’s a simple definition for a <markdown-help> tag--it’s similar to a tag defined in the Hobo Cookbook app:

<def tag="markdown-help">
   <a href="http://daringfireball.net/..." param="default"/>
 </def>

You would use it like this:

Add formatting using <markdown-help>markdown</markdown-help>

Suppose you wanted to give the caller the ability to choose the target for the link. You could extend the definition like this:

<def tag="markdown-help" attrs="target">
   <a href="http://daringfireball.net/..." target="&target" param="default"/> </def>

Now we can call the tag like this:

Add formatting using <markdown-help target="_blank">markdown</markdown-help>

OK, but maybe the caller wants to add a CSS class, or a javascript onclick attribute, or any one of a dozen potential HTML attributes. This approach is not going to scale. That’s where merge-attrs comes in. As mentioned above, DRYML keeps track of all the attributes that were passed to a tag, even if they were not declared in the attrs list of the tag definition. They are available in two hashes: attributes (that has only undeclared attributes) and all_attributes (that has all of them), but in normal usage you don’t need to access those variables directly. To add all of the undeclared attributes to a tag inside your definition, just add the merge-attrs attribute, like this:

<def tag="markdown-help"> 
  <a href="http://daringfireball.net/..." merge-attrs param="default"/> </def>

Note that the merge attribute is another way of merging attributes. Declaring merge is a shorthand for declaring both merge-attrs and merge-params (which we’ll cover later).

Merging selected attributes

merge-attrs can be given a value - either a hash containing attribute names and values, or a list of attribute names (comma separated), to be merged from the all_attributes variable.
Examples:

<a merge-attrs="href, name">
<a merge-attrs="&my_attribute_hash">

A requirement that crops up from time to time is to forward to a tag all the attributes that it understands (i.e. the attributes from that tag’s attrs list), and to forward some or all the other attributes to tags called within that tag. Say for example, we are declaring a tag that renders a section of content, with some navigation at the top. We want to be able to add CSS classes and so on to the main <div> that will be output, but the <navigation> tag also defines some special attributes, and these need to be forwarded to it.

To achieve this we take advantage of a helper method attrs_for. Given the name of a tag, it returns the list of attributes declared by that tag.

Here’s the definition:

<def tag="section-with-nav"> 
  <div class="section" merge-attrs="&attributes - attrs_for(:navigation)">               <navigation merge-attrs="&attributes & attrs_for(:navigation)"/>
     <do param="default"/>
   </div>
 </def>

Note that:

The expression attributes - attrs_for(:navigation) returns a hash of only those attributes from the attributes hash that are not declared by <navigation> (The - operator on Hash comes from HoboSupport)
The expression attributes & attrs_for(:navigation) returns a hash of only those attributes from the attributes hash that are declared by <navigation> (The & operator on Hash comes from HoboSupport)
The <do> tag is a “do nothing” tag, defined by the core DRYML taglib, which is always included.

The class attribute

If you have the following definition:

<def tag="foo">   <div id="foo" class="bar" merge-attrs /> </def>

and the user invokes it with:

<foo id="baz" class="bop" />

The following content will result:

<foo id="baz" class="bar bop" />

The class attribute receives special behavior when merging. All other attributes are overridden with the user specified values. The class attribute takes on the values from both the tag definition and invocation.

Repeated and optional content
As you would expect from any template language, DRYML has the facility to repeat sections of content, and to optionally render or not render given sections according to your application’s data. DRYML provides two alternative syntaxes, much as Ruby does (e.g. Ruby has the block if and the one-line suffix version of if).

Conditionals - if and unless

DRYML provides if and unless both as tags, which come from the core tag library, and are just ordinary tag definitions, and as attributes, which are part of the language:

The tag version:

<if test="&logged_in?"><p>Welcome back</p></if>

The attribute version:

<p if="&logged_in?">Welcome back</p>

Important note! The test is performed (in Ruby terms) like this:

if (...your test expression...).blank?

Got that? Blankiness not truthiness (blank? comes from ActiveSupport by the way – Rails’ mixed bag of core-Ruby extensions). So for example, in DRYML:

<if test="&current_user.comments">

is a test to see if there are any comments – empty collections are considered blank. We are of the opinion that Matz made a fantastic choice for Ruby when he followed the Lisp / Smalltalk approach to truth values, but that view templates are a special case, and testing for blankness is more often what you want.

Can we skip <unless>? It’s like <if> with the nest negated. You get the picture, right?

Repetition

For repeating sections of content, DRYML has the <repeat> tag (from the core tag library) and the repeat attribute.

The tag version:

<repeat with="&current_user.new_messages">
  <h3><%= h this.subject %></h3>
</repeat>

The attribute version:

<h3 repeat="&current_user.new_messages"><%= h this.subject %></h3>

Notice that as well as the content being repeated, the implicit context is set to each item in the collection in turn.

Even/odd classes

It’s a common need to want alternating styles for items in a collection - e.g. striped table rows. Both the repeat attribute and the repeat tag set a scoped variable scope.even_odd which will be alternately ‘even’ then ‘odd’, so you could do:

<h3 repeat="&new_messages" class="#{scope.even_odd}"><%= h this.subject %></h3>

That example illustrates another important point – any Ruby code in attributes is evaluated inside the repeat. In other words, the repeat attribute behaves the same as wrapping the tag in a <repeat> tag.

first_item? and last_item? helpers

Another common need is to give special treatment to the first and last items in a collection. The first_item? and last_item? helpers can be used to find out when these items come up; e.g., we could use first_item? to capitalise the first item:

<h3 repeat="&new_messages"><%= h(first_item? ? this.subject.upcase : this.subject) %></h3>

Repeating over hashes

If you give a hash as the value to repeat over, DRYML will iterate over each key/value pair, with the value available as this (i.e. the implicit context) and the key available as this_key. This is particularly useful for grouping things in combination with the group_by method:

<div repeat="&current_user.new_messages.group_by(&:sender)"> 
  <h2>Messages from <%= h this_key %></h2>
     <ul> 
      <li repeat><%= h this.subject %></li>
     </ul>
   <h2>
</div>

That example has given a sneak preview of another point - using if/unless/repeat with the implicit context. We’ll get to that in a minute.


Using the implicit context

If you don’t specify the test of a conditional, or the collection to repeat over, the implicit context is used. This allows for a few nice shorthands. For example, this is a common pattern for rendering collections:

<if:comments> 
  <h3>Comments</h3> 
  <ul> 
    <li repeat> ... </li>
   </ul>
</if>

We’re switching the context on the <if> tag to be this.comments, which has two effects. Firstly the comments collection is used as the test for the if, so the whole section including the heading will be omitted if the collection is empty (remember that if tests for blankness, and empty collections are considered blank). Secondly, the context is switched to be the comments collection, so that when we come to repeat the <li> tag, all we need to say is repeat.

One last shorthand - attributes of this

The attribute versions of if/unless and repeat support a useful shortcut for accessing attributes or methods of the implicit context. If you give a literal string attribute–that is, an attribute that does not start with &–this is interpreted as the name of a method on this. For example:

<li repeat="comments"/>

is equivalent to

<li repeat="&this.comments"/>

Similarly

<p if="sticky?">This post has been marked 'sticky'</p>

is equivalent to

<p if="this.sticky?">This post has been marked 'sticky'</p>

It is a bit inconsistent that these shortcuts do not work with the tag versions of <if>, <unless> and <repeat>. This may be remedied in a future version of DRYML.

Content tags only

The attributes introduced in this section – repeat, if and unless, can only be used on content tags, i.e. static HTML tags and defined tags. They cannot be used on tags like <def>, <extend> and <include>.

Pseudo parameters - before, after, append, prepend, and replace

For every parameter you define in a tag, there are five “pseudo parameters” created as well. Four allow you to insert extra content without replacing existing content, and one lets you replace or remove a parameter entirely.

To help illustrate these, here’s a very simple <page> tag:

<def tag="page"> 
  <body>
     <h1 param="heading"><%= h @this.to_s %></h1>
     <div param="content"></div>
   </body>
 </def>

We’ve assumed that @this.to_s will give us the name of the object that this page is presenting.

Inserting extra content

The output of the heading would look something like:

<h1 class="heading">Welcome to my new blog</h1>

Pseudo parameters give us the ability to insert extra context in four places, marked here as (A), (B), (C) and (D):

(A)<h1 class="heading">(B)Welcome to my new blog(C)</h1>(D)

The parameters are:
(A) – <before-heading:>
(B) – <prepend-heading:>
(C) – <append-heading:>
(D) – <after-heading:>

So, for example, suppose we want to add the name of the blog to the heading:

<h1 class="heading">Welcome to my new blog -- The Hobo Blog</h1>

To achieve that on one page, we could call the <page> tag like this:

<page>
   <append-heading:> -- The Hobo Blog</append-heading:>
   <body:>     ...   </body>
</page>

Or we could go a step further and create a new page tag that added that suffix automatically. We could then use that new page tag for an entire section of our site:

<def tag="blog-page">
   <page>
    <append-heading:> -- The Hobo Blog</append-heading:> 
    <body: param></body>
   </page>
</def>

Note: we have explicitly made sure that the <body:> parameter is still available. There is a better way of achieving this using merge-params or merge, which are covered later.)

The default parameter supports append and prepend

As we’ve seen, the <append-...:> and <prepend-...:> parameters insert content at the beginning and end of a tag’s content. But in the case of a defined tag that may output all sorts of other tags and may itself define many parameters, what exactly is the tag’s “content”? It is whatever is contained in the default parameter tag. So <append-...:> and <prepend-...:> only work on tags that define a default parameter.

For this reason, you will often see tag definitions include a default parameter, even though it would be rare to use it directly. It is there so that <append-...:> and <prepend-...:> work as expected.

Replacing a parameter entirely

So far, we’ve seen how the parameter mechanism allows us to change the attributes and content of a tag, but what if we want to remove the tag entirely? We might want a page that has no <h1> tag at all, or has <h2> instead. For that situation we can use “replace parameters”. Here’s a page with an <h2> instead of an <h1>:

<page>
   <heading: replace><h2>My Awesome Page</h2></heading:>
</page>

And here’s one with no heading at all:

<page>
   <heading: replace/> 
</page>

There is a nice shorthand for the second case. For every parameter, the enclosing tag also supports a special without attribute. This is exactly equivalent to the previous example, but much more readable:

<page without-heading/>

Note: To make things more consistent, <heading: replace> may become <replace-heading:> in the future.

Current limitation

Due to a limitation of the current DRYML implementation, you cannot use both before and after on the same parameter. You can achieve the same effect as follows (this technique is covered properly later in the section on wrapping content):

<heading: replace> 
  ... before content ...
   <heading restore>
   ... after content ...
 </heading:>


Nested parameters

As we’ve discussed at the start of this guide, one of the main motivations for the creation of DRYML was to deliver a higher degree of re-use in the view layer. One of the great challenges of re-use is managing the constant tension between re-use and flexibility: the greater the need for flexibility, the harder it is to re-use existing code. This has a very direct effect on the size of things that we can successfully re-use. Take the humble hypertext link for example. A link is a link is a link – there’s only so much you could really want to change, so it’s not surprising that long ago we stopped having to assemble links from fragments of HTML text. Rails has its link_to helper, and Hobo Rapid has its <a> tag. At the other extreme, reusing an entire photo gallery or interactive calendar is extremely difficult. Again no surprise–these things have been built from scratch over and over again, because each time something slightly (or very) different is needed. A single calendar component that is flexible enough to cover every eventuality would be so complicated that configuring it would be more effort than starting over.

This tension between re-use and flexibility will probably never go away; life is just like that. As components get larger they will inevitably get either harder to work with or less flexible. What we can do though, through technologies like DRYML, is slow down the onset of these problems. By thinking about the fundamental challenges to re-use, we have tried to create a language in which, as components grow larger, simplicity and flexibility can be retained longer.

One of the most important features that DRYML brings to the re-use party is nested parameters. 

They are born of the following observations:

As components get larger, they are not really single components at all, but compositions of many smaller sub-components.
Often, the Customization we wish to make is not to the “super-component” but to one of the sub-components.
What is needed, then, is a means to pass parameters and attributes not just to the tag you are calling, but to the tag called within the tag, or the tag called within the tag called within the tag, and so on.

DRYML’s nested parameter mechanism does exactly that. After you’ve been using DRYML for some time, you may notice that you don’t use this feature very often. But when you do use it, it can make the difference between sticking with your nice high-level components or throwing them away and rebuilding from scratch. A little use of nested parameters goes a long way.

An example

To illustrate the mechanism, we’ll build up a small example using ideas that are familiar from Rapid. This is not a Rapid guide though, so we’ll define these tags from scratch. First off, the <card> tag. This captures the very common pattern of web pages displaying collections of some kind of object as small “cards”: comments, friends, discussion threads, etc.

<def tag="card">
  <div class="card" merge-attrs>
     <h3 param="heading"><%= h this.to_s %></h3>
     <div param="body"></div>
   </div>
</def>

We’ve defined a very simple <card> that uses the to_s method to give a default heading, and provides a <body:> parameter that is blank by default. Here’s how we might use it:

<h2>Discussions</h2>
 <ul>
   <li repeat="@discussions"> 
    <card> 
      <body:><%= this.posts.length %> posts</body:>
     </card> 
    </li>
 </ul>

This example (specifically, the collection created in the <li repeat="@discussions"> section) demonstrates that as soon as we have the concept of a card, we very often find ourselves wanting to render a collection of <card> tags. The obvious next step is to capture that collection-of-cards idea as a reusable tag:

<def tag="collection"> 
  <h2 param="heading"></h2>
   <ul>
     <li repeat>
      <card param>
     </li>
   </ul>
 </def>

The <collection> tag has a straightforward <heading:> parameter, but notice that the <card> tag is also declared as a parameter. Whenever you add param to a tag that itself also has parameters, you give your “super-tag” (<collection> in this case) the ability to customize the “sub-tag” (<card> in this case) using nested parameters. Here’s how we can use the nested parameters in the <collection> tag to get the same output as the <li repeat="@discussions"> section in the previous example:

<collection>
   <heading:>Discussions</heading>
   <card:>
     <body:><%= this.posts.length %>posts</body:>
   </card:>
 </collection>

This nesting works to any depth. To show this, if we define an <index-page> tag that uses <collection> and declares it as a parameter:

<def tag="index-page">
   <html>
     <head> ... </head>
     <body>
       <h1 param="heading"></h1>
       ...
        <collection param>
       ...
     </body> 
  </html>
 </def>

we can still access the card inside the collection inside the page:

<index-page>
   <heading:>Welcome to our forum</heading:>
   <collection:>
     <heading:>Discussions</heading>
     <card:><body:><%= this.posts.length %>posts</body:></card:>
    </collection:>
</index-page>

Pay careful attention to the use of the trailing ’:’. The definition of <index-page> contains a call the collection tag, written <collection> (no ’:’). By contrast, the above call to <index-page> customizes the call to the collection tag that is already present inside <index-page>, so we write <collection:> (with a ’:’). Remember:

Without ’:’ – call a tag
With ’:’ – customize an existing call inside the definition

Customizing and extending tags

As we’ve seen, DRYML makes it easy to define tags that are highly customizable. By adding prams to the tags inside your definition, the caller can insert, replace and tweak to their heart’s content. Sometimes the changes you make to a tag’s output are needed not once, but many times throughout the site. In other words, you want to define a new tag in terms of an existing tag.

New tags from old

As an example, let’s bring back our card tag:

<def tag="card">
   <div class="card" merge-attrs>
     <h3 param="heading"><%= h this.to_s %></h3>
     <div param="body"></div>
   </div>
</def>

Now let’s say we want a new kind of card, one that has a link to the resource that it represents. Rather than redefine the whole thing from scratch, we can define the new card, say, “linked-card”, like this:

<def tag="linked-card"> 
  <card>
     <heading: param><a href="&object_url this"><%= h this.to_s %></a>
     </heading:>
   </card>
 </def>

That’s all well and good but there are a couple of problems:

The original card used merge-attrs so that we could add arbitrary HTML attributes to the final <div>. Our new card has lost that feature
Worse than that, the new card is in fact useless, as there’s no way to pass it the body parameter

Let’s solve those problems in turn. First the attributes.

merge-attrs again

In fact merge-attrs works just the same on defined tags as it does on HTML tags that are output, so we can simply add it to the call to <card>, like this:

<def tag="linked-card">
   <card merge-attrs>
    <heading: param><a href="&object_url this"><%= h this.to_s %></a>
   </heading:>
   </card>
</def>

Now we can do things like <linked-card class="emphasised">, and the attribute will be passed from <linked-card>, to <card>, to the rendered <div>.

Now we’ll fix the parameters, it’s going to look somewhat similar…

merge-prams

We’ll introduce merge-prams the same way we introduced merge-attrs – by showing how you would get by without it. The problem with our <linked-card> tag is that we’ve lost the <body:> parameter. We could bring it back like this:

<def tag="linked-card">
   <card merge-attrs> 
    <heading: param><a href="&object_url this"><%= h this.to_s %></a>
    </heading:>
     <body: param/>
   </card>
</def>

In other words, we use the param declaration to give <linked-card> a <body:> parameter, which is forwarded to <card>. But what if <card> had several parameters? We would have to list them all out. And what if we add a new parameter to <card> later? We would have to remember to update <linked-card> and any other customized cards we had defined.
Instead we use merge-prams, much as we use merge-attrs:

<def tag="linked-card"> 
  <card merge-attrs merge-params>
     <heading: param><a href="&object_url this"><%= h this.to_s %></a>
     </heading:>
   </card>
 </def>

You can read merge-prams as: take any “extra” parameters passed to <linked-card> and forward them all to <card>. By “extra” parameters, we mean any that are not declared as parameters (via the param attribute) inside the definition of <linked-card>.

There are two local variables inside the tag definition that mirror the attributes and all_attributes variables described previously:

parameters a hash containing all the “extra” parameters (those that do not match a declared parameter name)
all parameters a hash containing all the parameters passed to the tag

The values in these hashes are Ruby procs. One common use of all parameters is to test if a certain parameter was passed or not:

<if test="&all_parameters[:body]">

In fact, all parameters and parameters are not regular hashes, they are instances of a subclass of Hash – Hobo::Dryml::TagParameters. This subclass allows parameters to be called as if they were methods on the hash object, e.g.:

parameters.default

That’s not something you’ll use often.


Merge

As it’s very common to want both merge-attrs and merge-prams on the same tag, there is a shorthand for this: merge. So the final, preferred definition of <linked-card> is:

<def tag="linked-card">
   <card merge>
     <heading: param><a href="&object_url this"><%= h this.to_s %></a>
    </heading:>
   </card>
 </def>

Merging selected parameters

Just as with merge-attrs, merge-prams can be given a value - either a hash containing the parameters you wish to merge, or a list of parameter names (comma separated), to be merged from the all parameters variable.

Examples:

<card merge-params="heading, body">
<card merge-params="&my_parameter_hash">

Extending a tag

We’ve now seen how to easily create a new tag from an existing tag. But what if we don’t actually want a new tag, but rather we want to change the behavior of an existing tag in some way, and keep the tag name the same. What we can’t do is simply use the existing name in the definition:

<!-- DOESN'T WORK! -->
 <def tag="card"> 
  <card merge>
    <heading: param><a href="&object_url this"><%= h this.to_s %></a>
   </heading:>
   </card>
 </def>

All we’ve done there is created a nice stack overflow when the card calls itself over and over.
Fortunately, DRYML has support for extending tags. Use <extend> instead of <def>:

<extend tag="card">
   <old-card merge>
     <heading: param><a href="&object_url this"><%= h this.to_s %></a>
     </heading:>
   </old-card>
 </extend>

The one thing to notice there is that the “old” version of <card>, i.e. the one that was active before you’re extension, is available as <old-card>. That’s about all there is to it.
Here’s another example where we add a footer to every page in our application. It’s very common to <extend tag="page"> in your application.dryml, in order to make changes that should appear on every page:

<extend tag="page">
   <old-page merge>
     <footer: param> 
      ... 
       your custom footer here
       ... 
    </footer:>
   </old-page>
</extend>

Aliasing tags

Welcome to the shortest section of The DRYML Guide…

If you want to create an alias of a tag; i.e., an identical tag with a different name:

<def tag="my-card" alias-of="card"/>

Note that it is a self-closing tag–there is no body to the definition.

So… that’s aliasing tags then…

Polymorphic tags

DRYML allows you to define a whole collection of tags that share the same name, where each definition is appropriate for a particular type of object being rendered. When you call the tag, the type (i.e. class) of the context is used to determine which definition to call. These are called polymorphic tags.

To illustrate how these work, let’s bring back our simple <card> tag once more:

<def tag="card" polymorphic>
   <div class="card" merge-attrs>
      <h3 param="heading"><%= h this.to_s %></h3> 
      <div param="body">
      </div>
    </div>
 </def>

We’ve added the polymorphic attribute to the <def>. This tells DRYML that <card> can have many definitions, each for a particular type. The definition we’ve given here is called the “base” definition or the “base card”. The base definition serves two purposes:

It is the fallback if we call <card> and no definition is found for the current type.
The type-specific definition can use the base definition as a starting point to be further customized.

To add a type-specific <card>, we use the for attribute on the <def>. For example, a card for a Product:

<def tag="card" for="Product">   ... </def>

Note: If the name in the for attribute starts with an uppercase letter, it is taken to be a class name. Otherwise it is taken to be an abbreviated name registered with HoboFields; e.g.:

 <def tag="input" for="email_address">

For the product card, lets make the heading be a link to the product, and put the price of the product in the body area:

<def tag="card" for="Product">
   <card merge>
     <heading: param><a href="#{object_url this}"><%= h this.to_s %></a>
     </heading:>
     <body: param="price">$<%= this.price %></body:>
   </card>
</def>

We call this a type-specific definition. Some points to notice:

The callback to <card> is not a recursive loop, but a call to the base definition.
We’re using the normal technique for Customizing / extending an existing card; i.e., we’re using merge.

It is not required for the type-specific definition to call the base definition, it’s just often convenient. In fact the base definition is not required. It is valid to declare a polymorphic tag with no content:

<def tag="my-tag" polymorphic/>

Type hierarchy

If, for a given call, no type-specific definition is available for this.class, the search continues with this.class.superclass and so on up the superclass chain. If the search reaches either ActiveRecord::Base or Object, the base definition is used.

Specifying the type explicitly

Sometimes it is useful to give the type explicitly for the call explicitly (i.e., to override the use of this.class). The for-type attribute (on the call) provides this facility. For example, you might want to implement one type-specific definition in terms of another:

<def tag="card" for="SpecialProduct">
   <card for-type="Product">
     <append-price:>Today Only!)</append-price:>
   </card>
</def>


Extending polymorphic tags

Type-specific definitions can be extended just like any other tag using the <extend> tag. For example, here we simply remove the price:

<extend tag="card" for="Product">
   <old-card merge without-price/>
 </extend>


Wrapping content

DRYML provides two mechanisms for wrapping existing content inside new tags.

Wrapping inside a parameter

Once or twice in the previous examples, we have extended our card tag definition, replacing the plain heading with a hyperlink heading. Here is an example call to our extended card tag:

<card>
   <heading:><a href="#{object_url this}"><%= h this.to_s %></a></heading:> </card>

There’s a bit of repetition there – <%= h this.to_s %> was already present in the original definition. All we really wanted to do was wrap the existing heading in an <a>. In this case there wasn’t much markup to repeat, so it wasn’t a big deal, but in other cases there might be much more.

We can’t use <prepend-heading:><a></prepend-heading:> and <append-heading:></a></append-heading:> because that’s not well formed markup (and is very messy besides). Instead, DRYML has a specific feature for this situation. The <param-content> tag is a special tag that brings back the default content for a parameter.

Here’s how it works:

<card>
   <heading:>
     <a href="#{object_url this}"><param-content for="heading"/></a>
   </heading:>
</card>

That’s the correct way to wrap inside the parameter, so in this case the output is:

<h3><a href="...">Fried Bananas</a></h3>

What if we wanted to wrap the entire <heading:> parameter, including the <h3> tags?

Wrapping outside a parameter

For example, we might want to give the card a new ‘header’ section, that contained the heading, and the time the record was created, like this:

<div class="header">
   <h3>Fried Bananas</h3>
   <p>Created: ....</p>
</div>

To use DRYML terminology, what we’ve done there is replaced the entire heading with some new content, and the new content happens to contain the original heading. So we replaced the heading, and then restored it again, which in DRYML is written:

<card>
   <heading: replace> 
    <div class="header">
      <heading: restore/> 
      <p>Created: <%= this.created_at.to_s(:short) %></p>
     </div>
   </heading:>
 </card>

To summarize: 

To wrap content inside a parameter, use <param-content/>
To wrap an entire parameter, including the parameterized tag itself (the <h3> in our examples), use the replace and restore attributes.

Local variables and scoped variables.

DRYML provides two tags for setting variables: <set> and <set-scoped>.

Setting local variables with <set>

Sometimes it’s useful to define a local variable inside a template or a tag definition. It’s worth avoiding if you can, as we don’t really want our view layer to contain lots of low-level code, but sometimes it’s unavoidable. Because DRYML extends ERB, you can simply write:

<% total = price_of_fish * number_of_fish %>

For purely aesthetic reasons, DRYML provides a tag that does the same thing:

<set total="&price_of_fish * number_of_fish"/>

Note that you can put as many attribute/value pairs as you like on the same <set> tag, but the order of evaluation is not defined.

Scoped variables – <set-scoped>

Scoped variables (which is not a great name, we realize as we come to document them properly) are kind of like global variables with a limited lifespan. We all know the pitfalls of global variables, and DRYML’s scoped variables should indeed be used as sparingly as possible, but you can pull off some very useful tricks with them.

The <set-scoped> tag is very much like <set> except you open it up and put DRYML inside it:

<set-scoped xyz="&...">    ... </set-scoped>

The value is available as scope.xyz anywhere inside the tag and in any tags that are called inside that tag. That’s the difference between <set> and <set-scoped>. 

They are like dynamic variables from LISP. To repeat the point, they are like global variables that exist from the time the <set-scope> tag is evaluated, and for the duration of the evaluation of the body of the tag, and are then removed.

As an example of their use, let’s define a simple tag for rendering navigation links. The output should be a list of <a> tags, and the <a> that represents the “current” page should have a CSS class “current”, so it can be highlighted in some way by the stylesheet. (In fact, the need to create a reusable tag like this is where the feature originally came from).

On our pages, we’d like to simply call, say:

  <main-nav current="Home">`

And we’d like it to be easy to define our own <main-nav> tag in our applications:
<def tag="main-nav">
   <navigation merge-attrs>
     <nav-item href="...">Home</nav-item> 
    <nav-item href="...">News</nav-item>
     <nav-item href="...">Offers</nav-item>
   </navigation>
 </def>

Here’s the definition for the <navigation> tag:

<def tag="navigation" attrs="current">
   <set-scoped current-nav-item="current">
    <ul merge-attrs param="default"/> 
  </set-scoped>
</def>

All <navigation> does is set a scoped-variable to whatever was given as current and output the body wrapped in a <ul>.

Here’s the definition for the <nav-item> tag:

<def tag="nav-item">
   <set body="&parameters.default"/> 
   <li class="#{'current' if scope.current_nav_item == body}"> 
    <a merge-attrs><%= body %>
   </li>
</def>

The content inside the <nav-item> is compared to scope.current_nav_item. If they are the same, the “current” class is added. Also note the way parameters.default is evaluated and the result stored in the local variable body, in order to avoid evaluating the body twice.

Nested scopes

One of the strengths of scoped variables is that scopes can be nested, and where there are name clashes, the parent scope variable is temporarily hidden, rather than overwritten. With a bit of tweaking, we could use this fact to extend our <navigation> tag to support a sub-menu of links within a top level section. The sub-menu could also use <navigation> and <nav-item> and the two scope.current_nav_item variables would not conflict with each other.

Taglibs

DRYML provides the <include> tag to support breaking up lots of tag definitions into separate “tag libraries”, known as taglibs. You can call <include> with several different formats:

<include src="foo"/>

Load foo.dryml from the same directory as the current template or taglib.

<include src="path/to/foo"/>

Load app/views/path/to/foo.dryml

<include src="foo" plugin="path/to/plugin"/>

Load vendor/plugins/path/to/plugin/taglibs/foo.dryml

When running in development mode, all of these libraries are automatically reloaded on every request.

Divergences from XML and HTML

Self-closing tags

In DRYML, <foo:/> and <foo:></foo:> have two slightly different meanings.
The second form replaces the parameter’s default inner content with the specified content:  nothing in this case.

The first form uses the parameters default inner content unchanged.

This is very useful if you wish to add an attribute to a parameter but leave the inner content unchanged. In this example:

<def tag="bar">
  <div class="container" merge-attrs> 
    <p class="content" param>
      Hello
     </p>
   </div>
 <def>

 Then:

<bar><foo: class="my-foo"/></bar>
Gives:

<div class="container">
   <p class="content my-foo">
     Hello
   </p>
 </div>

If you used:

<bar><foo: class="my-foo"></foo:></bar>

You would get:

<div class="container">
   <p class="content my-foo"></p>
</div>

Colons in tag names

In XML, colons are valid inside tag and attribute names. However they are reserved for “experiments for namespaces”. So it’s possible that we may be non-compliant with the not-yet-existent XML 2.0.

Close tag shortcuts

In DRYML, you’re allowed to close tags with everything preceding the colon:

<view:name> Hello </view>

XML requires the full tag to be specified:

<view:name> Hello </view:name>

Null end tags

Self-closing tags are technically illegal in HTML. So <br /> is technically not valid HTML. However, browsers do parse it as you expect. It is valid XHTML, though.

However, browsers only do this for empty elements. So tags such as <script> and <a> require a separate closing tag in HTML. This behavior has surprised many people: 

<script src="foobar.js" />

…is not recognized in many web browsers for this reason. You must use:

 <script src="foorbar.js"></script>

 …in HTML instead.

DRYML follows the XML conventions:

 <a/>

 …is valid DRYML.


CHAPTER 14 – THE HOBO RAPID TAG LIBRARY

This section of the book serves as reference for all of the pre-defined DRYML tags used by Hobo to provide the “magic” rendering of pages and forms without you coding.  You can learn how to extend and use these tags to customize your applications.
Look at the figure below that shows the contents of rapid.dryml

You see how the rapid.dryml file includes the following source files, in alphabetical order:
rapid_core.dryml
rapid_document_tags.dryml
rapid_pages.dryml
rapid_editng.dryml
rapid_forms.dryml
rapid_navigation.dryml
rapid_plus.dryml
rapid_generics.dryml
rapid_lifecycles.dryml
rapid_support.dryml

Rapid Tag Library Index

The following categories will be described in detail in the rest of this chapter:
Core
Core DRYML tags. These are included implicitly and are always available. Contains mainly control-flow tags.
Rapid
This taglib does not define tags - it just includes all the other taglibs. 
Rapid Core
Core Rapid tags and tags that don’t belong to other categories.
Rapid Document Tags
Extra tags for semantic markup.
Rapid Editing
Rapid Editing provides “in-place” or “AJAX” editors for various basic data types. 
Rapid Forms
Rapid Forms provides various tags that make it quick and easy to produce working new or edit forms.
Rapid Generics
Rapid Generics provides tags that provide generic renderings that can adapt to the model being rendered.
Rapid Lifecycles
Contains view-layer support for Hobo’s lifecycles.
Rapid Navigation
Support for navigation links, account navigation (log in, out etc.) and pagination navigation.
Rapid Pages
Rapid-Pages provides tags for working with entire pages.
Rapid Plus
Tags that define higher level interactive ‘widgets’
Rapid Summary
A collection of tags that allow an application outline or summary to be created.
Rapid Support
Rapid Support is the home for some tags that are useful in defining other tags.
Rapid User Pages
Rapid User Pages contains tags that implement the basics of Hobo’s user management: log in, sign up, forgot password etc.




Core

Core DRYML tags. These are included implicitly and are always available. Contains mainly control-flow tags.

<call-tag>
<wrap>
<partial>
<repeat>
<do>
<with>
<if>
<else>
<unless>

<call-tag>
Call the tag given by the tag attribute. This lets you call tags dynamically based on some runtime value. It’s the DRYML equivalent of Ruby’s send method.

<wrap>
Wrap the body in the tag specified by the tag attribute, if when is true.
Using regular DRYML conditional logic it is rather awkward to conditionally wrap some tag in another tag. This tag makes it easy to do that.

Usage
For example, you might want to wrap an <img> tag in an <a> tag but only under certain conditions. Say the current context has an href attribute that may or may not be nil. We want to wrap the img in <a> if href is not nil:

<wrap when="&this.href.present?" tag="a" href="&this.href">
  <img src="&this.img_filename"/>
</wrap>

<partial>
DRYML version of render(:partial => 'my_partial')

Usage

<partial name="my-partial" locals="&{:x => 10, :y => 20}"/>

<repeat>
Repeat a section of mark-up. The context should be a collection (anything that responds to each). The content of the call to <repeat> will be repeated for each item in the collection, and the context will be set to each item in turn.


Attributes
join: The value of this attribute, if given, will be inserted between each of the items (e.g. join=", " is very common).

<do>
The ‘do nothing’ tag. Used to add parameters or change context without adding any markup

<with>
Alias of do

<if>
DRYML’s ‘if’ test

Usage

<if test="&current_user.administrator?">Logged in as administrator</if>
  <else>Logged in as normal user
 </else>

Note: <if> tests for non-blank vs. blank (as defined by ActiveSupport), not true vs. false. If you do not give the test attribute, uses the current context instead. This allows a nice trick like this:

<if:comments>...</if>

This has the double effect of changing the context to the this.comments, and only evaluating the body if there are comments (because an empty collection is considered blank)

<else>
General purpose else clause. <else> works with various tags such as <if> and <repeat> (the else clause will be output if the collection was empty). It simply outputs its content if Hobo::Dryml.last_if is false. This is pretty much a crazy hack, which violates many good principles of language design, but it’s very useful : )

<unless>
Same behavior as <if>, except the test is negated.
Rapid Core

Core Rapid tags and tags that don’t belong to other categories.

<dev-user-changer>
<field-list>
<nil-view>
<table>
<image>
<spinner>
<hobo-rapid-javascripts>
<name>
<type-name>
<collection-name>
<a>
<count>
<theme-stylesheet>
<You>
<Your>
<A-or-An>
<comma-list>
<collection-list>
<collection-view>
<links-for-collection>
<view>

<dev-user-changer>
Development mode only - a menu to change the current_user

<field-list>
Renders a table with one row per field, where each row contains a <th> with the field name, and a <td> with (by default) a <view> of the field.

Parameters
#{this_field.to_s.sub('?', '')}-label 
label 
#{this_field.to_s.sub('?', '')}-view 
view 
#{this_field.to_s.sub('?', '')}-tag 
input-help 



Attributes
fields: Comma separated list of field names to display. Defaults to the fields returned by the standard_fields helper. That is, all fields apart from IDs and timestamps.
force-all: All non-viewable fields will be skipped unless this attribute is given
skip: Comma separated list of fields to exclude
tag: The name of a tag to use inside the <td> to display the value. Defaults to view
show-non-editable: By default, if tag is set to input, fields for which the current user does not have edit permission will be skipped (the entire row is skipped). Set this attribute to keep them. (Note that <input> automatically degrades to <view> if the user does not have edit permission.)

Example
 
<field-list fields="first-name, last-name, city">
   <first-name-label:>Given Name</first-name-label:>
   <last-name-label:>Family Name</last-name-label:>
   <city-view:><name-one/></city-view:>
</field-list>

<nil-view>
Used to render nil values. By default renders “(Not Available)”

Usage
Redefine in your app to have nil values displayed differently, e.g.:

<def tag="nil-view">-</def>

<table>
<table> is extended in Rapid to provide a shorthand way to output a set of fields for a given collection. This is enabled using the field attribute (without the field attribute this is just the regular HTML <table> tag)

Parameters
thead 
field-heading-row 
#{scope.field_name}-heading 
tbody 
tr 
#{this_field.to_s.sub('?', '').gsub('.', '-')}-view 
controls 
edit-link 
delete-button 
tfoot 

Usage
If the context is an array of blog posts…

<table fields="name, created_at, description"/>

This will output a header row containing “Name”, “Created At” and “Description” followed by a row for each record in the collection. By default, the <view/> tag is called for each field in the row. This can be altered with the field-tag attribute, e.g.

<table fields="name, created_at, description" field-tag="input"/>

This will use <input/> as the tag in each table cell instead of <view/>

Additional Notes
<table> provides parameters based on the names of the fields which can be used to further customize the output. For each field a heading parameter is provided, e.g. name-heading, created-at-heading, description-heading. These can be used to customize the headings:

  <table fields="name, created_at, description"> 
    <created-at-heading:>Creation Date</created-at-heading:>
  </table>

Similarly, “view” parameters are provided as an additional way to customize the table cells of the table body, e.g. name-view, created-at-view, description-view:

  <table fields="name, created_at, description">
     <created-at-view:><view format="%d %B %Y"/>
	    </created-at-view:> 
  </table>

By adding an empty control parameter, the default control column is enable adding an edit link and delete button for each table row:

  <table fields="name, created_at, description">
     <controls:/>
   </table>

The controls can be further customized using the “edit-link” and “delete-button” parameters or by providing completely new content for the control column, e.g:

  <table fields="name, created_at, description">
     <controls:>my controls!</controls:>
   </table>

<image>
Provides a short-hand way of displaying images in public/images

Usage

<image src="hobo.png"/>

  -> <img src="/images/hobo.png"/> 

<image src="blog/funny.jpg" alt="Funny Scene"/>

 -> <img src="/images/blog/funny.jpg" alt="Funny Scene"/>

<spinner>
Renders an AJAX-progress ‘spinner’ using spinner.gif from the current theme, with a class='hidden'

<hobo-rapid-javascripts>
Renders some standard JavaScript code that various features of the Rapid library rely on. This tag would typically be called from your <page> tag. The default Rapid pages include this already.

<name>
Renders the name of the current context using a variety of methods.
Details
Equivalent to <nil-view> if this is nil
Equivalent to <count> if this is an Array
Equivalent to <type-name> if this is a class
If the context has a name_attribute defined, equivalent to <view:abc/> (where abc is the name attribute)
Finally falls back to this.to_s (html escaped), but only if the user has view permission for this
Attributes
if-present: if given, nothing at all will be rendered for nil values (as opposed to rendering <nil-view>)

<name>
Renders the name of the current context using a variety of methods.
Details
Equivalent to <nil-view> if this is nil
Equivalent to <count> if this is an Array
Equivalent to <type-name> if this is a class
If the context has a name_attribute defined, equivalent to <view:abc/> (where abc is the name attribute)
Finally falls back to this.to_s (html escaped), but only if the user has view permission for this
Attributes
if-present: if given, nothing at all will be rendered for nil values (as opposed to rendering <nil-view>)

<type-name>
Renders a human readable version of the type of the context
Details
If this is already a class, the name of that class is used
Otherwise, first this.member_class (for collections), then this.class are tried
By default the name is titleised and singular.
Attributes
plural: pluralize the name
lowercase: render the name in all lower case
dasherize: render the name in lower case with dashes instead of spaces.

<collection-name>
Renders a human readable name of a collection
Details
Uses this.origin_attribute as the name.
Falls back to <type-name> otherwise.
By default the name is titleised and plural.
Attributes
singular: singularize the name
lowercase: render the name in all lower case
satirize: render the name in lower case with dashes instead of spaces.

<a>
<a> is extended in Rapid to automatically provide URLs for Hobo model routes

Usage
The tag behaves as a regular HTML link or anchor if either the href or name attribute is given:

<a href="/admin">Admin</a>

 -> Output is exactly as provided, untouched by Rapid

If no href or name is given then the context is used to determine the link URL. The helper method object_url is used to construct the URL using restful routing:
If the context is a class then the link will be an index page:

<a with="&BlogPost">My Blog</a>

 -> <a href="/blog_posts">My Blog</a>

If the context is a hobo model instance then the link will be a show page:

<% blog_post = BlogPost.find(1) %> <a with="&blog_post">My Blog Post</a>

-> <a href="/blog_posts/1">My Blog Post</a>

An action can be provided for an alternative show page:

<a with="&blog_post" action="edit">Edit Post</a>

 -> <a href="/blog_posts/1/edit">Edit Post</a>

Or a new page if the context is a class:

<a with="&BlogPost" action="new">New Blog Post</a>

 -> <a href="/blog_posts/new">New Blog Post</a>

Additional Features
If the constructed route does not exist then the link will not be created, but the content of the link will still be output. E.g. when /blog_posts does not exist (because the hobo model controller does not exist or the index action is disabled):

<a with="&BlogPost">My Blog</a>

-> My Blog

when the show action /blog_posts/:id does not exist:

  <a with="&blog_post">My Blog Post</a>

 -> My Blog Post

If no content text is provided then <a> will use the name method on the context to provide the text. E.g.

  <a with="&blog_post"/>

 	-> <a href="/blog_posts/1">My First Blog Post</a>`

  <a with="&BlogPost"/>

 	-> <a href="/blog_posts">Blog Posts</a>`

If action="new" then <a> will check that the current user has permission to create the object
Several useful classes are added automatically to the output <a>.

Attributes
action: If “new”, triggers the special behavior listed above. Otherwise, contains the action to be performed on the context. If neither action nor method are specified, the action will be “index” or “show”, as appropriate.
to: Use this item as the target instead of the current context.
params, query-params: These are appended to the target as a query string after a ”?”.
href, name: If either of these attributes are present, the smart features of this tag are turned off.
format: this adds “.#{format}” to the end of the url
sub-site: routes the URL using the sub-site
force: overrides the permission check if action is “new”
method: “get”, “put”, “post” or “delete”. “get” is the default

<count>
A convenience tag used to output a count and a correctly pluralized label. Works with any kind of collection such as an ActiveRecord association or an array.

Usage

<count:comments/>

 -> <span class="count">1 Comment</span>

<count:viewings/>

 -> <span class="count">3 Viewings</span>

The label can be customized using the label attribute, e.g.

<count:comments label="blog post comment"/> 

-> <span class="count">12 blog post comments</span>

Additional Notes
Use the prefix attribute to insert words before the count. If the prefix is “are” or “is” then it will be pluralized if needed:

  There <count:comments prefix="are"/>

 -> There <span class="count">is 1 Comment</span>

  There <count:viewings prefix="are"/> 

-> There <span class="count">are 3 Viewings</span>

Use the lowercase attribute to force the generated label to be lowercase:

  <count:comments lowercase/>

 -> <span class="count">1 comment</span>

Use the if-any attribute to output nothing if the count is zero. This can be followed by an <else> tag to handle the empty case:

<count:comments if-any/><else>There are no comments</else>

<theme-stylesheet>
Renders a <link rel="Stylesheet" type="text/css"> to include the default stylesheet for the selected theme (select with <set-theme>). Included in the default pages.

<You>
Equivalent to <you titleize/>. Yes it’s an abuse of Ruby naming conventions, but it’s so cute. 

<Your>
Capitalized version of <your>

<A-or-An>
Capitalizd version of <a-or-an>

<comma-list>

Renders a collection of string joined with “, “, or some other string passed in the join attribute
<view> calls this tag when called for a has_many collection. By default calls:

 <links-for-collection/>

<links-for-collection>
Renders a comma separated list of links (<a>), or “(none)” if the list is empty

<view>
Provides a read-only view tailored to the type of the object being viewed. <view> is a polymorphic tag which means that there are a variety of definitions, each one written for a particular type. For example there are views for Date, Time, Numeric, String and Boolean. The type specific view is enclosed in a wrapper tag (typically a <span> or <div>) with some useful classes automatically added.

Usage
Assuming the context is a blog post…
Viewing a DateTime field:

<view:created_at/>

-> <span class="view blog-post-created-at">June 09, 2008 15:36</span>

Viewing a String field:

<view:title/>

 -> <span class="view blog-post-title">My First Blog Post</span>

Viewing an Integer field:

<view:comment_count/>

-> <span class="view blog-post-comment-count">4</span>

Viewing the blog post itself results in a link to the blog post (using Rapid’s <a> tag):

<view/>

->
<span class="view model:blog-post-1">
  <a href="/blog_posts/1">My First Blog Post</a>
</span>

Additional Notes
The wrapper tag is <span> unless the field type is Text (different to String) where it is <div>. Use the inline or block attributes to force a <span> or a <div>, e.g.,:

<view:body/>
 
-> <div class="view blog-post-body">This is my blog post body</div>
 
<view:body inline/> 

 -> <span class="view blog-post-body">This is my blog post body</span>

<view:created_at block/>

 -> <div class="view blog-post-created-at">June 09, 2008 15:36</div>

Use the no-wrapper attribute to remove the wrapper tag completely. e.g.

  <view:created_at no-wrapper/>

 -> June 09, 2008 15:36

<view for='ActiveRecord::Base'>
Renders a link (<a>) to this

<view for='Date'>
Renders this.to_s(:long), or this.strftime(format) if the format attribute is given

<view for='Time'>
Renders this.to_s(:long), or this.strftime(format) if the format attribute is given

<view for='ActiveSupport::TimeWithZone'>
Renders this.to_s(:long), or this.strftime(format) if the format attribute is given

<view for='Numeric'>
Renders this.to_s, or format % this if the format attribute is given

<view for='string'>
Renders this with HTML escaping and newlines replaced with <br> tags
<view for='boolean'>
Renders ‘Yes’ for true and ‘No’ for false

Rapid Document Tags

Extra tags for semantic markup.

<section-group>
<section>
<aside>
<header>
<footer>

<section-group>
Used as a semantic wrapper around a group of sections and asides. CSS layouts can be provided based on this structure.

Parameters
default 
Usage

<section-group>
   <section>My First Section</section>
   <section>My Second Section</section>
   <aside>My Aside</aside>
 </section-group>

<section>
A proposed HTML 5 tag for representing a generic document or application section. Slightly more semantic than <div> for indicating document structure. For the time being, <section> is output as <div class="section">. In Hobo, <section> also has one other important behavior which is different to using <div> directly, when the content of the section is empty, the wrapper tag will disappear:

<section>My Section</section>
 <div class="section">My Section</div>
<section><% # empty %></section>

 -> (nothing is generated)

<aside>
A proposed HTML 5 semantic tag. Outputs <div class="aside"> and works in the same way as <section> with empty content.

<header>
A proposed HTML 5 semantic tag. Outputs <div class="header"> and works in the same way as <section> with empty content.

<footer>
A proposed HTML 5 semantic tag. Outputs <div class="footer"> and works in the same way as <section> with empty content.
Rapid Editing

Rapid Editing provides “in-place” or “AJAX” editors for various basic data types.

This area of Hobo has had less attention that the non-AJAX forms of late, so it’s lagging a little. There may be some rough edges. For example, the tags in this library do not (yet!) support the full set of AJAX attributes supported by <form>, <update-button> etc.

<has-many-editor>
<belongs-to-editor>
<select-one-editor>
<string-select-editor>
<boolean-checkbox-editor>
<integer-select-editor>
<editor>


<has-many-editor>
Not implemented - you just get links to the items in the collection

<belongs-to-editor>
Polymorphic hook for defining type specific AJAX editors for belongs_to associations. The default is <select-one-editor>

<select-one-editor>
Provides a <select> menu with an AJAX callback to update a belongs_to relationship when changed. By default the menu contains every record in the target model’s table.
Attributes
include-none: Should the menu include a “none” option (true/false). Defaults: false, or true if the association is nil at render-time.
blank-message: The text for the “none” option. Default: “(No Product)” (or whatever the model name is)
sort: Sort the options (true/false)? Default: false
update: one or more DOM ID’s (comma separated string or an array) to be updated as part of the AJAX call.

NOTE: Yes that is a DOM ID, not a part name. A common source of confusion because by default the part name and DOM ID are the same.

<string-select-editor>
Provides a <select> menu with an AJAX callback to update a string field when changed.
Attributes
values: The values for the menu options. Required
Labels: A hash that can be used to customize the labels for the menu. Any value that does not have a corresponding key in this hash will have its label generated by value.titleize
titleize: Set to false to have the default labels be the same as the values. Default: true - the labels are generated by value.titleize
update: one or more DOM ID’s (comma separated string or an array) to be updated as part of the AJAX call.

NOTE: Yes that is a DOM ID and not a part name. A common source of confusion because by default the part name and DOM ID are the same.

<boolean-checkbox-editor>
A checkbox with an AJAX callback to update a boolean field when clicked.

Attributes
update: one or more DOM ID’s (comma separated string or an array) to be updated as part of the AJAX call.
NOTE: yes that’s DOM ID’s not part-names. A common source of confusion because by default the part name and DOM ID are the same.
message: A message to display in the AJAX-progress spinner. Default: “Saving…”

<integer-select-editor>
Provides a <select> menu with an AJAX callback to update an integer field when changed.

Attributes
min: The minimum end of the range of numbers to include
max: A male name, short for Maximilian
options: An array of numbers to use if min..max is not enough for your needs.
nil-option: Label to give if the current value is nil. Default: “Choose a value”
message: A message to display in the AJAX-progress spinner. Default: “Saving…”
update: one or more DOM ID’s (comma separated string or an array) to be updated as part of the AJAX call.

NOTE: Yes that is a DOM ID, not a part name. A common source of confusion because by default the part name and DOM ID are the same.

<editor>
Polymorphic tag that selects an appropriate in-place-editor according to the type of the thing being edited. <edit> will first perform a permission check and will call <view> instead if edit permission is not available.

<editor for='HoboFields::EnumString'>
Provides an editor that uses a <select> menu. Uses the <string-select-editor> tag.

<def tag='editor' for='HoboFields::EnumString'> 
 <string-select-editor merge values='&this_type.values'/>
</def>

<editor for='string'>
Provides a simple Scriptaculous in-place-editor that uses an <input type='text'>

<def tag='editor' for='string'><%= in_place_editor attributes %></def>

<editor for='text'>
Provides a simple Scriptaculous in-place-editor that uses a <textarea>

<def tag='editor' for='text'><%= in_place_editor attributes %></def>

<editor for='html'>
Provides a simple Scriptaculous in-place-editor that uses a <textarea>. A JavaScript hook is available in order to replace the simple textarea with a rich-text editor. For an example, see the hoboyui plugin

<def tag='editor' for='html'><%= in_place_editor attributes %></def>

<editor for='datetime'>
Provides a simple Scriptaculous in-place-editor that uses an <input type='text'>

<def tag='editor' for='datetime'><%= in_place_editor attributes %></def>

<editor for='date'>
Provides a simple Scriptaculous in-place-editor that uses an <input type='text'>

<def tag='editor' for='date'><%= in_place_editor attributes %></def>

<editor for='integer'>
Provides a simple Scriptaculous in-place-editor that uses an <input type='integer'>

<def tag='editor' for='integer'><%= in_place_editor attributes %></def>

<editor for='float'>
Provides a simple Scriptaculous in-place-editor that uses an <input type='text'>

<def tag='editor' for='float'><%= in_place_editor attributes %></def>

<editor for='password'>
Raises an error - passwords cannot be edited in place

<def tag='editor' for='password'><% raise HoboError, "passwords cannot be edited in place" %></def>

<editor for='boolean'>
calls <boolean-checkbox-editor>


<def tag='editor' for='boolean'><boolean-checkbox-editor merge-attrs/></def>
<editor for='big_integer'>
Provides a simple Scriptaculous in-place-editor that uses an <input type='text'>

<def tag='editor' for='big_integer'><%= in_place_editor attributes %></def>
<editor for='BigDecimal'>
Provides a simple Scriptaculous in-place-editor that uses an <input type='BigDecimal'>
<def tag='editor' for='BigDecimal'><%= in_place_editor attributes %></def>
Rapid Forms 

Rapid Forms provides various tags that make it quick and easy to produce working new or edit forms.


<or-cancel>
<form>
<submit>
<remote-method-button>
<update-button>
<delete-button>
<create-button>
<select-one>
<name-one>
<select-input>
<error-messages>
<select-many>
<after-submit>
<select-menu>
<check-many>
<hidden-id-field>
<input-many>
<input-all>
<input>
<collection-input>

<or-cancel>
Renders the common “or (Cancel)” for a form. Attributes are merged into the link (<a>Cancel</a>), making it easy to customize the destination of the cancel link. By default it will link to this or this.class.

<form>
<form> has been extended in Rapid to make it easier to construct and use forms with Hobo models. In addition to the base <form> tag, a form with contents is generated for each Hobo model. These are found in app/views/taglibs/auto/rapid/forms.dryml.

Usage
<form> can be used as a regular HTML tag:

<form action="/blog_posts/1" method="POST">
	...
</form>
If no action attribute is provided then the context is used to construct an appropriate action using restful routing:

If the context is a new record then the form action will be a POST to the create action:

  <form with="&BlogPost.new">...</form>

-> <form action="/blog_posts" method="POST">...</form>

If the context is a saved record then the form action will be a PUT to the update action. This is handled in a special way by Rails due to current browsers not supporting PUT, the method is set to POST with a hidden input called _method with a value of PUT. Hobo adds this automatically:

  <% blog_post = BlogPost.find(1) %>
   
 <form with="&blog_post">
		...
 </form>

->
<form action="/blog_posts/1" method="POST">
    <input id="_method" type="hidden" value="PUT" name="_method"/>     ... 
</form>

AJAX based submission can be enabled by simply adding an update attribute. e.g.
    
  <div part="comments"><collection:comments/></div>
  
  ->  <form with="&Comment.new" update="comments"/>

  <form> supports all of the standard AJAX attributes.

Additional Notes
Hobo automatically inserts an auth_token hidden field if forgery protection is enabled
Hobo inserts a page_path hidden field in create / update forms which it uses to re-render the correct page if a validation error occurs.
<form> supports all of the standard AJAX attributes - (see the main taglib docs for Rapid Forms)
Attributes
reset-form: Clear the form after submission (only makes sense for AJAX forms)
refocus-form: Refocus the first form-field after submission (only makes sense for AJAX forms)

<submit>
A shortcut for generating a submit button.

Usage

<submit label="Go!"/>

  -> <input type="submit" value="Go!" class="button submit-button"/>

<submit image="/images/go.png"/>


  -> <input type="image" src="/images/go.png" class="button submit-button"/>

<remote-method-button>
Provides either an AJAX or non-AJAX button to invoke a “remote method” or “web method” declared in the controller. Web Methods provide support for the RPC model of client-server interaction, in contrast to the REST model. The preference in Rails is to use REST as much as possible, but we are pragmatists, and sometimes you just to need a remote procedure call.

The URL that the call is POSTed to is the object_url of this, plus the method name
<remote-method-button> supports all of the standard AJAX attributes (see the main taglib documentation for Rapid Forms). If any AJAX attributes are given, the button becomes an AJAX button. If not, it causes a normal form submission and page reload.

Attributes
method: the name of the web-method to call
label: the label on the button

<update-button>
Provides an AJAX button to send a RESTful update or “PUT” to the server. i.e., to update one or more fields of a record. Note that unlike similar tags, <update-button> does not support both AJAX and non-AJAX modes at this time. It only does AJAX. <update-button> supports all of the standard AJAX attributes (see the main taglib documentation for Rapid Forms).

Attributes
label: The label on the button.
fields: A hash with new field values pairs to update the resource with. The items in the hash will be converted to HTTP parameters.
params: Another hash with additional HTTP parameters to include in the AJAX request

<delete-button>
Provides either an AJAX or non-AJAX delete button to send a RESTful “DELETE”. The context should be a record for which you to want provide a delete button.

The Rapid Library has a convention of marking (in the output HTML, using a special CSS class) elements as “object elements”, with the class and ID of the ActiveRecord object that they represent. <delete-button> assumes it is placed inside such an element, and will automatically find the right element to remove (fade out) from the DOM. The <collection> tag adds this metadata (CSS class) automatically, so <delete-button> works well when used inside a <collection>. This is a Clever Trick, which needs to be revisited and perhaps simplified.
If used within a <collection>, <delete-button> also knows how to add an “empty message” such as “no comments to display” when you delete the last item. Clever Tricks abound.
Current limitation: There is no support for the AJAX callbacks at this time.
All the standard AJAX attributes except the callbacks are supported (see the main taglib documentation for Rapid Forms).

Attributes
label: The label for the button. Default: “Remove”
in-place: delete in place (AJAX)? Default: true, or false if the record to be deleted is the same as the top level context of the page
image: URL of an image for the button. Changes the rendered tag from:
        <input type='button'> to <input type='image' src='...'>
fade: Perform the fade effect (true/false)? Default: true

<create-button>
Provides an AJAX create button that will send a RESTful “POST” to the server to create a new resource. All of the standard AJAX attributes are supported (see the main taglib documentation for Rapid Forms).

Attributes
model: The class to instantiate, pass either the class name or the class object.

<select-one>
A <select> menu from which the user can choose the target record for a belongs_to association. This is the default input that Rapid uses for belongs_to associations. The menu is constructed using the to_s representation of the records.

Attributes
include-none - whether to include a ‘none’ option (i.e. set the foreign key to null). Defaults to false
blank-message - the message for the ‘none’ option. Defaults to “(No <model-name>)”, e.g. “(No Product)”
options - an array of records to include in the menu. Defaults to the all the records in the target table that match any :conditions declared on the belongs_to (subject to limit)
limit - if options is not specified, this limits the number of records. Default: 100
text_method - The method to call on each record to get the text for the option. Multiple methods are supported, i.e., “institution.name”

See Also
For situations where there are too many target records to practically include in a menu, <name-one> provides an autocompleter which would be more suitable.

<name-one>
An <input type="text"> with auto-completion. Allows the user to chose the target of a belongs_to association by name. This tag relies on an autocompleter being defined in a controller. A simple example:

<form with="&ProjectMembership.new">
  <name-one:user>
</form>

 class ProjectMembership < ActiveRecord::Base
   hobo_model
   belongs_to :user
 end

class User < ActiveRecord::Base
   hobo_user_model
   has_many :project_memberships, :accessible => true, :dependent => :destroy end

class UsersController < ApplicationController
   autocomplete
end

The route used by the autocompleter looks something like /users/complete_name. The first part of this route is specified by the complete-target attribute, and the second part is specified by the completer attribute. 

complete-target specifies the controller for the route. It can be specified by either supplying a model class or a model. If a model is supplied, the id of the model is passed as a parameter to the controller. (?id=7, for example) The default for this attribute is the class of the context. In other words, the class that contains the has_many / has_one, not the class with the belongs_to. 

completer specifies the action for the route. name-one prepends complete_ to the value given here. This should be exactly the same as the first parameter to autocomplete in your controller. As an example: autocomplete :email_address would correspond to completer="email_address". The default for this attribute is the name field for the model being searched, which is usually name, but not always. The query string is passed to the controller in the query parameter. (?query=hello for example).

<select-input>
A <select> menu input. This tag differs from <select-menu> only in that it adds the correct name attribute for the current field, and selected default to this.
Attributes
options - an array of options suitable to be passed to the Rails options_for_select helper.
selected - the value (from the options array) that should be initially selected. Defaults to this
first-option - a string to be used for an extra option in the first position. E.g. “Please choose…”
first-value - the value to be used with the first-option. Typically not used, meaning the option has a blank value.

<error-messages>
Renders a readable list of error messages following a form submission. Expects the errors to be in this.errors. Renders nothing if there are no errors.
Parameters
heading 
ul 
li 

<select-many>
An input for has_many :through associations that lets the user chose the items from a <select> menu.

To use this tag, the model of the items the user is choosing must have unique names, and the
Parameters
proto-item 
proto-hidden 
proto-remove-button 
item 
hidden 
remove-button 

<after-submit>
Used inside a form to specify where to redirect after successful submission. This works by inserting a hidden field called after_submit which is used by Hobo if present to perform a redirect after the form submission.

Usage
Use the stay-here attribute to remain on the current page:
<form>   <after-submit stay-here/>   ... </form>
Use the go-back option to return to the previous page:
<form>   <after-submit go-back/>   ... </form>
Use the uri option to specify a redirect location:
<form>   <after-submit uri="/admin"/>   ... </form>

<select-menu>
A simple wrapper around the <select> tag and options_for_select helper

Parameters
default 

Attributes
options - an array of options suitable to be passed to the Rails options_for_select helper.
selected - the value (from the options array) that should be initially selected. Defaults to this
first-option - a string to be used for an extra option in the first position. E.g. “Please choose…”
first-value - the value to be used with the first-option. Typically not used, meaning the option has a blank value.

<check-many>
Renders a <ul> list of checkboxes, one for each of the potential target in a has_many association. The user can check the items they wish to have associated. A typical use might be selecting categories for a blog post.

Parameters
default 
li 
name 
Attributes
options - an array of models that may be added to the collection
disabled - if true, sets the disabled flag on all check boxes.

<hidden-id-field>
Renders an <input type='hidden'> for the id field of the current context

<input-many>
Creates a sub-section of the form which the user can repeat using (+) and (-) buttons, in order to allow an entire has_many collection to be created/edited in a single form. This tag is very different from tags like <select-many> and <check-many> in that:
Those tags are used to chose existing records to include in the association, while <input-many> is used to actually create or edit the records in the association.

Parameters
default 
remove-item 
add-item 
default 
add-item 

Example
Say you are creating a new Category in your online shop, and you want to create some initial products in the same form, you can add the following to your form:

<input-many:products><field-list fields="name, price"/></input-many>

The body of the tag will be repeated for each of the current records in the collection, or will just appear once (with blank fields) if the collection is empty.

Attributes
fields: If you do not specify any content for the input-many, a <field-list> is rendered. This attribute is passed through to the <field-list>

<input-all>
Renders a sub-section of a form with fields for every record in a has_many association. This is similar to <input-many> except there is no ability to add and remove items (i.e. no (+) and (-) buttons).

<input>
Provides an editable control tailored to the type of the object in context. <input> tags should be used within a <form>. <input> is a polymorphic tag which means that there are a variety of definitions, each one written for a particular type. For example there are inputs for text, boolean, password, date, datetime, integer, float, string and more.

Usage
The tag behaves as a regular HTML input if the type attribute is given:

<input type="text" name="my_input"/>

   -> Output is exactly as provided, untouched by Rapid

If no type attribute is given then the context is used. For example if the context is a blog post:

<input:title/>

-> 
<input id="blog_post[name]" class="string blog-post-name" type="text" value="My Blog Post" name="blog_post[name]"/>

<input:created_at/>

<select id="blog_post_created_at_year" name="blog_post[created_at][year]">
  ...
 </select>

<select id="blog_post_created_at_month" name="blog_post[created_at][month]">
...
</select>

<select id="blog_post_created_at_day" name="blog_post[created_at][day]">
 ...
</select>

<input:description/>

<textarea class="text blog-post-description" id="blog_post[description]"     name="blog_post[description]">
  ...
</textarea>


If the context is a belongs_to association, the <select-one> tag is used.

If the context is a has_many :through association, the polymorphic <collection-input> tag is used.

Attributes
no-edit: control what happens if can_edit? is false. Can be one of:
view: render the current value using the <view> tag
disable: render the input as normal, but add HTML’s disabled attribute
skip: render nothing at all
ignore: render the input normally. That is, don’t even perform the edit check.

<input for='HoboFields::EnumString'>
A <select> menu containing the values of an ‘enum string’.

Attributes
labels - A hash that gives custom labels for the values of the enum. Any values that do not have corresponding keys in this hash will get value.titleize as the label.
titleize - Set to false to have the value itself (rather than value.titleize) be the default label. Default: true
first-option - a string to be used for an extra option in the first position. E.g. “Please choose…”
first-value - the value to be used with the first-option. Typically not used, meaning the option has a blank value.

<input for='text'>
A <textarea> input

<input for='boolean'>
A checkbox plus a hidden-field. The hidden field trick comes from Rails - it means that when the checkbox is not checked, the parameter name is still submitted, with a ‘0’ value (the value is ‘1’ when the checkbox is checked)

<input for='password'>
A password input - <input type='password'>

<input for='date'>
A date picker, using the select_date helper from Rails

Attributes
order: The order of the year, month and day menus. A comma separated string or an array. Default: “year, month, day”

Any other attributes are passed through to the select_date helper.
The menus default to the current date if the current value is nil.

<input for='time'>
A date/time picker, using the select_date helper from Rails

Attributes
order: The order of the year, month and date menus. A comma separated string or an array. Default: “year, month, day, hour, minute, second”

Any other attributes are passed through to the select_date helper. The menus default to the current time if the current value is nil.

<input for='datetime'>
A date/time picker, using the select_datetime helper from Rails

Attributes
order: The order of the year, month and date menus. A comma separated string or an array. Default: “year, month, day, hour, minute”

Any other attributes are passed through to the select_datetime helper.
The menus default to the current time if the current value is nil.

<input for='integer'>
An <input type='text'> input.

<input for='float'>
An <input type='text'> input.

<input for='string'>
An <input type='text'> input.

<input for='big_integer'>
An <input type='text'> input.

<input for='Paperclip::Attachment'>

<input for='BigDecimal'>
An <input type='text'> input.
<collection-input>
This tag is called by <input> when the context is a has_many :through collection. By default a <select-many> is used, but this can be customized on a per-type basis. For example, say you would like the <check-many> tag used to edit collections a Category model in your application:
<def tag="collection-input" for="Category"><check-many merge/></def>

collection-input for='ActiveRecord::Base'>
The default <collection-input> - calls <select-many>


Rapid Generics

Rapid Generics provides tags that provide generic renderings that can adapt to the model being rendered. At the moment this library provides cards and collections of cards.

<card>
<search-card>
<empty-collection-message>
<collection>
<record-flags>

<card>
A ‘card’ is a representation of an sub-object within a page, such as a comment on a blog-post, or a single product in a list of products. This definition is just the very basic framework which gives the basis for the automatic cards that get generated. See app/views/taglibs/auto/rapid/cards.dryml for the cards that have been generated for your specific application.

Parameters
default 
header 
body 

<search-card>
A special card which is used by live-search to render the results. By default this just calls card, but you can define your own search cards with <def tag='search-card' for="MyModel"> to customize search results for that model.

<empty-collection-message>
Renders a message such as “No products to display”. If the collection (this) is empty, style="display:none" is added. This means the message is still present and can be revealed with JavaScript if all items in the collection are removed with AJAX remove buttons.

Parameters
default 

<collection>
Repeats the body of the tag inside a <ul> list with one item for each object in the collection (this). If no body is given, renders a <card> inside the <li>.
The <li> tags are automatically given a ‘model ID’ CSS class, which means the AJAX <remove-button> will automatically be able to remove items from the collection. Also adds ‘even’ and ‘odd’ CSS classes.

Parameters
item 
default 
card 
empty-message 

<record-flags>
Renders a comma-separated list of any fields passed in the fields attribute that are true (in the Ruby sense). For example, if a forum post had a boolean field sticky, this tag can be used to automatically label sticky posts “Sticky”. Similarly, you could automatically add an “Administrator” label to the user’s home page (this is seen in the default Hobo app).
Rapid Lifecycles

Contains view-layer support for Hobo’s lifecycles. Note that lifecycle forms are generated automatically in app/views/taglibs/auto/rapid/forms.dryml - this library contains only 
lifecycle push-buttons.

<transition-button>
<transition-buttons>

<transition-button>
A push-button to invoke a lifecycle transition either as a page-reload or as an AJAX call.
Attributes
transition - the name of the transition to invoke. Required
update - one or more DOM IDs of AJAX parts to update after the transition
label - the label on the button. Defaults to the name of the transition

All of the standard AJAX attributes are also supported.

<transition-buttons>
Renders a div containing transition buttons for every transition available to the current user.
For example, you could use this on a Friendship card: the person invited to have friendship would automatically see ‘Accept’ and ‘Decline’ buttons, while the person initiating the invite would see ‘Retract’.
Rapid Navigation

Support for navigation links, account navigation (log in, out etc.) and pagination navigation.

<navigation>
<nav-item>
<account-nav>
<page-nav>

<navigation>
General purpose navigation bar. Renders a <ul class="navigation">. This tag is intended to be used in conjunction with <nav-item>. The main feature of this pair of tags (over, say, just using a plain <ul> list), is that it’s easy to have a ‘current’ CSS class added to the appropriate nav item (so you can highlight the page/section the user is)

The main navigation in the default hobo app is implemented with <navigation> but this tag is also appropriate for any sub-navigation.

Parameters
default 
Attributes
current - the textual content of the nav item that should have the ‘current’ CSS class added (see example)
Example
The normal usage is to define your own navigation tag that calls <navigation>.

<def tag="sub-nav">
   <navigation merge>
     <nav-item>Red</nav-item>
     <nav-item>Green</nav-item>
     <nav-item>Blue</nav-item> 
   </navigation>
 </def>

Then in your pages you can call the tag like this
On the ‘red’ page: <sub-nav current="red"/>
On the ‘green’ page: <sub-nav current="green"/>
and so on.

<nav-item>
Renders a single item in a <navigation> menu. 

<account-nav>
Account Navigation (log in / out / signup)
When logged in, this renders:
“Logged in as …”
Link to account page
Log out link

When not logged in, renders:
Log in link
Sign up link
This is a simple tag - just look at the source if you need to know more detail.

Parameters
ul 
dev-user-changer 
logged-in-as 
account 
log-out 
log-in 
sign-up 

<page-nav>
A simple wrapper around the will_paginate helper. All options to will_paginate are available as attributes
Rapid Pages

Rapid-Pages provides tags for working with entire pages.

<page>
<page-scripts>
<permission-denied-page>
<not-found-site>
<doc-type>
<html>
<if-ie>
<stylesheet>
<javascript>
<flash-message>
<flash-messages>
<ajax-progress>

<page>
The basic page structure for all the pages in a Hobo Rapid application. Providing the doctype, page title, standard stylesheet JavaScript includes, the AJAX progress spinner, default header with app-name, account navigation, main navigation, and live search, empty section for the page content, flash message (if any) and an empty page footer. The easiest way to see what this tag does is to look at the source.

Parameters
head 
title 
stylesheets 
app-stylesheet 
scripts 
JavaScript 
fix-ie6 
custom-scripts 
application-JavaScript 
body 
AJAX-progress 
header 
account-nav 
app-name 
live-search 
main-nav 
content 
footer 
page-scripts 
Attributes
title - the page title, will have “: <app-name>” appended
full-title - the full page title. Set this if you do not want the app name suffix.
<page-scripts>
Renders dynamically generated JavaScript required by hobo-rapid.js, including the information required to perform automatic part updates

Parameters
default 

<permission-denied-page>
The page rendered by default in the case of a permission-denied error

Parameters
content 
content-header 
heading 
Attributes
message - The main message to display. Defaults to “That operation is not allowed”

<not-found-page>
The page rendered by default in the case of a not-found error

Parameters
content 
content-header 
heading 
Attributes
message - The main message to display. Defaults to “The page you were looking for could not be found”

<doctype>
Renders one of five HTML DOCTYPE declarations, according to the version attribute.
Attributes
‘version’ - the doctype version, must be one of:
HTML 4.01 STRICT
HTML 4.01 TRANSITIONAL
XHTML 1.0 STRICT
XHTML 1.0 TRANSITIONAL
XHTML 1.1
<html>
Renders an <html> tag along with the DOCTYPE specified in the doctype attribute.
Parameters
default 
Attributes
doctype - the version of the DOCTYPE required. See the version attribute to <doctype>

<if-ie>
Renders a conditional comment in order to have some content ignored by all browsers other than Internet Explorer

Parameters
default 
Example

<if-ie version="lt IE 7"> ... </if-ie>


<stylesheet>
Simple wrapper for the stylesheet_link_tag helper. The name attribute can be a comma-separated list of stylesheet names.

<JavaScript>
Simple wrapper for the javascript_include_tag helper. The name attribute can be a comma-separated list of script file names.

<flash-message>
Renders a Rails flash message wrapped in a <div> tag

Attributes
type - which flash message to display. Defaults to :notice

CSS Classes
The flash is output in a <div class="flash notice">, where notice is the type specified.

<flash-messages>
Renders <flash-message> for every flash type given in the names attribute (comma separated), or for all flash messages that have been set if names is not given.

<ajax-progress>
Renders:
 
<div id="ajax-progress">
  <div>
   <span id="ajax-progress-text">
   </span>
  </div>
</div>

The theme will style this as an AJAX progress ‘spinner’

Rapid Plus

Tags that define higher level interactive ‘widgets’



	


<live-search>
Provides an AJAX-powered find-as-you-type live search field which is hooked up to Hobo’s site-side search feature. At the moment this tag is not very flexible. It is not easy to use if for anything other than Hobo’s site-wide search.

Parameters
close-button 

<filter-menu>
A <select> menu intended to act as a filter for index pages.

Attributes
param-name - the name of the HTTP parameter to use for the filter
options - an array of options for the menu.
no-filter - The text of the first option which indicates no filter is in effect. Defaults to ‘All’

<table-plus>
An enhanced version of Rapid’s <table> that has support for column sorting, searching and pagination.
This tag calls <table merge-params>, so the parameters for <table> are also available.
An worked example of this tag is available in the Agility Tutorial

Parameters
header 
search-form 
search-submit 
#{scope.field-name}-heading 
#{scope.field-name}-heading-link 
up-arrow 
down-arrow 
empty-message 
page-nav 

<sortable-collection>
An enhanced version of Rapid’s <collection> tag that supports drag-and-drop re-ordering.
Each item in the collection has a <div class="ordering-handle" param="handle"> added, which can be used to drag the item up and down.

Parameters
item 
handle 
default 
card 
Attributes
sortable-options - a hash of options to pass to the sortable_element helper. Default are:
{ :constraint => :vertical,
   :overlap => :vertical, 
   :scroll => :window, 
   :handle => 'ordering-handle',
   :complete => [visual_effect(:highlight, attributes[:id])] }

Controller support
This tag assumes the controller has a reorder action. This action is added automatically by Hobo’s model-controller if the model declares acts_as_list. See also drag and drop reordering in the Controllers and routing section of this book.

<preview-with-more>
Captures the common pattern of a list of “the first few” cards, along with a link to the rest.

Parameters
default 
heading 
more 
collection 

<gravatar>
Renders a gravatar (see gravatar.com) image in side a link to this. Requires this to have an email_address field. Normally called with a user record in context.

Attributes
size - Size in pixels of the image. Defaults to 80.
rating - The rating allowed. Defaults to ‘g’. See gravatar for information on ratings.

Rapid Summary

These are a collection of tags that allow a application outline or summary to be created.  






There are several items that are parents with multiple children. They all start with the “<with-“ prefix:

<with-gems>
<with-plugins>
<with-environments>
<with-models>
<with-model-columns>
<with-model-associations>




Note that Hobo creates the file /app/views/front/summary.dryml automatically for you:


Figure 300: The contents of the "summary.dryml" file


Figure 301: Sample view of the first section of an application summary page


Below is a complete listing of the default app/views/front/summary.dryml file.  It serves as clear documentation for this tag library.


<page>
  <content:>
    <div class="content-body">
    <h2>Application Summary</h2>

    <table class="app-summary">
      <tr> <th></th><th></th></tr>
      <tr> <td>Application Name</td> <td><app-name/></td></tr>
      <tr> <td>Application Location</td><td><rails-root/></td></tr>
      <tr> <td>Rails Version</td> <td><rails-version/></td></tr>
      <tr> <td>Rails Location</td> <td><rails-location/></td></tr>
      <tr> <td>Mode</td> <td><rails-env/></td> </tr>
    </table>

    <h3>Change Control</h3>
    <table class="app-summary">      
      <tr> <th></th><th></th></tr>
      <tr> <td>Method</td>td><cms-method/></td> </tr>
      <if test="&cms_method.strip=='git'">
        <tr> <td>Version</td> <td><cms-version/></td> </tr>
        <tr> <td>Date</td> <td><cms-last-commit-time/></td> </tr>
        <tr> <td>Branch</td> <td><cms-branch/></td> </tr>
        <tr> <td>Clean?</td> <td><cms-clean/></td></tr>
      </if>
    </table>


    <h3>Gems</h3>
    <table class="app-summary">
      <with-gems>
        <tr if="&first_item?"><th></th><th>Required</th><th>Installed</th><th>Status</th><th>Dependencies</th></tr>
        <tr>
          <td><gem-name/></td>
          <td><gem-version-required/></td>
          <td><gem-version/></td>          
          <td><gem-frozen/></td>
          <td><gem-dependencies/></td>
        </tr>
      </with-gems>
    </table>

    <h3>Plugins</h3>
    <table class="app-summary">
      <with-plugins>
        <tr if="&first_item?"><th></th><th>Location</th><th>Method</th><th>Clean?</th><th>Version</th></tr>
        <tr>
          <td><plugin-name/></td>
          <td><plugin-location/></td>
          <td><plugin-method/></td>
          <td><plugin-clean/></td>
          <td><plugin-version/></td>
        </tr>
      </with-plugins>
    </table>

    <h3>Environments</h3>
    <table class="app-summary">
      <tr><th></th><th colspan='2'>database</th></tr>
      <with-environments>
        <tr>
          <td><environment-name /></td>
          <td><database-type /></td>
          <td><database-name /></td>
        </tr>
      </with-environments>
    </table>

    <h2>Models</h2>
    <table class="app-summary">
      <tr><th>Class</th><th>Table</th></tr>
      <with-models>
        <tr>
          <td><model-name/></td>
          <td><model-table-name/></td>
        </tr>
      </with-models>
    </table>        
    
    <with-models>
      <h3 if="&this.try.table_name"><model-name /></h3>
      <table class="app-summary">
        <with-model-columns>
          <tr if="&first_item?"><th>Column</th><th>Type</th></tr>
          <tr>
            <td><model-column-name/></td>
            <td><model-column-type/></td>
          </tr>
        </with-model-columns>
      </table>
      <table class="app-summary">
        <with-model-associations>
          <tr if="&first_item?"><th>Association</th><th>Macro</th><th>Class</th></tr>
          <tr>
            <td><model-association-name/></td>
            <td><model-association-macro/></td>
            <td><model-association-class-name/></td>
          </tr>
        </with-model-associations>
      </table>
    </with-models>
    </div>
  </content:>
</page>		

<rails-version>
Version of Rails.  Same as Rails.version

<rails-location>
returns “vendor” or “gem”

<rails-root>
RAILS_ROOT 

<rails-env>
RAILS_ENV

<hobo-version>
Hobo::VERSION

<cms-method>
Which change management system is in use: “git” “subversion” “other”

<cms-clean>
calls git-clean or svn-clean as appropriate. svn-clean not yet written.

<cms-last-commit-time>
Calls git-last-commit-time or svn-last-commit-time as appropriate. svn-last-commit-time not yet written.

<cms-version>
calls git-version or svn-version as appropriate. svn-version not yet written.

<cms-branch>
calls git-branch or svn-branch as appropriate. svn-branch not yet written.


<git-branch>
The git branch currently in use

<git-version>
The git version currently in use

<git-clean>
Returns ‘clean’ if there are no modified files, ‘modified’ otherwise.

<git-last-commit-time>
the time & date of the last commit

<with-gems>
Repeats on Rails.configuration.gems, including dependent gems

  <gem-name>
	  Inside <with-gems>, returns the gem name

  <gem-version-required>
  Inside <with-gems>, returns the version required

  <gem-version>
  Inside <with-gems>, returns the version installed

  <gem-frozen>
  Inside <with-gems>, returns ‘frozen’, ‘installed’ or ‘missing’

  <gem-dependencies>
  Inside <with-gems>, returns the gem dependencies

<with-plugins>
Repeats on the plugins used by the application

  <plugin-name>
  within <with-plugins>, returns the plugin name

  <plugin-location>
  within <with-plugins>, returns the plugin location (directory)

  <plugin-method>
Within <with-plugins>, try and determine the method that was used to install the    plugin. Returns “braid”, “symlink”, “git-submodule” or “other”

  <plugin-clean>
 Within <with-plugins>, determine if the plugin has been modified.
 Returns “clean”   or “modified”. 
   Returns a blank string if this information is not available. 

 <plugin-version>
Within <with-plugins>, determine if the plugin version.
  Returns a blank string if this information is not available. 






<with-environments>
Repeats on the available execution environments, which are usually ‘development’, ‘test’ and ‘production’

  <environment-name>
 Within <with-environments>,  the environment name in context

  <database-type>
Within <with-environments>,  the database type in context
 
  <database-name>
 Within <with-environments>,  the database name in context

<with-models>
Repeats on available models. Does not return models defined in libraries or plugins.
   
  <model-name>
  Within <with-models>, returns the internal model name.

  <model-table-name>
 Within <with-models>, returns the model’s physical table name.

<with-model-columns>
Repeats on the columns within a model.

  <model-column-type>
   Within <with-model-columns>, returns the column type.

   <model-column-name>
   Within <with-model-columns>, returns the column type.

<with-model-associations>
Given a model, repeats on the associations.

  <model-association-name>
  Within <with-model-associations>, returns the association name.
  
  <model-association-macro>
  Within <with-model-associations>, returns the association type.

  <model-association-class-name>
  Within <with-model-associations>, returns the association class name.



Rapid Support 

Rapid Support is the home for some tags that are useful in defining other tags.


<with-fields>
<with-field-names>

<with-fields>
Call with the context set to a record. Repeats the content of the tag with this and this_field set to the value and name of each of the record’s fields in turn. E.g. this is useful for generating a form containing each of the fields. Tags like <field-list> and <table> forward their attributes to this tag and also have the features described here. For example, the fields attribute to <field-list> supports the same options as described here.

Parameters
default 
default 
Attributes
fields - set to one of:
A model class - equivalent to listing all of the regular ‘content columns’ of that model
’*’ - equivalent to listing all of the regular ‘content columns’ of the current record
A comma separated list of field names. Defaults to ’*’
associations - set to has_many to select the associations has_many relationships used as the “fields”. Do not also give the fields attribute.
skip - comma separated list of field names to omit.
skip-associations - set to has-many to omit all has_many associations.
include-timestamps - whether or not to include the standard ActiveRecord timestamp fields such as created_at and updated_at. Defaults to false.
force-all - by default fields are skipped if the current user does not have view permission. Set force-all to true to skip this permission check and include all the fields.

<with-field-names>
Call with the context set to a model class. Repeats the content of the tag with this set name of each of the model’s fields in turn.  For example, this tag is used when generating the heading row in:
 <table fields='...'/>.

	
Attributes
fields - set to one of:

A model class - equivalent to listing all of the regular ‘content columns’ of that model
’*’ - equivalent to listing all of the regular ‘content columns’ of the current record
A comma separated list of field names. Defaults to ’*’
skip - comma separated list of field names to omit.
skip-associations - set to has-many to omit all has_many associations.
include-timestamps - whether or not to include the standard ActiveRecord timestamp fields such as created_at and updated_at. Defaults to false.

Rapid User Pages 

Rapid User Pages contains tags that implement the basics of Hobo’s user management: log in, sign up, forgot password etc.

<simple-page>
<login-page>
<forgot-password-page>
<forgot-password-email-sent-page>
<account-disabled-page>
<account-page>


<simple-page>
Some of the user pages use a simplified layout that does not feature things like the main nav and live-search. This tag defines that page

<login-page>
Simple log-in page

Parameters
body 
content 
content-header 
heading 
content-body 
form 
labeled-item-list 
login-label 
login-input 
password-label 
password-input 
remember-me 
remember-me-label 
remember-me-input 
actions 
submit 
forgot-password 

<forgot-password-page>
The page that initiates the forgotten password process. Contains a single text-input where the user can provide their email address


Parameters
body 
content 
content-header 
heading 
content-body 
form 
list-item-list 
email-address-label 
email-address-input 
actions 
submit 

<forgot-password-email-sent-page>
Second page in the forgotten password process. Informs the user that the email has been sent “If the e-mail address you entered is in our records”. This is to avoid a privacy concern that the forgotten-password mechanism can be otherwise used to tell if a given email is associated with an account or not.

Parameters
body 
content 
content-header 
h2 
content-body 
message 

<account-disabled-page>
The page that is displayed on attempting to log in to an account that has been disabled.

Parameters
body 
content 
content-header 
h2 
content-body 

<account-page>
Basic account page that provides the ability for the user to change their email address and password.

Parameters
body 
content 
content-header 
heading 
content-body 
error-messages 
form 
field-list 
actions 
submit 
INDEX
A
account	65, 88, 90, 117, 277, 337, 341, 380, 410, 484, 517, 518, 519, 535, 536
Account Navigation	517
acting_user	90, 91, 92, 93, 117, 233, 234, 310, 312, 364, 365, 366, 367, 370, 371, 374, 375, 376, 377, 397, 401, 402, 403
acting_user.signed_up?	92, 93, 233, 234, 310, 312, 364, 365, 366
action	90, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 107, 125, 136, 137, 138, 142, 145, 165, 171, 186, 193, 202, 203, 204, 222, 223, 225, 251, 254, 298, 308, 311, 312, 315, 316, 360, 361, 362, 364, 380, 381, 382, 383, 384, 385, 386, 388, 389, 390, 391, 400, 403, 406, 407, 408, 409, 411, 449, 492, 493, 503, 504, 507, 523
actions	92, 94, 95, 96, 97, 100, 101, 102, 104, 120, 132, 133, 136, 183, 195, 198, 199, 200, 203, 222, 223, 226, 229, 254, 312, 316, 360, 361, 363, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 390, 393, 398, 405, 406, 407, 408, 409, 534, 535, 536
Administration Sub-Site	317
agile	208
AJAX-progress	490, 500, 519
alias-of	473
all_attributes	454, 455, 469
all_changed?	366, 372
any_changed?	366, 372
application.css	289, 291, 292, 294, 295, 300, 302, 306
application.dryml	66, 104, 106, 119, 135, 138, 139, 142, 143, 144, 146, 147, 148, 158, 165, 167, 168, 173, 176, 185, 186, 187, 191, 196, 197, 198, 237, 238, 241, 256, 258, 261, 265, 290, 294, 297, 298, 301, 303, 306, 307, 309, 361, 362, 472
associated record collection	173
Association Scopes	433, 437
associations	18, 108, 110, 125, 210, 229, 320, 365, 366, 371, 499, 506, 508, 532, 533
attr_accessible	368
attr_protected	368, 369, 374, 399
attr_readonly	368, 369
attribute	86, 98, 109, 115, 149, 153, 155, 156, 168, 174, 175, 179, 180, 182, 187, 191, 192, 193, 195, 196, 197, 203, 242, 248, 249, 253, 257, 260, 275, 280, 363, 364, 365, 366, 367, 368, 369, 370, 372, 374, 390, 400, 401, 402, 441, 443, 445, 446, 449, 451, 452, 453, 454, 455, 456, 457, 459, 460, 464, 469, 473, 474, 478, 480, 481, 485, 486, 488, 489, 490, 491, 493, 494, 496, 504, 507, 508, 510, 511, 515, 520, 521, 532
attributes	158, 243, 274, 361, 365, 366, 367, 368, 369, 370, 373, 387, 395, 396, 397, 400, 402, 441, 442, 451, 452, 453, 454, 455, 456, 457, 459, 460, 461, 463, 465, 468, 469, 477, 493, 495, 499, 504, 505, 506, 512, 516, 518, 532
attrs	298, 308, 453, 454, 455, 456, 479
auto_actions	94, 95, 96, 97, 99, 100, 101, 102, 223, 224, 225, 226, 227, 230, 254, 267, 276, 280, 312, 318, 379, 380, 382, 383, 391, 405, 406
auto-generated	19, 104, 132, 133, 135, 136, 165, 168, 185, 186, 190, 193, 194, 195, 198, 202, 204, 244, 360, 361
Auto-Generated Tag	130, 133
autocomplete	389, 390, 507
B
bar chart	270, 272
before_filter	267
belongs_to	111, 112, 119, 121, 122, 128, 211, 212, 254, 310, 320, 365, 366, 371, 372, 375, 380, 381, 397, 401, 402, 404, 433, 438, 449, 499, 506, 507, 511
body	88, 109, 110, 121, 138, 155, 168, 169, 171, 172, 174, 176, 177, 183, 184, 187, 188, 189, 190, 191, 195, 197, 200, 209, 242, 246, 275, 289, 291, 295, 297, 301, 302, 308, 313, 428, 441, 442, 443, 444, 445, 446, 447, 448, 449, 451, 462, 463, 466, 467, 468, 469, 470, 473, 474, 478, 479, 485, 486, 489, 495, 496, 510, 514, 519, 534, 535, 536
Boolean scopes	435
Boolean Scopes	432
by_most_recent	432, 436
C
can_call?	378
can_create?	378
can_delete?	378
can_edit?	202, 378, 511
can_update?	378
card	133, 136, 143, 145, 146, 168, 169, 171, 172, 173, 176, 177, 241, 242, 246, 361, 415, 466, 467, 468, 469, 471, 472, 473, 474, 475, 476, 477, 514, 515, 516, 523
card merge-params=	471
cards.dryml	65, 66, 104, 132, 135, 143, 176, 361, 514
Chaining	433, 439
changed	67, 96, 139, 140, 141, 142, 146, 161, 162, 163, 196, 232, 234, 253, 289, 347, 365, 366, 367, 369, 370, 371, 372, 499, 500
changed?	234, 365, 366, 370, 371, 372
Changing Field Names	56, 73
Changing Field Names and Displaying Hints	56
Charts	264, 266
children	415, 416, 429
CKEditor	206, 251, 259, 260, 262
close-button	522
collection	14, 145, 146, 165, 167, 168, 169, 170, 171, 172, 173, 174, 175, 177, 179, 180, 181, 182, 188, 190, 195, 209, 242, 245, 246, 248, 249, 268, 271, 360, 361, 381, 403, 415, 416, 452, 458, 459, 460, 466, 467, 473, 486, 488, 489, 491, 493, 494, 499, 504, 506, 509, 510, 513, 514, 523
Colons in tag names	481
Constraints	53
content	150, 153, 154, 155, 156, 163, 168, 170, 179, 190, 192, 198, 242, 243, 245, 249, 283, 285, 297, 298, 300, 301, 302, 303, 304, 306, 307, 360, 393, 410, 416, 444, 445, 446, 447, 449, 451, 455, 456, 457, 458, 461, 462, 463, 464, 468, 474, 476, 477, 479, 480, 481, 486, 489, 492, 497, 498, 510, 517, 519, 520, 521, 532, 533, 534, 535, 536
content-body	155, 191, 192, 204, 245, 534, 535, 536
content-header	155, 520, 534, 535, 536
context	171, 178, 196, 197, 198, 204, 242, 246, 381, 383, 401, 402, 403, 448, 449, 451, 452, 460, 462, 473, 485, 486, 489, 490, 491, 492, 493, 495, 504, 505, 506, 507, 509, 510, 511, 513, 523, 532
controls	19, 70, 92, 125, 195, 311, 312, 488, 489
Core	484, 485, 487
Create	58, 60, 65, 66, 69, 79, 80, 87, 88, 89, 92, 120, 153, 166, 186, 196, 204, 209, 225, 235, 254, 277, 337, 342, 363, 373, 374, 406, 411
create a new tag from an existing tag	471
create an alias of a tag	473
create_permitted?	90, 91, 92, 117, 233, 364, 366, 376
Creating Tags from Tags	130, 156
CRUD	373
CSS	77, 132, 171, 172, 192, 283, 285, 288, 291, 292, 294, 298, 299, 302, 304, 305, 445, 455, 478, 497, 506, 514, 517, 521
CSS stylesheet	283, 285
D
dasherize	491
data flow	15
database schema	63, 87, 113, 343, 344
database.yml	43, 46, 47
Date scopes	435
Date Scopes	432
def index	183, 383, 385, 388
default message text	153
Delete	179, 373
delete-button	360, 361, 488, 489, 506
destroy_permitted?	90, 91, 92, 93, 232, 233, 364, 367
dev-user-changer	487, 518
Directories and Generators	56, 58
display a list of records	132
display a single record	103
display collections of record	132, 173
Display model data in table form	179
div.page-header	291, 292, 294, 295, 296
do_transition_action	316, 408
down-arrow	523
drop-down	61, 107, 109, 110, 125, 195, 197, 208
DRY	14, 18, 125
DRYML	14, 17, 19, 54, 77, 130, 131, 132, 134, 143, 149, 151, 155, 156, 161, 163, 165, 166, 237, 241, 242, 247, 253, 257, 283, 297, 304, 306, 362, 363, 381, 383, 391, 440, 441, 442, 443, 445, 446, 447, 448, 449, 451, 452, 453, 454, 455, 456, 457, 459, 460, 464, 465, 468, 471, 473, 476, 477, 478, 480, 481, 482, 483, 484, 485, 486
DRYML Guide	247, 440, 448, 473
E
Edit Page	130, 194
edit_permitted?	368, 369, 370, 374
edit-link	202, 488, 489
edit.dryml	257
Editing Auto-Generated Tags	130, 133
Editing the Navigation Tabs	56, 104
email-address-input	535
email-address-label	535
empty-message	249, 515, 523
enum_string	109, 110, 229, 251
erb	361
ERB	237, 440, 441, 442, 478
error-messages	195, 198, 199, 200, 536
extending a tag	158
Extending a tag	471
F
Field Validation	56, 79
field_names	428
field-heading-row	488
field-list	185, 187, 188, 189, 190, 194, 195, 196, 197, 198, 199, 252, 253, 256, 258, 360, 361, 487, 510, 532, 536
flash components	263
flexibility	14, 15, 132, 440, 465
force	68, 72, 101, 112, 271, 493, 494, 495
force-all	488, 532
forgot-password	534
form	66, 70, 77, 79, 80, 92, 98, 100, 103, 125, 132, 133, 136, 138, 146, 150, 179, 194, 195, 196, 197, 198, 199, 200, 201, 225, 234, 235, 236, 252, 256, 257, 258, 262, 263, 280, 298, 299, 308, 316, 360, 361, 368, 369, 376, 384, 385, 387, 389, 406, 408, 411, 434, 437, 442, 447, 452, 480, 499, 503, 504, 505, 507, 508, 509, 510, 532, 534, 535, 536
Form Tag	194
format	153, 154, 169, 263, 385, 386, 489, 493, 496
FusionCharts	263, 264, 265, 266, 268, 269, 270, 272, 273
G
gem list	28, 29
gems	28, 45, 54, 325, 326, 340, 342, 343
Git	218, 327, 328, 329, 331
github.com	325, 326, 342
gravatar	523
gravatar.com	523
Guest user	312, 315
GUI	110, 114, 119
H
has_many	119, 121, 122, 128, 211, 212, 233, 235, 256, 371, 386, 404, 433, 438, 494, 507, 508, 509, 510, 511, 513, 532, 533
has_many 	
through relationships	128
header	155, 171, 176, 177, 290, 296, 362, 416, 476, 477, 489, 497, 514, 519, 522
heading	171, 176, 177, 188, 283, 286, 301, 308, 416, 460, 462, 463, 464, 466, 467, 468, 469, 471, 473, 474, 476, 477, 489, 508, 520, 523, 532, 534, 535, 536
Heroku	206, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347
heroku create	341
heroku db	
pull	347
push	346
heroku git push	342
Heroku.com	334, 336, 337, 339, 344, 345, 346, 347
Hobo	5, 14, 15, 16, 17, 18, 19, 20, 21, 46, 47, 50, 54, 56, 58, 59, 60, 61, 65, 66, 67, 68, 69, 70, 71, 72, 73, 77, 79, 81, 82, 85, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 101, 102, 103, 104, 105, 107, 108, 110, 111, 112, 113, 116, 117, 119, 120, 122, 125, 126, 127, 131, 132, 133, 135, 136, 138, 139, 141, 142, 143, 144, 145, 146, 148, 149, 151, 155, 156, 158, 165, 166, 167, 171, 172, 174, 175, 176, 178, 179, 180, 181, 182, 185, 186, 188, 190, 192, 193, 195, 196, 198, 200, 201, 202, 203, 204, 205, 209, 212, 222, 223, 224, 225, 229, 231, 235, 237, 243, 248, 253, 254, 256, 257, 259, 260, 261, 262, 274, 280, 281, 282, 283, 285, 286, 309, 325, 326, 336, 342, 343, 350, 360, 361, 362, 363, 364, 365, 367, 368, 369, 370, 371, 372, 373, 375, 377, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 398, 400, 405, 406, 408, 410, 411, 413, 415, 428, 429, 434, 435, 440, 441, 448, 454, 462, 463, 465, 470, 483, 484, 486, 491, 497, 499, 503, 504, 508, 515, 516, 522, 523, 534
Hobo Controllers	56, 94
Hobo Index Generation	320
Hobo Lifecycles	17, 310, 316, 392
Hobo Model Controller	17
Hobo Scopes	432
hobo_create	387, 388
hobo_create_for	388
hobo_index_for	387, 388
hobo_migration	18, 58, 63, 66, 68, 69, 70, 71, 72, 73, 88, 89, 113, 120, 135, 166, 212, 219, 229, 254, 256, 274, 277, 278, 280, 286, 311
hobo_model	18, 58, 67, 69, 71, 73, 94, 95, 96, 97, 99, 100, 101, 102, 109, 110, 111, 121, 210, 227, 233, 267, 318, 320, 377, 379, 382, 383, 393, 433, 507
hobo_model_controller	58, 94, 95, 96, 97, 99, 100, 101, 102, 227, 267, 318, 379, 382, 383
hobo_model_resource	58, 66, 67, 69, 88, 91, 110, 111, 209, 254, 274, 275, 278
hobo_new	384, 386, 388
hobo_new_for	388
hobo_reorder	391
hobo_show	383, 384, 386
hobo_update	384, 385, 387, 388
hobo_user_model	377, 507
href, name	455, 493
HTML	94, 106, 132, 133, 143, 149, 153, 155, 156, 161, 163, 168, 170, 172, 192, 201, 237, 241, 260, 261, 285, 289, 360, 385, 388, 389, 447, 448, 455, 461, 465, 468, 480, 481, 482, 488, 491, 496, 497, 498, 503, 506, 510, 511, 520
I
id_rsa.pub	333
if-present	490, 491
implicit	171, 174, 237, 246, 448, 458, 459, 460
implicit context	171, 174, 237, 246, 448, 458, 459, 460
include	20, 58, 83, 97, 132, 139, 235, 265, 309, 366, 377, 379, 386, 403, 404, 405, 411, 432, 437, 461, 463, 480, 490, 494, 499, 500, 505, 506, 507, 509, 521, 532, 533
include-timestamps	532, 533
index_action	382, 385
index.dryml	142, 143, 149, 153, 155, 158, 160, 161, 165, 166, 167, 168, 173, 175, 179, 238, 240, 266, 269, 297, 299, 301, 303, 311
Indexes	18, 52
Inline Booleans	416, 417
instance variables	250, 384
Introduction to Permissions	56, 87
is	5, 14, 15, 17, xviii, 19, 20, 36, 43, 45, 46, 47, 49, 54, 57, 58, 59, 61, 63, 65, 66, 67, 68, 69, 72, 73, 74, 76, 77, 79, 81, 82, 83, 85, 86, 87, 89, 90, 91, 92, 94, 95, 97, 98, 100, 102, 104, 105, 107, 108, 109, 110, 111, 112, 113, 116, 117, 118, 119, 122, 124, 125, 128, 129, 131, 132, 133, 135, 136, 137, 138, 139, 140, 142, 143, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 158, 161, 162, 163, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 178, 179, 181, 182, 183, 186, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 200, 201, 203, 204, 208, 209, 211, 214, 215, 218, 219, 222, 224, 225, 226, 230, 232, 233, 234, 235, 236, 237, 238, 239, 241, 242, 243, 246, 247, 248, 249, 250, 251, 252, 253, 256, 257, 259, 260, 261, 263, 266, 268, 269, 271, 272, 273, 275, 276, 280, 282, 283, 285, 286, 288, 289, 290, 291, 292, 293, 294, 297, 298, 300, 301, 303, 304, 305, 306, 310, 311, 312, 313, 315, 316, 320, 322, 325, 326, 330, 334, 336, 342, 343, 360, 361, 362, 363, 364, 365, 367, 368, 369, 370, 371, 373, 374, 375, 376, 377, 378, 379, 380, 381, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 408, 410, 411, 413, 416, 432, 434, 435, 436, 438, 440, 441, 442, 443, 444, 446, 447, 448, 449, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 476, 477, 478, 479, 480, 481, 482, 484, 485, 486, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 499, 500, 501, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 517, 518, 519, 520, 521, 522, 523, 532, 535
J
join	174, 175, 235, 241, 242, 248, 371, 486, 494
K
Key scopes	436
Key Scopes	432
L
label	74, 80, 81, 183, 188, 189, 190, 195, 196, 198, 199, 200, 268, 269, 298, 308, 487, 493, 494, 500, 505, 506, 511, 515, 516
labelled-item-list	534, 535
lifecycle actions	312, 315, 405, 406
Lifecycle scopes	436
Lifecycles	310, 391, 398, 400, 406, 408
Lifecycles for Workflow	310
Lifecyle Scopes	432
limit	20, 320, 390, 398, 432, 436, 437, 506
Link to account page	518
Listing Data in Table Form	130, 179
Listing Data with the Index Tag	130
log-in	289, 518, 534
log-out	518
Logged in as	486, 518
logged-in-as	518
login-input	534
login-label	534
lowercase	491, 494
M
MagicMailer	393, 400
Making Your Own Tags	130
Many-to-many relationships	119
markdown-help	454, 455
Matz	54, 457
merge-attrs	106, 442, 454, 455, 456, 466, 468, 469, 471, 473, 479, 480
method	14, 86, 90, 91, 98, 102, 109, 136, 142, 156, 158, 183, 229, 230, 234, 249, 250, 271, 321, 322, 364, 365, 367, 368, 369, 372, 374, 375, 377, 378, 381, 382, 384, 385, 386, 387, 389, 390, 391, 395, 397, 398, 400, 401, 402, 403, 404, 405, 406, 408, 432, 437, 443, 448, 453, 455, 459, 460, 466, 485, 491, 492, 493, 503, 504, 505, 506
method_callable_by?(user, method_name)	374
migration	14, 18, 47, 63, 64, 65, 67, 68, 70, 72, 76, 88, 89, 110, 111, 112, 113, 122, 212, 213, 215, 251, 254, 256, 274, 277, 278, 311, 320, 321, 322, 336, 395, 400, 433
migrations	18, 72, 120, 280, 320
Model Relationships	56, 107, 119
model_name	89, 92, 136, 148
Model-View-Controller	14, 15, 54
MVC	14, 15, 16, 54, 209, 392
MySQL	31, 38, 41, 43, 322
mysysgit	327
N
name	18, 47, 50, 65, 66, 67, 68, 69, 71, 72, 73, 74, 79, 81, 82, 84, 85, 88, 89, 94, 95, 98, 99, 105, 110, 111, 112, 113, 117, 118, 119, 120, 121, 122, 136, 137, 139, 146, 147, 150, 158, 165, 171, 175, 176, 177, 187, 190, 196, 198, 208, 209, 211, 233, 237, 238, 246, 248, 250, 253, 254, 260, 261, 268, 274, 287, 298, 307, 311, 320, 321, 322, 332, 341, 342, 345, 360, 361, 362, 365, 367, 369, 370, 374, 375, 378, 379, 380, 381, 387, 388, 389, 390, 395, 397, 398, 399, 400, 401, 402, 403, 404, 405, 412, 413, 428, 433, 434, 435, 436, 437, 438, 439, 441, 442, 445, 447, 448, 449, 450, 451, 452, 455, 460, 462, 469, 471, 473, 478, 479, 481, 485, 487, 488, 489, 490, 491, 492, 499, 500, 504, 505, 506, 507, 509, 510, 512, 516, 520, 521, 522, 532
name_changed?	370
name_was	370
named_scope	312, 432
nested parameters	465, 466
never_show	367, 368, 399
New and Edit Pages With The Form Tag	130
New tags from old	468
no-filter	522
none_changed?	366, 372
not_	310, 311, 316, 391, 432, 434, 435, 438
O
only_changed?	366, 367, 372
options	45, 54, 86, 91, 92, 185, 251, 260, 273, 298, 308, 311, 321, 322, 328, 335, 336, 385, 386, 390, 398, 400, 401, 402, 409, 499, 500, 506, 508, 509, 518, 522, 523, 532
Oracle	45, 46, 47, 48, 51, 52, 211, 214, 219, 320
Oracle Object Browser	51
Oracle XE	48
order	14, 80, 107, 119, 132, 146, 147, 152, 153, 156, 183, 190, 254, 256, 263, 266, 296, 313, 322, 375, 381, 387, 391, 416, 432, 437, 448, 449, 450, 452, 472, 478, 479, 483, 501, 509, 512, 521
order_by	183, 313, 432, 437
owner	365, 366, 367, 371, 375, 380, 381, 387, 389, 403, 404
P
page-nav	517, 523
pages.dryml	65, 66, 104, 132, 135, 136, 138, 139, 143, 146, 185, 186, 193, 194, 243, 244, 245, 248, 360, 361, 362
param	146, 149, 151, 153, 154, 155, 156, 158, 161, 163, 168, 171, 176, 177, 188, 192, 195, 197, 198, 199, 200, 202, 243, 248, 297, 298, 301, 304, 307, 308, 390, 443, 444, 445, 446, 447, 449, 453, 454, 455, 456, 462, 463, 466, 467, 468, 469, 471, 472, 473, 474, 479, 480, 523
parameter tag	151, 153, 154, 156, 161, 162, 163, 168, 171, 179, 188, 189, 190, 191, 196, 198, 204, 312, 444, 447, 449, 463
params	149, 183, 250, 298, 313, 360, 383, 386, 387, 391, 396, 397, 400, 402, 408, 409, 411, 449, 468, 493, 505
parse_sort_param	183, 313
password-input	534
password-label	534
Permissions	17, 90, 117, 229, 232, 233, 234, 310, 371, 376
Permissions for data integrity	234
pie chart	271, 272, 273
Plugins	218
plural	95, 98, 102, 103, 105, 111, 136, 165, 361, 437, 491
polymorphic	194, 241, 320, 361, 449, 473, 474, 475, 495, 510, 511
polymorphic tag	473, 474, 475, 495, 510
post comments to more than one table	274
Q
query-params	493
R
rake	72, 274, 277, 278, 280, 343
rake db	
migrate	72, 274, 277, 278, 280, 343
Rapid Core	484
Rapid Document Tags	484, 497
Rapid Editing	484, 499
Rapid Forms	484, 503, 504, 505, 506
Rapid Generics	484, 514
Rapid Lifecycles	484, 516
Rapid Navigation	484, 517
Rapid Pages	519
Rapid Parameter Tag	190
Rapid Support	532
Rapid Tag Library	15, 19, 483, 484
Rapid User Pages	484, 534
rapid_core.dryml	483
rapid_document_tags.dryml	483
rapid_editng.dryml	483
rapid_forms.dryml	483
rapid_generics.dryml	483
rapid_lifecycles.dryml	483
rapid_navigation.dryml	483
rapid_pages.dryml	483
rapid_plus.dryml	483
rapid_support.dryml	483
rating	523
Read	260, 373, 384
READ_ONLY_ATTRS	366
recent	432, 436
Record Collections	165
record.creatable_by?(user)	374
record.destroyable_by?(user)	374
record.editable_by?(user, attribute=nil)	374
record.updatable_by?(user)	374
record.viewable_by?(user, attribute=nil)	374
redirect_to	316, 384, 388, 406, 407
relationship declarations	119, 120, 125
remember-me	534
remember-me-input	534
remember-me-label	534
Removing actions	222
Reordering	256
repeat tag	174, 459
Rich Text	259
Roles	229, 404
ruby script/generate	393
ruby script/server	60, 87, 108, 119, 133, 215
S
scoped variables	478, 479
Scopes	432
Scoping Associations	438
search	5, xviii, 58, 69, 179, 183, 184, 248, 249, 250, 274, 298, 299, 307, 308, 313, 432, 435, 437, 474, 514, 519, 522
search-form	522
search-submit	522
Self-closing tags	480, 481
Show Page	130, 185, 202
Show Page Tag	202
show_action	382, 385
show.dryml	185, 186, 187, 188, 192, 193, 204, 243, 245, 248, 252, 362
sign-up	289, 518
Simple log-in page	534
Simple Scopes	434
size	86, 336, 385, 465, 523
skip	21, 86, 282, 442, 457, 488, 511, 532, 533
skip-associations	532, 533
sortable-options	523
state	68, 69, 71, 72, 73, 100, 107, 119, 310, 311, 312, 313, 314, 321, 366, 367, 369, 376, 392, 394, 395, 396, 397, 398, 400, 401, 402, 403, 411, 433, 434, 436
Static scopes	436
Static Scopes	432
status_changed?	365, 366
status_was	365
stylesheets	77, 283, 289, 306, 307, 519
Sub-Site	319
submit	195, 196, 198, 199, 200, 252, 263, 298, 308, 316, 360, 361, 389, 405, 412, 505, 508, 534, 535, 536
T
tag polymorphism	196, 197
taglibs	65, 104, 119, 131, 134, 135, 138, 139, 158, 165, 167, 176, 237, 241, 243, 248, 261, 286, 306, 480, 503, 514, 516
tbody	488
tfoot	488
The <a> Tag Hyperlink	130
thead	488
theme	282, 283, 285, 296, 490, 494, 521
this_field	451, 452, 487, 488, 532
this_parent	451, 452
timestamps	67, 70, 71, 73, 109, 110, 111, 121, 233, 433, 488
tnsnames.ora	50
to	5, 14, 15, 17, 18, 19, 20, 21, 28, 29, 36, 38, 43, 45, 46, 47, 49, 50, 51, 57, 58, 60, 61, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 76, 77, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 122, 123, 125, 126, 127, 128, 129, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 142, 143, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 160, 161, 163, 165, 166, 167, 168, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 202, 203, 204, 205, 208, 209, 210, 211, 212, 214, 215, 218, 222, 223, 224, 225, 226, 227, 229, 230, 231, 232, 234, 235, 237, 239, 241, 242, 243, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 326, 329, 330, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 416, 428, 432, 434, 435, 437, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 476, 477, 478, 479, 480, 481, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 499, 500, 501, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 532, 533, 535, 536
tr	488
trailing colon (	
) syntax	178
transition	310, 311, 312, 315, 316, 397, 401, 402, 403, 404, 405, 408, 410, 411, 516
transition actions	311
transitions	310, 316, 396, 397, 398, 399, 401, 403, 405, 408, 409, 410
U
UI	69, 73, 77, 85, 92, 96, 97, 119, 125, 134, 139, 146, 147, 234, 343, 376, 413
ul	149, 155, 158, 168, 246, 294, 301, 302, 303, 304, 308, 459, 460, 466, 479, 508, 509, 514, 517, 518
up-arrow	522
update	47, 79, 86, 90, 91, 92, 93, 95, 97, 99, 101, 102, 103, 104, 117, 183, 208, 226, 233, 234, 249, 252, 253, 257, 267, 275, 276, 279, 280, 294, 317, 319, 360, 363, 364, 365, 366, 367, 368, 369, 371, 373, 374, 377, 378, 379, 380, 383, 384, 385, 387, 388, 392, 397, 406, 408, 469, 499, 500, 504, 505, 516
Update	92, 279, 295, 363, 373
update_permitted?	90, 91, 92, 93, 117, 233, 234, 364, 365, 366, 367, 368, 369, 371
upload data to Heroku.com	345
User Comments	206, 274
user_find	373, 386
Users Controller	230
V
validates_inclusion_of	83, 85, 377
validates_numericality_of	81, 82, 85
validates_timeliness	257
View Hints	236
view_permitted?	90, 91, 233, 364, 367
ViewHints	416, 428, 429
W
with_	374, 433, 437
without_	433, 437
Working with the Show Page Tag	130, 185
Wrapping inside a parameter	476
Wrapping outside a parameter	476
X
XML	19, 133, 143, 263, 266, 267, 268, 271, 272, 386, 448, 449, 480, 481, 482
_
_after	432, 435
_before	432, 435
_between	432, 436
_contains	434
_does_not_contain	432, 434
_does_not_end	432, 435
_does_not_start	432, 435
_ends	432, 435
_is	432, 433, 434, 437
_is_not	432, 433, 434, 438
_starts	432, 434
-
--add-routes	317
--default-name	274, 277, 278, 280
--migrate	274, 277, 278, 280
<
<A-or-An>	487, 494
<a>	487, 491
<account-disabled-page>	534
<account-nav>	517
<account-page>	534
<after-submit>	503, 508
<ajax-progress>	519
<aside>	497
<belongs-to-editor>	499
<boolean-checkbox-editor>	499, 500
<call-tag>	485
<card>	514
<check-many>	503, 509
<cms-branch>	529
<cms-last-commit-time>	528
<cms-method>	528
<cms-version>	528
<collection-input>	503
<collection-list>	487
<collection-name>	487, 491
<collection-view>	487
<collection>	514
<comma-list>	487, 494
<count>	487, 493
<create-button>	503, 506
<database-name>	530
<database-type>	530
<delete-button>	503, 505
<dev-user-changer>	487
<do>	485
<doc-type>	519
<editor>	499, 500
<else	485
<empty-collection-message>	514
<environment-name>	530
<error-messages>	503, 508
<field-list>	487
<filter-menu>	522
<flash-message>	519
<flash-messages>	519
<footer>	497, 498
<forgot-password-email-sent-page>	534
<forgot-password-page>	534
<form>	503
<gem-dependencies>	529
<gem-frozen>	529
<gem-name>	529
<gem-version-required>	529
<gem-version>	529
<git-branch>	529
<git-clean>	529
<git-last-commit-time>	529
<git-version>	529
<gravatar>	522
<has-many-editor>	499
<header>	497
<hidden-id-field>	503, 509
<hobo-rapid-javascripts>	487, 490
<hobo-version>	528
<html>	519
<if-ie>	519
<if>	485
<image>	487, 490
<input-all	503
<input-all>	510
<input-many>	503, 509
<input>	503, 510
<integer-select-editor>	499, 500
<javascript>	519
<links-for-collection>	487, 494
<live-search>	522
<login-page>	534
<model-association-class-name>	531
<model-association-macro>	531
<model-association-name>	531
<model-column-name>	531
<model-column-type>	531
<model-name>	530
<model-table-name>	530
<name-one>	503, 507
<name>	490
<nav-item>	517
<navigation>	517
<nil-view>	487
<not-found-site>	519
<or-cancel>	503
<page-nav>	518
<page-scripts>	519
<page>	519
<partial>	485
<permission-denied-page>	519
<plugin-clean>	530
<plugin-location>	529
<plugin-method>	530
<plugin-name>	529
<plugin-version>	530
<preview-with-more>	522
<rails-env>	528
<rails-location>	528
<rails-root>	528
<rails-version>	528
<record-flags>	514
<remote-method-button>	503, 505
<repeat>	485
<search-card>	514
<section-group>	497
<section>	497
<select-input>	503, 507
<select-many	503
<select-many>	508
<select-menu>	503, 509
<select-one-editor>	499
<select-one>	503, 506
<simple-page>	534
<sortable-collection>	522
<spinner>	487, 490
<string-select-editor>	499
<stylesheet>	519
<submit>	503, 505
<table-plus>	522
<table>	487
<theme-stylesheet>	487, 494
<transition-button>	516
<transition-buttons>	516
<type-name>	487, 490, 491
<unless>	485
<update-button>	503, 505
<view>	487, 495
<with-environments>	530
<with-field-names>	532
<with-fields>	532
<with-gems>	529
<with-model-associations>	531
<with-model-columns>	530
<with-models>	530
<with-plugins>	529
<with>	485
<wrap>	485
<You>	487, 494
<Your>	494

